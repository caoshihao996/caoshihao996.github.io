<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Maven项目porm.xml配置资源文件问题</title>
    <url>/2021/04/10/2021_04_10_maven%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记</title>
    <url>/2021/04/15/2021_04_15_springmvc/</url>
    <content><![CDATA[<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>ssm：spring + springmvc + mybatis</p>
<p><strong>MVC三层架构：</strong></p>
<p><strong>SSM=JavaWeb做项目</strong></p>
<p><strong>Spring：IOC 和 AOP</strong></p>
<p><strong>SpringMVC：SpringMVC的执行流程</strong></p>
<p><strong>SpringMVC：SSM框架整合。</strong></p>
<a id="more"></a>

<p>MVC：模型（dao, service） 视图（jsp） 控制器</p>
<p>dao</p>
<p>service</p>
<p>servlet：转发，重定向</p>
<p>jsp/html</p>
<p><strong>MVC框架要做的事</strong></p>
<ol>
<li>将url映射到Java类或Java类的方法</li>
<li>封装用户提交的数据</li>
<li>处理请求–调用相关的业务处理–封装响应数据</li>
<li>将响应的数据进行渲染 .jsp / html 等表示层数据</li>
</ol>
<p><strong>为什么要学习SpringMVC？</strong></p>
<p>SpringMVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效，基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful风格、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p><strong>中心控制器</strong></p>
<p>​    spring的web框架围绕DispatcherServlet [调度Servlet] 设计。DispatcherServlet的作用是将请求分发到不同的处理器。</p>
<ol>
<li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。<ul>
<li>假设请求的url为：<a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li>
<li>如上的url拆分成三部分：<a href="http://localhost:8080/">http://localhost:8080</a> 域名服务器</li>
<li>SpringMVC表示部署在服务器上的web站点</li>
<li>hello表示控制器</li>
<li>通过分析，如上的url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器</li>
</ul>
</li>
<li>HandlerMapping为处理器映射，DispatcherServlet调用HandlerMapping，HandlerMapping根据请求的url查找Handler。</li>
<li>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找的控制器为：hello。</li>
<li>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等。</li>
<li>HandlerAdapter表示处理器的适配器，其按照特定规则去执行Handler。</li>
<li>Handler让具体的Controller执行。</li>
<li>Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView。</li>
<li>HandlerAdapter将视图逻辑名或者模型传递给DispatcherServlet。</li>
<li>DispatcherServlet调用视图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名。</li>
<li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li>
<li>DispatcherServlet根据视图解析器解析的结果，调用具体的视图。</li>
<li>最终视图呈现给用户</li>
</ol>
<p>注册DispatcherServlet     web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置DispatcherServlet：SpringMVC的核心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--DispatcherServlet要绑定Spring的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动级别1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    在springMVC中， /  /*</span></span><br><span class="line"><span class="comment">    /   只匹配所有的请求，不会去匹配jsp页面</span></span><br><span class="line"><span class="comment">    /*  匹配所有的请求，包括jsp页面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>配置springmvc-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.caosh.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>RequestMapping</strong></p>
<p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p><strong>解决乱码问题，在web.xml总配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置springmvc的乱码过滤器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoing<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoing<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>前后端分离时代：</strong></p>
<p><strong>后端部署后端，提供接口，提供数据</strong></p>
<p><strong>前端独立部署，负责渲染后端的数据</strong></p>
<p><strong>返回JSON</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/j1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;韩寒&quot;</span>, <span class="number">3</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        String str = mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>发现出现乱码问题，我们需要设置一下它的编码格式为utf-8，以及返回类型</p>
</li>
<li><p>通过@RequestMapping的produces属性来实现，修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>乱码统一解决</strong></p>
<p>在springmvc的配置文件中添加一段消息StringHttpMessageConverter的转换配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>@RestController  //会直接返回字符串<br>@Controller //会走视图解析器  + @ResponseBody = @RestController </p>
<h3 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">`ssmbuild`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> ssmbuild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">	bookID <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment <span class="keyword">comment</span> <span class="string">&#x27;书ID&#x27;</span>,</span><br><span class="line">	bookName <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">    bookCounts <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    detail <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`bookID`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> books(bookID, bookName, bookCounts, detail) <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;从入门到放弃&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;MySql&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;从删库到跑路&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;Linux&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;从进门到进牢&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/05/06/2021_05_06_SpringBoot/</url>
    <content><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="自动配置："><a href="#自动配置：" class="headerlink" title="自动配置："></a>自动配置：</h4><ul>
<li>可通过官网生成</li>
<li>通过IDEA的SpringInitializer生成</li>
</ul>
<h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SpringBoot的启动场景</li>
<li>比如spring-boot-starter-web，自动导入web环境所有的依赖</li>
<li>springboot会将所有的功能场景，都变成一个个启动器</li>
<li>我们要使用什么功能，就只需要找到对应的启动器就可以了<code>starter</code></li>
</ul>
<a id="more"></a>

<h4 id="主程序："><a href="#主程序：" class="headerlink" title="主程序："></a>主程序：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot01HelloworldApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot01HelloworldApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span> :springboot 的配置</span><br><span class="line">    <span class="meta">@Configuration</span>: spring配置类</span><br><span class="line">    <span class="meta">@Component</span>:说明这也是一个spring的组件</span><br><span class="line">    </span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  ： 自动导入配置</span><br><span class="line">	<span class="meta">@AutoConfigurationPackage</span>：自动配置包</span><br><span class="line">		<span class="meta">@Import(&#123;Registrar.class&#125;)</span> ：自动配置包注册</span><br><span class="line">	<span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>：自动配置导入选择</span><br><span class="line">        </span><br><span class="line"><span class="comment">//获取所有的配置        </span></span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取候选的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：springboot所有自动配置都是在启动时扫描并加载：spring.factories所有的自动配置类都在这里面，但是并不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功了。</p>
<ol>
<li>springboot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值；</li>
<li>将这些自动配置的类导入容器，自动配置就会生效，进行自动配置</li>
<li>以前我们需要自动配置的东西，现在springboot帮我们做了</li>
<li>整合JavaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure-2.4.5.jar这个包下</li>
<li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器</li>
<li>容器中也会有非常多的xxxAutoConfiguration的文件（@Bean），就是这些类给容器中导入了这个场景需要的所有组件；并自动配置，@Configuration, JavaConfig!</li>
<li>有了自动配置类，免去了我们手动编写配置文件的工作。</li>
</ol>
<p>关于SpringBoot，谈谈你的理解：</p>
<ul>
<li>自动装配</li>
<li>run</li>
</ul>
<p>全面接管SpringMVC的配置</p>
<h3 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h3><p>yaml语法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对空格的要求十分严格</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 普通的k-v</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">caosh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hanhan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">student1:</span> &#123;<span class="attr">name:</span> <span class="string">hanhan</span>,<span class="attr">age:</span> <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ptes1:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br></pre></td></tr></table></figure>

<p>yaml可以给实体类赋值</p>
<p>结论：</p>
<ul>
<li>配置yaml和配置properties都可以获取到值，强烈推荐yml</li>
<li>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下@value</li>
<li>如果说，我们呢专门编写了一个JavaBean来和配置文件进行映射，就直接使用<code>@ConfigurationProperties</code></li>
</ul>
<p>jsr303检验规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">空检查 </span><br><span class="line"><span class="meta">@Null</span> 验证对象是否为<span class="keyword">null</span> </span><br><span class="line"><span class="meta">@NotNull</span> 验证对象是否不为<span class="keyword">null</span>, 无法查检长度为<span class="number">0</span>的字符串 </span><br><span class="line"><span class="meta">@NotBlank</span> 检查约束字符串是不是Null还有被Trim的长度是否大于<span class="number">0</span>,只对字符串,且会去掉前后空格. </span><br><span class="line"><span class="meta">@NotEmpty</span> 检查约束元素是否为NULL或者是EMPTY.</span><br><span class="line"></span><br><span class="line">Booelan检查 </span><br><span class="line"><span class="meta">@AssertTrue</span> 验证 Boolean 对象是否为 <span class="keyword">true</span> </span><br><span class="line"><span class="meta">@AssertFalse</span> 验证 Boolean 对象是否为 <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">长度检查 </span><br><span class="line"><span class="meta">@Size(min=, max=)</span> 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 </span><br><span class="line"><span class="meta">@Length(min=, max=)</span> Validates that the annotated string is between min and max included.</span><br><span class="line"></span><br><span class="line">日期检查 </span><br><span class="line"><span class="meta">@Past</span> 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 </span><br><span class="line"><span class="meta">@Future</span> 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 </span><br><span class="line"><span class="meta">@Pattern</span> 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。</span><br><span class="line"></span><br><span class="line">数值检查 </span><br><span class="line">建议使用在Stirng,Integer类型，不建议使用在<span class="keyword">int</span>类型上，因为表单值为“”时无法转换为<span class="keyword">int</span>，但可以转换为Stirng为”“,Integer为<span class="keyword">null</span> </span><br><span class="line"><span class="meta">@Min</span> 验证 Number 和 String 对象是否大等于指定的值 </span><br><span class="line"><span class="meta">@Max</span> 验证 Number 和 String 对象是否小等于指定的值 </span><br><span class="line"><span class="meta">@DecimalMax</span> 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 </span><br><span class="line"><span class="meta">@DecimalMin</span> 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 </span><br><span class="line"><span class="meta">@Digits</span> 验证 Number 和 String 的构成是否合法 </span><br><span class="line"><span class="meta">@Digits(integer=,fraction=)</span> 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 </span><br><span class="line"><span class="meta">@Range(min=, max=)</span> 被指定的元素必须在合适的范围内 </span><br><span class="line"><span class="meta">@Range(min=10000,max=50000,message=”range.bean.wage”)</span> </span><br><span class="line"><span class="meta">@Valid</span> 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) </span><br><span class="line"><span class="meta">@CreditCardNumber</span>信用卡验证 </span><br><span class="line"><span class="meta">@Email</span> 验证是否是邮件地址，如果为<span class="keyword">null</span>,不进行验证，算通过验证。 </span><br><span class="line"><span class="meta">@ScriptAssert(lang= ,script=, alias=)</span> </span><br><span class="line"><span class="meta">@URL(protocol=,host=, port=,regexp=, flags=)</span></span><br></pre></td></tr></table></figure>



<h4 id="自动装配的原理"><a href="#自动装配的原理" class="headerlink" title="自动装配的原理"></a>自动装配的原理</h4><p>精髓：</p>
<ol>
<li><p>SpringBoot启动会加载大量的自动配置类；</p>
</li>
<li><p>我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
</li>
<li><p>我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在其中，我们就不需要再手动配置了）</p>
</li>
<li><p>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p><code>xxxAutoConfiguration</code>:自动配置类；给容器中添加组件；</p>
<p><code>xxxProperties</code>: 封装配置文件中的相关属性；</p>
</li>
</ol>
<h3 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h3><p>jar:webapp</p>
<p>自动装配</p>
<p>springboot到底帮我们配置了什么？我们能不能进行修改？能修改哪些东西？能不能扩展？</p>
<ul>
<li><code>xxxxAutoConfiguration</code>: 像容器中自动装配组件</li>
<li><code>xxxProperties</code>: 自动配置类，装配配置文件中自定义的一些内容</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>导入静态资源</li>
<li>首页</li>
<li>jsp，模板引擎Thymeleaf</li>
<li>装配扩展SpringMVC</li>
<li>增删改查</li>
<li>拦截器</li>
<li>国际化</li>
</ul>
<h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><ol>
<li>在springboot中，可以使用以下方式处理静态资源<ul>
<li>webjars      <code>localhost:8080/webjars/</code></li>
<li>public, static, /**, resources     <code>localhost:8080/</code></li>
</ul>
</li>
<li>优先级: resources &gt; static(默认)&gt;public</li>
</ol>
<h4 id="首页如何定制"><a href="#首页如何定制" class="headerlink" title="首页如何定制"></a>首页如何定制</h4><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>结论：只要需要使用thymeleaf，只需要导入对应的依赖就可以了。将html放在templates目录下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>在springboot中，有非常多的xxxx Configuration 帮助我们进行扩展配置，只要看见了这个东西，我们就要注意了</p>
<p>1.首页配置：</p>
<ol>
<li>注意点，所有页面的静态资源都需要使用thymeleaf接管；</li>
<li>url:@{}</li>
</ol>
<p>2.页面国际化：</p>
<ol>
<li>我们需要配置i8n文件</li>
<li>如果需要在项目中进行按钮自动切换，我们需要自定义一个国际化组件<code>LocaleResolver</code></li>
<li>记得将自己写的组件配置到spring容器 @Bean</li>
<li>#{}</li>
</ol>
<p>3.登录+拦截器</p>
<p>4.员工列表展示</p>
<ul>
<li>提取公共页面</li>
</ul>
<ol>
<li><code>th:fragment=&quot;sidebar&quot;</code></li>
<li><code>th:replace=&quot;~&#123;commons/commons::sidebar&#125;&quot;</code></li>
<li>如果要传递参数，可以直接使用（）传参，接收判断即可</li>
</ol>
<ul>
<li>列表循环展示</li>
</ul>
<p>5.添加员工</p>
<ol>
<li>按钮提交</li>
<li>跳转到添加页面</li>
<li>添加员工</li>
<li>返回首页</li>
</ol>
<p>6.crud</p>
<p>7.404</p>
<p>前端：</p>
<ul>
<li>模板</li>
<li>框架</li>
</ul>
<p>1.有一套自己熟悉的后台模板</p>
<p>2.前端界面：至少自己能够通过前端框架，组合出一个网站页面</p>
<p>3.让这个网站独立运行</p>
<h3 id="SpringSecurity（安全）"><a href="#SpringSecurity（安全）" class="headerlink" title="SpringSecurity（安全）"></a>SpringSecurity（安全）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Spring Sercurity是针对Spring项目的安全框架，也是SpringBoot底层安全模块默认的技术选型，他可以实现强大的web安全控制，对于安全控制，我们进需要引入<code>spring-boot-starter-security</code>模块，进行少量的配置，即可实现强大的安全管理。</p>
<p>在web开发中，安全第一位！过滤器，拦截器</p>
<p>功能性需求：否</p>
<p>做网站：安全应该在什么时候考虑？设计之初</p>
<ul>
<li>漏洞，隐私泄露</li>
<li>架构一旦确定，很难变更</li>
</ul>
<p>shiro、SpringSecurity</p>
<p>认证，授权</p>
<ul>
<li>功能权限</li>
<li>访问权限</li>
<li>菜单权限</li>
<li>过滤器、拦截器：大量的原生代码、冗余</li>
</ul>
<p>AOP：横切 配置类，在不改变原有代码的基础上进行配置</p>
<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><ul>
<li>Shiro是一个Java的安全框架</li>
<li>可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以应用在JavaEE环境。</li>
<li>可以完成认证、授权、登录、加密、会话管理、web集成、缓存等</li>
</ul>
<ol>
<li>导入依赖</li>
<li>配置文件</li>
<li>Hello word</li>
</ol>
<p>Spring Security都有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line">currentUser.isAuthenticated()</span><br><span class="line">currentUser.getPrincipal()</span><br><span class="line">currentUser.hasRole(<span class="string">&quot;schwartz&quot;</span>)</span><br><span class="line">currentUser.isPermitted(<span class="string">&quot;lightsaber:wield&quot;</span>)</span><br><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure>





<ul>
<li>Subject  用户</li>
<li>SecurityManager   管理所有用户</li>
<li>Realm   连接数据</li>
</ul>
<p>springboot整合shiro</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>异步任务</p>
<p>定时任务</p>
<p>邮件发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TaskScheduler  任务调度者</span><br><span class="line">TaskExecutor  任务执行者</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">//开启定时功能的注解</span></span><br><span class="line"><span class="meta">@Scheduled</span> <span class="comment">//什么时候执行</span></span><br><span class="line">    </span><br><span class="line">cron表达式    </span><br></pre></td></tr></table></figure>





<h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>在springboot2.x后，原来的Jedis被替换为了lettuce</p>
<p>jedis:采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！ BIO模式</p>
<p>lettuce:采用netty,实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数据，更像NIO模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">	RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">	template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">	StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">	template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>自定义RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义了一个RedisTemplates   固定模板</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JSOn序列化配置</span></span><br><span class="line">    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String的序列化</span></span><br><span class="line">    StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">    template.setKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">    template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">    template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">    template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">    template.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>CoinsWay</title>
    <url>/2020/12/28/CoinWays/</url>
    <content><![CDATA[<h4 id="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"><a href="#使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张" class="headerlink" title="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"></a>使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张</h4><pre><code>从左到右的模型，依次判断index位置上的纸币用几张，当index到达length时，如果rest==0，则该方法有效
返回1，否则返回0.在由暴力递归改成动态规划时，要考虑枚举问题。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ways1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：0~index-1位置上的货币使用已经确定，从index之后的货币使用方法数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选用index位置上的货币</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">1</span>; zhang*arr[<span class="keyword">index</span>] &lt;= rest; zhang++)&#123;</span><br><span class="line">		p2 += process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest - zhang*arr[<span class="keyword">index</span>]);<span class="comment">//选用index位置上的货币，至少一张</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法，每个格子有枚举行为，细粒度划分</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			<span class="built_in">int</span> ways = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">0</span>; zhang*arr[<span class="keyword">index</span>]&lt;=rest; zhang++)&#123;</span><br><span class="line">				ways += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-zhang*arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划方法，省去枚举行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];<span class="comment">//没有使用cur位置上的</span></span><br><span class="line">			<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>][rest-arr[<span class="keyword">index</span>]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CardInLine</title>
    <url>/2020/12/27/CardInLine/</url>
    <content><![CDATA[<h4 id="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"><a href="#玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值" class="headerlink" title="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"></a>玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值</h4><pre><code>给定一个整形数组arr，代表数值不同的纸牌拍成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后
拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都决定聪明。请问最后获胜者的分数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( L==R )&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(arr[L] + s(arr, L+<span class="number">1</span>, R), arr[R] + s(arr, L, R<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;			<span class="comment">//先手函数选了arr[L]</span></span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">min</span>(f(arr, L+<span class="number">1</span>, R), f(arr, L, R<span class="number">-1</span>));<span class="comment">//对手会让你选择最小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>), s(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpWay</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr ==null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">	<span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; i++)&#123;</span><br><span class="line">		f[i][i] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//s[i][i]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = i;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;N &amp;&amp; R&lt;N)&#123;</span><br><span class="line">			f[L][R] = Math.<span class="built_in">max</span>(arr[L]+s[L+<span class="number">1</span>][R], arr[R]+s[L][R<span class="number">-1</span>]);</span><br><span class="line">			s[L][R] = Math.<span class="built_in">min</span>(arr[L]+f[L+<span class="number">1</span>][R], arr[R]+f[L][R<span class="number">-1</span>]);</span><br><span class="line">			L++;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f[<span class="number">0</span>][N<span class="number">-1</span>], s[<span class="number">0</span>][N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>ConvertToLetters</title>
    <url>/2020/12/27/ConvertToLetters/</url>
    <content><![CDATA[<h4 id="将数字转化为字母有多少种方法，从左往右的尝试模型"><a href="#将数字转化为字母有多少种方法，从左往右的尝试模型" class="headerlink" title="将数字转化为字母有多少种方法，从左往右的尝试模型"></a>将数字转化为字母有多少种方法，从左往右的尝试模型</h4><pre><code>规定1和A对应、2和B对应、3和C对应...的规则。那么一个数字字符串比如“111”就可以转化为AAA、KA、AK。给定一个只
有数字字符串组成的字符串str,返回有多少种转化结果。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> numbers(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span> == <span class="keyword">null</span> || <span class="built_in">str</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(<span class="built_in">str</span>.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str[0..i-1]已经转化完了，固定了</span></span><br><span class="line"><span class="comment">//返回值：从i开始到结尾有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process1(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str[i] == &#x27;3&#x27;~&#x27;9&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> process(<span class="built_in">str</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="built_in">int</span> N = <span class="built_in">str</span>.length;</span><br><span class="line">	<span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>];</span><br><span class="line">	dp[N] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2021/03/19/BinaryTreeLayer/</url>
    <content><![CDATA[<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;<span class="type">Integer</span>&gt; PrintFromTopToBottom(TreeNode root)&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;<span class="type">Integer</span>&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			ret.<span class="keyword">add</span>(t.val);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.left);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h4 id="二叉树的多行遍历"><a href="#二叉树的多行遍历" class="headerlink" title="二叉树的多行遍历"></a>二叉树的多行遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			list.<span class="keyword">add</span>(t.val);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.lef);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">			ret.<span class="keyword">add</span>(list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt; &gt; ret = <span class="built_in">new</span> ArrayList;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.<span class="keyword">add</span>(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">reverse</span> = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    	ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> cnt = queue.size();</span><br><span class="line">    	<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">    		TreeNode t = queue.poll();</span><br><span class="line">    		<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		list.<span class="keyword">add</span>(t.val);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.left);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">reverse</span>)</span><br><span class="line">    		Colllections.reverse(list);</span><br><span class="line">    	<span class="keyword">reverse</span>=!<span class="keyword">reverse</span>;</span><br><span class="line">    	<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">    		ret.<span class="keyword">add</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>广度优先遍历</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">	<span class="comment">//找出数组中最大值和最小值</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">max</span> = Integer.MIN_VALUE;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化计数数组count[]</span></span><br><span class="line">	<span class="comment">//长度为最大值减去最小值加1，再加1</span></span><br><span class="line">	<span class="type">int</span>[] <span class="built_in">count</span> = new <span class="type">int</span>[<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数，并确保count[0]永远为0</span></span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">count</span>[num-<span class="built_in">min</span>+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计数数组变形，新元素是的值是前面元素的累加之和的值</span></span><br><span class="line">	for(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">count</span>.length;i++)&#123;</span><br><span class="line">		<span class="built_in">count</span>[i] += <span class="built_in">count</span>[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建结果数组</span></span><br><span class="line">	<span class="type">int</span>[] result = new <span class="type">int</span>[arr.length];</span><br><span class="line">	<span class="comment">//遍历arr中的元素，填充到结果数组中去，从前往后遍历</span></span><br><span class="line">	for(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]] = arr[j];</span><br><span class="line">		<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2020/12/27/Knapsack/</url>
    <content><![CDATA[<h4 id="背包问题，从左往右的尝试模型"><a href="#背包问题，从左往右的尝试模型" class="headerlink" title="背包问题，从左往右的尝试模型"></a>背包问题，从左往右的尝试模型</h4><pre><code>给定两个长度都为N的数组weights和values，weight[i]和values[i]分别代表物品的重量和价值。给定一个正数bag
表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不变：w[] v[] bag</span></span><br><span class="line"><span class="comment">//index... 最大价值</span></span><br><span class="line"><span class="comment">//0...index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span></span><br><span class="line"><span class="comment">//如果返回-1则认为没有方法，如果不返回-1，则认为返回的值是真实值</span></span><br><span class="line"><span class="comment">//函数返回值为index之后的最大价值</span></span><br><span class="line">public <span class="type">int</span> process(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> alreadyW, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="keyword">if</span>(alreadyW&gt;bag)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//index到达length时，剩余货物的最大价值为0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW, bag);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW+w[<span class="keyword">index</span>], bag);<span class="comment">//yes</span></span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="type">int</span> process1(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest-w[<span class="keyword">index</span>]);</span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">public <span class="type">int</span> dpWay(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="type">int</span> N = w.<span class="built_in">length</span>;</span><br><span class="line">	<span class="type">int</span>[][] dp = new <span class="type">int</span>[N+<span class="number">1</span>][bag+<span class="number">1</span>];<span class="comment">//dp[N][...]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">index</span>=N<span class="number">-1</span>;<span class="keyword">index</span>&gt;=<span class="number">0</span>;<span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//dp[index][rest]=?</span></span><br><span class="line">			<span class="type">int</span> p1 = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rest - w[<span class="keyword">index</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				p2 = v[<span class="keyword">index</span>] + dp[<span class="keyword">index</span>+<span class="number">1</span>][rest - w[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>NQueens</title>
    <url>/2020/12/27/NQueens/</url>
    <content><![CDATA[<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><pre><code>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n
返回n种皇后的摆法有多少种。
n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//record[i]-&gt;i行的皇后，放在了第几列</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//潜台词：record[0...i-1]的皇后，任何两个皇后都不共行、不共列、不共斜线</span></span><br><span class="line"><span class="comment">//目前来到了第i行</span></span><br><span class="line"><span class="comment">//record[0..i-1]表示之前的行，放了皇后的列的序号</span></span><br><span class="line"><span class="comment">//返回值，接着把i...之后摆完，有多少种摆法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//i来到证明前面的摆法有效，返回1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//依次尝试i行的皇后摆放在什么位置</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isValid</span>(record, i, j))&#123;</span><br><span class="line">			record[i] = j;</span><br><span class="line">			res += <span class="built_in">process</span>(i+<span class="number">1</span>, record, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(record[k] ==j || Math.<span class="built_in">abs</span>(k-i) == Math.<span class="built_in">abs</span>(recod[k]-j))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用位运算计算不超过32皇后的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&lt;<span class="number">32</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果你是9皇后问题，limit最右9个是1，其他都是0</span></span><br><span class="line">	<span class="keyword">int</span> limit = n == <span class="number">32</span> ? <span class="number">-1</span> : (<span class="number">1</span>&lt;&lt;n) <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit 划定了问题的规模，是固定的</span></span><br><span class="line"><span class="comment">//colLim 列的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDiaLim, <span class="keyword">int</span> rightDiaLim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colLim == limit)&#123;<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有候选皇后的位置，都在pos上</span></span><br><span class="line">    <span class="comment">//colLim | leftDiaLim | rightDigLim -&gt; 总限制</span></span><br><span class="line">    <span class="comment">//~(colLim | leftDiaLim | rightDigLim) -&gt; 左侧的一坨0干扰，右侧每个1可尝试</span></span><br><span class="line">    <span class="comment">//所有可以放皇后都在pos上</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//提取中pos最右侧的1，剩下位置都是0</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(limit, colLim | mostRightOne, (leftDiaLim|mostRightOne)&lt;&lt;<span class="number">1</span>,</span><br><span class="line">                (rightDiaLim|mostRightOne)&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>printAllSubSquence</title>
    <url>/2020/12/27/PrintAllSubsquences/</url>
    <content><![CDATA[<h4 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h4><hr>
<pre><code>从左往右的尝试模型，从0位置出发，依次判断每个位置的字符是否选择，当index到达字符串末尾时，将所形成的字符
path加入结果的集合中。</code></pre>
<hr>
<a id="more"></a>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subs(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	List&lt;<span class="keyword">String</span>&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	process1(<span class="built_in">str</span>, <span class="number">0</span>, ans, path);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str固定参数</span></span><br><span class="line"><span class="comment">//index，此时进行判断的位置下标，要 or 不要</span></span><br><span class="line"><span class="comment">//如果index来到str的终止位置，就把沿途路径所形成的答案放在ans中</span></span><br><span class="line"><span class="comment">//之前做出的选择就是path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, List&lt;<span class="keyword">String</span>&gt; ans, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		ans.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一个字符串的全部子序列，且要求不要重复出现的子序列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subsNoRepeate(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	process2(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">set</span>, path);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span>, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="built_in">set</span>.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PrintAllPermutations</title>
    <url>/2020/12/27/PrintAllPermutations/</url>
    <content><![CDATA[<h5 id="打印一个字符串的全部排列方式"><a href="#打印一个字符串的全部排列方式" class="headerlink" title="打印一个字符串的全部排列方式"></a>打印一个字符串的全部排列方式</h5><hr>
<pre><code>从左往右的尝试模型，排列组合的方式就是先固定0位置上的字符，即0~length-1上的字符都有可能来到0位置上，确
定0位置上的字符以后，再确定1位置上的字符，即1~length-1上的字符都有可能来到1位置上...依次类推。

在要求无重复的排列中，可以通过哈希表的方式，来记录一个字符是否在某个位置上出现过，没有出现过才进行递归。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str[0...i-1]都已经做好决定了</span></span><br><span class="line"><span class="comment">//str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">//i为终止位置，str当前的位置就是一种结果-&gt;res</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArrayList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有终止，那么i之后位置上的字符都可以来到i位置上</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; <span class="built_in">str</span>.length; j ++)&#123;</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		process(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> swap(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] temp = <span class="built_in">str</span>[i];</span><br><span class="line">	<span class="built_in">str</span>[i] = <span class="built_in">str</span>[j];</span><br><span class="line">	<span class="built_in">str</span>[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串的所有排序方式，没有重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArratList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">boolean</span>[] visit = <span class="keyword">new</span> <span class="built_in">boolean</span>[<span class="number">26</span>];<span class="comment">//26个字母，当前位置，不与其他位置共享</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;<span class="built_in">str</span>.length; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">false</span>)&#123;</span><br><span class="line">			visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">			process2(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span>[] radixSort(<span class="built_in">int</span>[] arr， <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">	<span class="built_in">int</span>[] <span class="built_in">count</span> = new <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">len</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> division = (<span class="built_in">int</span>)Math.pow(<span class="number">10</span>,i);</span><br><span class="line">		for(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[j]/division%<span class="number">10</span>;</span><br><span class="line">			<span class="built_in">count</span>[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> m=<span class="number">1</span>; m&lt;count.length;m++)&#123;</span><br><span class="line">			<span class="built_in">count</span>[m] = <span class="built_in">count</span>[m] + <span class="built_in">count</span>[m-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> <span class="built_in">n</span>=arr.length-<span class="number">1</span>;<span class="built_in">n</span>&gt;=<span class="number">0</span>;<span class="built_in">n</span>--)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[<span class="built_in">n</span>] / division % <span class="number">10</span>;</span><br><span class="line">			result[<span class="built_in">count</span>[num]]=arr[<span class="built_in">n</span>];</span><br><span class="line">			<span class="built_in">count</span>[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		Arrays.fill(<span class="built_in">count</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotMove</title>
    <url>/2020/12/27/RobotMove/</url>
    <content><![CDATA[<h4 id="机器人的移动问题"><a href="#机器人的移动问题" class="headerlink" title="机器人的移动问题"></a>机器人的移动问题</h4><pre><code>假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个）。
如果机器人来打1位置上，那么下一步一定只能往右走来打2位置；如果机器人来到N位置，那么下一步只能往左来到N-1
的位置；如果机器人来打中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也
是1~N中的一个）的方法有多少种，给定四个参数N、M、K、P，返回方法数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//总共N个位置，从M点出发，还剩K步，返回最终能到达P的方法数</span></span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, M, K, P)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N:位置1~N，固定参数</span></span><br><span class="line"><span class="comment">//cur:当前在cur位置，可变参数</span></span><br><span class="line"><span class="comment">//rest:剩余的步数，可变参数</span></span><br><span class="line"><span class="comment">//P：最终的目标位置</span></span><br><span class="line"><span class="comment">//该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果没有剩余步数了，当前的cur位置就是最后的位置</span></span><br><span class="line">    <span class="comment">//如果最后的位置停在P上，那么之前做的移动是有效的</span></span><br><span class="line">    <span class="comment">//如果最后的位置没在P上，那么之前做的移动式无效</span></span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> cur==P ? <span class="number">1</span> : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span></span><br><span class="line">    <span class="comment">//后续的过程就是，来到2位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, <span class="number">2</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span></span><br><span class="line">	<span class="comment">//后续的过程就是，来到N-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以想左也可以向右</span></span><br><span class="line">    <span class="comment">//走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">//走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P) + walk(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">waysCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;=N; row++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;=K;col++)&#123;</span><br><span class="line">			dp[row][col]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walkCache</span><span class="params">(N, M, K, P, dp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表方法，把cur和rest所有方法加入到缓存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walkCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[cur][rest]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		dp[cur][rest] = cur == P ? <span class="number">1</span> : 0;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, <span class="number">2</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[cur][rest] = walkCache(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P, dp) + walkCache(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">	<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">dpWays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	dp[P][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//dp[!P][...]=0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= K; rest++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">1</span>; cur &lt;= N; cur++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">				dp[cur][rest] = dp[<span class="number">2</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(cur==N)</span></span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[N<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[cur+<span class="number">1</span>][rest<span class="number">-1</span>]+dp[cur<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[M][P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/12/28/SnackWays/</url>
    <content><![CDATA[<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><pre><code>背包容量为w，一共有n袋零食，第i袋零食体积为v[i], 总体积不超过背包容量的
情况下，一共有多少种零食方法？（总体积为0也算一种方法）</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> nums(<span class="built_in">int</span>[] v, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == <span class="literal">null</span> || v.length==<span class="number">0</span> || w &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(v, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//rest&gt;=0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的零食</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>]=&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		p2 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest-arr[<span class="keyword">index</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span> || w&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][w+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest&lt;=w; rest++)&#123;</span><br><span class="line">		dp[N][rest] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N<span class="number">-1</span>; <span class="keyword">index</span> &lt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest &lt;= w; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line">			<span class="keyword">if</span>(rest-arr[<span class="keyword">index</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">			h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">//初始化gap的方法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap=h;gap&gt;<span class="number">0</span>;gap=(gap<span class="number">-1</span>)/<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;gap<span class="number">-1</span>;j-=gap)&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		arr[i] = arr[j] + arr[i];</span><br><span class="line">		arr[j] = arr[i] - arr[j];</span><br><span class="line">		arr[i] = arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> boolean exist(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">num</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="comment">//防止溢出</span></span><br><span class="line">	  mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">if</span>(arr[mid]==<span class="built_in">num</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;<span class="built_in">num</span>) right = mid - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">else</span> left = left + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid] == <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static <span class="built_in">int</span> nearestIndex(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">value</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">index</span> = -<span class="number">1</span>;//记录最左侧的下标</span><br><span class="line">	while(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span> - <span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;=<span class="built_in">value</span>)&#123;</span><br><span class="line">			<span class="built_in">index</span> = <span class="built_in">mid</span>;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">index</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> getLessIndex(<span class="built_in">int</span>[] arr)&#123;</span><br><span class="line">	<span class="built_in">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>])&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr[arr.length - <span class="number">2</span>] &gt; arr[arr.length - <span class="number">1</span>])&#123;</span><br><span class="line">		return arr.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	while(<span class="built_in">left</span>&lt;<span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span>-<span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else <span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> + <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/03/28/Proxy/</url>
    <content><![CDATA[<h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h3><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真是对象（real object ）的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个执行方法前后你可以增加一些自定义的操作。</strong></p>
<h3 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2.静态代理"></a>2.静态代理</h3><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的。实际场景中非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p><strong>上面我们是从实现和应用的角度来说静态代理，从JVM层面来说，静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。</strong></p>
<p>静态代理实现步骤：</p>
<ol>
<li>定义一个接口机器实现类；</li>
<li>创建一个代理类同样实现这个接口；</li>
<li>将目标对象注入代理类，然后再代理类的对应方法调用目标类的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以再目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类（CGLIB动态代理机制）。</p>
<p><strong>从JVM角度来说，动态代理是在运行时动态生成类字节码，并加载到JVM中。</strong></p>
<p>说到动态代理，Spring AOP、RPC框架应该是不得不提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理再我们日常开发总使用的相对较少，但是再框架中几乎是是比用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常用帮助。</strong></p>
<p>就Java来时，动态代理的实现方式有很多种，比如JDK动态代理、CGLIB动态代理等等。</p>
<h4 id="3-1-JDK动态代理机制"><a href="#3-1-JDK动态代理机制" class="headerlink" title="3.1.JDK动态代理机制"></a>3.1.JDK动态代理机制</h4><h5 id="3-1-1介绍"><a href="#3-1-1介绍" class="headerlink" title="3.1.1介绍"></a>3.1.1介绍</h5><p><strong>在Java动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p>Proxy类中使用频率最高的方法是： <code>newProxyInstance()</code>，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有三个参数：</p>
<ol>
<li>loader:类加载器，用于加载代理对象。</li>
<li>interfaces:被代理类实现的一些接口。</li>
<li>h : 实现了 <code>InvocationHandler</code> 接口的对象。</li>
</ol>
<p>要实现动态代理的话，还必须要实现 <code>InvocationHandler</code>来自定义处理逻辑。当我们的动态代理对象调用一个方法的时候，这个方法的调用就会被转发到实现 <code>InvocationHandler</code>接口类的 <code>invoke</code>方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h5 id="3-1-2-JDK动态代理类使用步骤"><a href="#3-1-2-JDK动态代理类使用步骤" class="headerlink" title="3.1.2.JDK动态代理类使用步骤"></a>3.1.2.JDK动态代理类使用步骤</h5><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义<code>InnvocationHandler</code>并重写 <code>invoke()</code>方法，在 <code>invoke()</code>方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象。</li>
</ol>
<h5 id="3-1-3-代码示例"><a href="#3-1-3-代码示例" class="headerlink" title="3.1.3.代码示例"></a>3.1.3.代码示例</h5><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个JDK动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-CGLIB动态代理机制"><a href="#3-2-CGLIB动态代理机制" class="headerlink" title="3.2.CGLIB动态代理机制"></a>3.2.CGLIB动态代理机制</h4><h5 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1.介绍"></a>3.2.1.介绍</h5><p><strong>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用CGLIB动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>methodProxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h5 id="3-2-2-CGLIB动态代理类使用步骤"><a href="#3-2-2-CGLIB动态代理类使用步骤" class="headerlink" title="3.2.2.CGLIB动态代理类使用步骤"></a>3.2.2.CGLIB动态代理类使用步骤</h5><ol>
<li>自定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h5 id="3-2-3-代码示例"><a href="#3-2-3-代码示例" class="headerlink" title="3.2.3.代码示例"></a>3.2.3.代码示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-JDK动态代理和CGLIB动态代理对比"><a href="#3-3-JDK动态代理和CGLIB动态代理对比" class="headerlink" title="3.3.JDK动态代理和CGLIB动态代理对比"></a>3.3.JDK动态代理和CGLIB动态代理对比</h4><ol>
<li><strong>JDK动态代理只能代理实现了接口的类或者直至代理接口，而CGLIB可以代理未实现任何接口的类。</strong>另外，CGLIB动态代理是通过一个被代理类的子拦截器来拦截被代理类的方法调用，因此不能代理生声明为final类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="４-静态代理和动态代理的对比"><a href="#４-静态代理和动态代理的对比" class="headerlink" title="４.静态代理和动态代理的对比"></a>４.静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
      <categories>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
        <tag>jdk动态代理</tag>
        <tag>cglib动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QucikSort</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		sort(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = partition(arr, left, right);<span class="comment">//获取pivot的位置</span></span><br><span class="line">		sort(arr,left,mid-<span class="number">1</span>);</span><br><span class="line">		sort(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = start;</span><br><span class="line">		<span class="keyword">int</span> right = end - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> pivot = arr[end];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">while</span>(left&lt;=right &amp;&amp; arr[left]&lt;=pivot)left++;</span><br><span class="line">			<span class="keyword">while</span>(left&lt;=right &amp;&amp; arr[right]&gt;pivot)right--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(left&lt;right)swap(arr,left,right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		swap(arr, left, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2021/03/25/mysql/</url>
    <content><![CDATA[<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5之前）。虽然性能极佳，而且提供大量的特性，包括全文索引、压缩、空间函数等，单MyISAM不支持事务和行级锁，最大的缺陷就是崩溃后无法安全回复。不过，5.5版本之后，MySQL引入了InnoDB（事务性性数据库引擎），MySQL5.5版本后默认的引擎为InnoDB。</p>
<a id="more"></a>
<p>大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用MyISAM也是合适的比如读密集的情况下。（如果不介意崩溃恢复的问题）。</p>
<p><strong>两者的对比</strong></p>
<ol>
<li><strong>是否支持行级锁</strong>：MyISAM只有表级锁（table-level locking）,而InnoDB支持行级锁（row-level locking）和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持，外部键等高级数据库功能。具有事务（commit）、回滚（rollback）和崩溃修复能力和事务安全型表。</li>
<li><strong>是否支持外键</strong>：MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong>：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在READ COMMITTED和REPEATABLE READ 两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现；各数据库中MVCC实现并不统一。</li>
</ol>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong>和<strong>哈希索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议使用BTree索引。</p>
<p>MySQL的BTree索引使用的是B+Tree，但是对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM</strong>：B+Tree叶节点的data域存放的数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB</strong>：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务时逻辑上的一组操作，要么执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说的例子就是转账。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的月增加1000元。万一这两个操作之间突然出现错误比如银行系统崩溃，导致小明的余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都失败。</p>
<h4 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h4><ul>
<li><strong>原子性（Atomicity）</strong>：事务时最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）</strong>：执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务干扰，个并发事务之间的数据库是独立的；</li>
<li><strong>持久性（Durability）</strong>：一个事务被提交之后。它对数据库中数据的改变是永久的，即使数据库发生故障也不应对其有任何影响。</li>
</ul>
<h4 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个任务对同一数据操作）。并发虽然是必须的，单可能会导致以下问题。</p>
<ul>
<li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到这个数据是“脏数据”，一句脏数据所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）</strong>：指在一个事务内多次读取数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内修改结果就被丢失，因此称丢失修改。</li>
<li><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问了该数据。那么第一个事务两次读取的数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据可能不一样的情况，依次称为不可重读。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本根本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="事务隔离级别有哪些？MySQL的默认隔离级别是？"><a href="#事务隔离级别有哪些？MySQL的默认隔离级别是？" class="headerlink" title="事务隔离级别有哪些？MySQL的默认隔离级别是？"></a>事务隔离级别有哪些？MySQL的默认隔离级别是？</h4><p><strong>SQL标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，</strong>可能会导致脏读、幻读或不可重复读。**</li>
<li><strong>READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，</strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。**</li>
<li><strong>REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，</strong>可以阻止脏读和不可重复读，但是幻读仍有可能发生。**</li>
<li><strong>SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说该级别</strong>可以防止脏读、不可重复读以及幻读。**</li>
</ul>
<p><strong>InnoDB引擎默认支持的隔离级别是REPEATABLE-READ（可重复读</strong>）。与SQL标准不同的地方在于，InnoDB在可重读事务隔离级别下使用的是<strong>Next-key Lock</strong>锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以锁InnoDB存储引擎的默认支持隔离级别已经完全可以保证事务的隔离性要求，即达到了SQL标准的<strong>SERIALIZABLE</strong>隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取已提交)**，但是需要知道的是InnoDB存储引擎默认使用</strong>REPEATABLE-READ（可重复读**）不会有任何性能损失。</p>
<p><strong>InnoDB引擎</strong>在分布式事务的情况下会用到<strong>SERIALIZABLE</strong>（可串行化）隔离级别。</p>
<h4 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h4><p><strong>MyISAM与InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁；</li>
<li>InnoDB采用行级锁和表级锁，默认使用行级锁。</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁</strong>：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和MySQL都是支持表级锁。</li>
<li><strong>行级锁</strong>：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种</strong>：</p>
<ul>
<li>Record　lock：单个行记录上的锁；</li>
<li>Gap　lock：间隙锁，锁定一个范围，不包括记录本省</li>
<li>Next-Key　lock：record＋Gap　锁定一个范围，包含巨鹿本身。</li>
</ul>
<p><strong>相关知识点</strong>：</p>
<ol>
<li>InnoDB对于行的查询使用了next-key lock</li>
<li>next-key lock为了解决幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显示关闭gap锁：A.将事务隔离级别设置为RC B.将参数innodb_lock_unsafe_for_binlog设置为1</li>
</ol>
<h4 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<p>1.<strong>限定数据范围</strong></p>
<p>务必禁止不带任何限制数据范围条件的查询语句。</p>
<p>2.<strong>读/写分离</strong></p>
<p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<p>3.<strong>垂直分区</strong></p>
<p>简单来说垂直分区是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><strong>垂直拆分的优点</strong>：可以使得列数据变小，在查询时减少读取的Block数，减少I/o次数。此外，垂直分区可以简化表结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起join操作，可以通过应用层进行Join来解决。此外，垂直分区会让事务变得更复杂。</p>
<p>4.<strong>水平分区</strong></p>
<p>保持表的结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对</p>
<p>于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。</p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。<strong>尽量不要对数据分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong>，一般数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案</strong>：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常见的实现。</strong></li>
<li><strong>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的MyCat、260的Atlas、网易的DDB等等都是这种架构。</strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Node1</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(<span class="built_in">int</span> value)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">in</span>(head.left);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">in</span>(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Satck&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			head = stack.pop();</span><br><span class="line">			System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		s1.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">			head = s1.pop();</span><br><span class="line">			s2.push(head);</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.print(s2.pop().value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用一个栈实现非递归的后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos2</span>(<span class="params">Node1 h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h != <span class="literal">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node1 c = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(c.left != <span class="literal">null</span> &amp;&amp; h!=c.left &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.right != <span class="literal">null</span> &amp;&amp; h!=c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(stack.pop()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                h=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历，非递归方法</span></span><br><span class="line"><span class="comment">//1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty() || head!=<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head);</span><br><span class="line">				head = head.left;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				head = stack.pop();</span><br><span class="line">				System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">				head = head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现二叉树的按层遍历</span></span><br><span class="line"><span class="comment"> * 1）其实就是宽度优先遍历，用队列</span></span><br><span class="line"><span class="comment"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWithUseMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	levelMap.<span class="built_in">put</span>(head, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> curLevel = <span class="number">1</span>;<span class="comment">//当前正在统计哪一层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">int</span> curNodeLevel = levelMap.<span class="built_in">get</span>(cur);</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.left, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.right, curLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span></span><br><span class="line">		<span class="keyword">if</span>(curNodeLevel == curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">max</span> = <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，不使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	Node1 curEnd = head;<span class="comment">//当前层，最右节点</span></span><br><span class="line">	Node1 nextEnd = head;<span class="comment">//下一层，最右节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的节点数</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">			nextEnd = cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">			nextEnd = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		<span class="keyword">if</span>(cur == curEnd)&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevelNodes = <span class="number">0</span>;</span><br><span class="line">			curEnd = nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历序列化与重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">preSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">	Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pres</span>(<span class="params">Node head, Queue&lt;<span class="built_in">String</span>&gt; ans</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		ans.add(<span class="literal">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByPreQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prelist == <span class="literal">null</span> || prelist.size()==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">preb</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">String</span> value = prelist.poll();</span><br><span class="line">	<span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">	head.left = preb(prelist);</span><br><span class="line">	head.right = preb(prelist);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">levelSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">    Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        ans.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByLevelQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; levelList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(levelList == <span class="literal">null</span> || levelList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNode(levelList.poll());</span><br><span class="line">        node.right = generateNode(levelList.poll());</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="function"><span class="title">generateNode</span>(<span class="params"><span class="built_in">String</span> val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4><a id="more"></a>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PrintTreeTest &#123;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">class</span> Node&#123;</span><br><span class="line">        <span class="built_in">int</span> value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="constructor">Node(<span class="params">int</span> <span class="params">v</span>)</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">Tree(Node <span class="params">head</span>)</span>&#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Binary Tree&quot;</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>, 0, <span class="string">&quot;H&quot;</span>, 17)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">InOrder(Node <span class="params">head</span>, <span class="params">int</span> <span class="params">height</span>, String <span class="params">to</span>, <span class="params">int</span> <span class="params">len</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head<span class="operator"> == </span>null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">right</span>, <span class="params">height</span>+1, <span class="string">&quot;v&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        String <span class="keyword">val</span> = <span class="keyword">to</span> + head.value + <span class="keyword">to</span>;</span><br><span class="line">        <span class="built_in">int</span> lenM = <span class="keyword">val</span>.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> lenL = (len - lenM)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        <span class="keyword">val</span> = get<span class="constructor">Space(<span class="params">lenL</span>)</span> + <span class="keyword">val</span> +get<span class="constructor">Space(<span class="params">lenR</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(get<span class="constructor">Space(<span class="params">height</span><span class="operator">*</span><span class="params">len</span>)</span> + <span class="keyword">val</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">left</span>, <span class="params">height</span>+1, <span class="string">&quot;^&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String get<span class="constructor">Space(<span class="params">int</span> <span class="params">num</span>)</span>&#123;</span><br><span class="line">        String space = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        return buf.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="返回二叉树中指定节点的后续节点"><a href="#返回二叉树中指定节点的后续节点" class="headerlink" title="返回二叉树中指定节点的后续节点"></a>返回二叉树中指定节点的后续节点</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">	int</span> value;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">left</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">right</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">parent</span>;</span><br><span class="line">	<span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在中序遍历中的后继节点</span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getSuccessorNode</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node.right!=null)&#123;</span><br><span class="line">		return getLeftMost(node.right);</span><br><span class="line">	&#125;else&#123;//无右子树</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">parent</span> = node.parent;</span><br><span class="line">		while(parent != null &amp;&amp; parent.left != <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">			node</span> = parent;</span><br><span class="line">			parent = node.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getLeftMost</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	&#125;</span></span><br><span class="line"><span class="title">	while</span>(node.left!=null)&#123;</span><br><span class="line">		<span class="keyword">node</span> <span class="title">= node</span>.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="纸对折，依次输出折痕的方向"><a href="#纸对折，依次输出折痕的方向" class="headerlink" title="纸对折，依次输出折痕的方向"></a>纸对折，依次输出折痕的方向</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归过程</span></span><br><span class="line"><span class="comment">//i是节点的层数，N一共的层数，down==true凹 down==false凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(down ? <span class="string">&quot;凹&quot;</span> : <span class="string">&quot;凸&quot;</span>);</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanced</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">			value = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">		<span class="keyword">boolean</span> isBalanced;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">			isBalanced = h;</span><br><span class="line">			<span class="built_in">height</span> = h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">		Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span> = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isBalanced = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Math.<span class="built_in">abs</span>(leftInfo.<span class="built_in">height</span> - rightInfo.<span class="built_in">height</span> &lt;<span class="number">2</span>)	&amp;&amp; leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced)&#123;</span><br><span class="line">			isBalanced = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, <span class="built_in">height</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">process</span>(head).isBalanced;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"><a href="#给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）" class="headerlink" title="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"></a>给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(head).distacne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">		distance = d;</span><br><span class="line">		<span class="built_in">height</span> = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意思考结果的可能性，常见的就是结果与当前节点有关和无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">	Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> heigth = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> distance = Math.<span class="built_in">max</span>(</span><br><span class="line">		Math.<span class="built_in">max</span>(leftInfo.distance, rightInfo.distance), </span><br><span class="line">		leftInfo.<span class="built_in">height</span>+rightInfo.<span class="built_in">height</span>+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(distance, <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点</h4><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> data)&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node getMaxSubBalancedTree(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process(head).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	<span class="built_in">boolean</span> isAllBST;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span>;</span><br><span class="line">	Node head;</span><br><span class="line">	<span class="keyword">public</span> Info(<span class="built_in">boolean</span> is, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span> mi, <span class="built_in">int</span> ma, Node h)&#123;</span><br><span class="line">		isAllBST = is;</span><br><span class="line">		maxSubSize = <span class="built_in">size</span>;</span><br><span class="line">		<span class="built_in">min</span> = mi;</span><br><span class="line">		<span class="built_in">max</span> = ma;</span><br><span class="line">		head = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Info process(Node X)&#123;</span><br><span class="line">	<span class="keyword">if</span>(X==<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = process(X.left);</span><br><span class="line">	Info rightInfo = process(X.right);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span> = X.value;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span> = X.value;</span><br><span class="line">	Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, leftInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, leftInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, rightInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, rightInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可能性1，与x节点无关</span></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = leftInfo.maxSubSize;</span><br><span class="line">		head = leftInfo.head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = Math.<span class="built_in">max</span>(maxSubSize, rightInfo.maxSubSize);</span><br><span class="line">		<span class="keyword">if</span>(maxSubSize&lt;rightInfo.maxSubSize)&#123;</span><br><span class="line">			head = rightInfo.head;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST) &amp;&amp; </span><br><span class="line">		(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST) &amp;&amp;</span><br><span class="line">		(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.<span class="built_in">max</span> &lt; X.value) &amp;&amp;</span><br><span class="line">		(right == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.<span class="built_in">min</span> &gt; X.value))&#123;</span><br><span class="line"></span><br><span class="line">			maxSubSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize) + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">			isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			head = X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubSize, <span class="built_in">min</span>, <span class="built_in">max</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="派对的快乐值"><a href="#派对的快乐值" class="headerlink" title="派对的快乐值"></a>派对的快乐值</h4><pre><code>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。数的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些不来，规则：
1.如果某员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</code></pre>
<hr>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee&#123;</span><br><span class="line">	<span class="built_in">public</span> happy;</span><br><span class="line">	<span class="built_in">public</span> List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> Employee(<span class="type">int</span> h)&#123;</span><br><span class="line">		happy = h;</span><br><span class="line">		nexts = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> maxHappy(Employee boss)&#123;</span><br><span class="line">	<span class="keyword">if</span>(boss == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">Info</span> <span class="keyword">all</span> = process(boss);</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="keyword">all</span>.yes, <span class="keyword">all</span>.<span class="keyword">no</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Info</span>&#123;</span><br><span class="line">	<span class="type">int</span> yes;//x来情况下的最大happy</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span>;//x不来情况下的最大happy</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Info</span>(<span class="type">int</span> y, <span class="type">int</span> n)&#123;</span><br><span class="line">		yes = y;</span><br><span class="line">		<span class="keyword">no</span> = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">Info</span> process(Employee x)&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.nexts.isEmpty)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(x.happy, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> yes = x.happy;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(Employee next : x.nexts)&#123;</span><br><span class="line">		<span class="keyword">Info</span> nextInfo = process(next);</span><br><span class="line">		yes += nextInfo.<span class="keyword">no</span>;</span><br><span class="line">		<span class="keyword">no</span> += Math.max(nextInfo.yes,nextInfo.<span class="keyword">no</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(yes, <span class="keyword">no</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>

<p>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(start==end)<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//分成两块</span></span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//左边排序</span></span><br><span class="line">		sort(arr, start, mid);</span><br><span class="line">		<span class="comment">//右边排序</span></span><br><span class="line">		sort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">		merge(arr, start, mid + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = left;</span><br><span class="line">		<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt;= arr[j])temp[k++] = arr[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) temp[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right) temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;temp.length; m++)&#123;</span><br><span class="line">			arr[left+m] = temp[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，只有一种数出现了奇数次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> eor = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.<span class="keyword">out</span>.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，有两种数出现了两次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// eor = a^b</span></span><br><span class="line">	<span class="comment">// eor != 0</span></span><br><span class="line">	<span class="comment">// eor必然有一个位置是1</span></span><br><span class="line">	<span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>)&#123;</span><br><span class="line">			onlyOne ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="built_in">println</span>(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">					arr[j<span class="number">-1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有3个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		stack.<span class="keyword">push</span>(cur);</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.value != stack.<span class="keyword">pop</span>().value)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head = head.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//need o(1) extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome2(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 = head;</span><br><span class="line">	NOde n2 = head;</span><br><span class="line">	<span class="keyword">while</span>(n2.<span class="keyword">next</span>!= <span class="keyword">null</span> &amp;&amp; n2.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>;<span class="comment">//n1-&gt;mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>.<span class="keyword">next</span>;<span class="comment">//n2-&gt;end</span></span><br><span class="line">	&#125;</span><br><span class="line">	n2 = n1.<span class="keyword">next</span>;<span class="comment">//n2-&gt;right part first node</span></span><br><span class="line">	n1.<span class="keyword">next</span> = <span class="keyword">null</span>;<span class="comment">//mid.next-&gt;null</span></span><br><span class="line">	Node n3 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n2!=<span class="keyword">null</span>)&#123;<span class="comment">//right part convert</span></span><br><span class="line">		n3 = n2.<span class="keyword">next</span>;<span class="comment">//n3-&gt;save the node</span></span><br><span class="line">		n2.<span class="keyword">next</span> = n1;<span class="comment">//next of right node convert</span></span><br><span class="line">		n1 = n2;<span class="comment">//n1 move</span></span><br><span class="line">		n2 = n3;<span class="comment">//n2 move</span></span><br><span class="line">	&#125;</span><br><span class="line">	n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">	n2 = head; <span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">	<span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2!= <span class="keyword">null</span>)&#123; <span class="comment">// check palindrome</span></span><br><span class="line">		<span class="keyword">if</span>(n1.value != n2.value)&#123;</span><br><span class="line">			res = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>; <span class="comment">// left to mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>; <span class="comment">// right to mid</span></span><br><span class="line">	&#125;</span><br><span class="line">	n1 = n3.<span class="keyword">next</span>;</span><br><span class="line">	n3.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">		n2 = n1.<span class="keyword">next</span>;</span><br><span class="line">		n1.<span class="keyword">next</span> = n3;</span><br><span class="line">		n3 = n1;</span><br><span class="line">		n1 = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node listPartition1(Node head, <span class="built_in">int</span> piovt)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i!=nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] = cur;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i != nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> arrPartition(Node[] nodeArr, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	<span class="built_in">int</span> samll = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">int</span> big = nodeArr.length;</span><br><span class="line">	<span class="built_in">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">index</span>!=big)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,<span class="keyword">index</span>++);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value==piovt)&#123;</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(nodeArr, --big, <span class="keyword">index</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试方法</span></span><br><span class="line"><span class="keyword">public</span> Node listPartition2(Node head, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	Node sH = <span class="literal">null</span>;<span class="comment">//small head</span></span><br><span class="line">	Node sT = <span class="literal">null</span>;<span class="comment">//samll tail</span></span><br><span class="line">	Node eH = <span class="literal">null</span>;<span class="comment">//equal head</span></span><br><span class="line">	Node eT = <span class="literal">null</span>;<span class="comment">//equal tail</span></span><br><span class="line">	Node mH = <span class="literal">null</span>;<span class="comment">//big head</span></span><br><span class="line">	Node MT = <span class="literal">null</span>;<span class="comment">//big tail</span></span><br><span class="line">	Node <span class="keyword">next</span> = <span class="literal">null</span>;<span class="comment">//save the node</span></span><br><span class="line">	<span class="comment">//every node distributed to three lists</span></span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(head.value &lt; pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sH == <span class="literal">null</span>)&#123;</span><br><span class="line">				sH = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				sT.<span class="keyword">next</span> = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(eH == <span class="literal">null</span>)&#123;</span><br><span class="line">				eH = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				eT.<span class="keyword">next</span> = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mH == <span class="literal">null</span>)&#123;</span><br><span class="line">				mH = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				mT.<span class="keyword">next</span> = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head = <span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//小于区域的尾巴，连等于区域的头，等于区域的尾巴</span></span><br><span class="line">	<span class="keyword">if</span>(sT!=<span class="literal">null</span>)&#123;<span class="comment">//如果有小于区域</span></span><br><span class="line">		sT.<span class="keyword">next</span> = eH;</span><br><span class="line">		eT = eT == <span class="literal">null</span> ? sT : eT;<span class="comment">//下一步，谁去连大于区域的头</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的if，不管跑了没有，et</span></span><br><span class="line">	<span class="comment">//all reconnect</span></span><br><span class="line">	<span class="keyword">if</span>(et!=<span class="literal">null</span>)&#123;</span><br><span class="line">		eT.<span class="keyword">next</span> = mH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="一种特殊的单链表节点描述一下"><a href="#一种特殊的单链表节点描述一下" class="headerlink" title="一种特殊的单链表节点描述一下"></a>一种特殊的单链表节点描述一下</h4><pre><code>class Node&#123;
    int value;
    Node next;
    Node rand;
    Node(int val)&#123;
        value = val;
    &#125;
&#125;
rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</code></pre>
<hr>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">//笔试方法，使用HashMap</span></span><br><span class="line">public Node copyListWithRand1(Node head)&#123;</span><br><span class="line">	HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="built_in">null</span>)&#123;</span><br><span class="line">		map.put(cur, new Node(cur.<span class="built_in">value</span>));</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老节点</span></span><br><span class="line">		<span class="comment">//map.get(cur)新节点</span></span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">next</span> = map.<span class="built_in">get</span>(cur.<span class="built_in">next</span>);</span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">rand</span> = map.<span class="built_in">get</span>(<span class="built_in">cut</span>.<span class="built_in">rand</span>);</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp.<span class="built_in">get</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试用的方法</span></span><br><span class="line">public Node copyListWithRand2(Node head)&#123;</span><br><span class="line">	if(head == <span class="built_in">null</span>)&#123;</span><br><span class="line">		return <span class="built_in">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	Node <span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//copy node and link to every node</span></span><br><span class="line">	<span class="comment">//1-&gt;2</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = new Node(cur.<span class="built_in">value</span>);</span><br><span class="line">		cur.<span class="built_in">next</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	Node curCopy = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//set copy node rand</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2-&gt;2&#x27;</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老</span></span><br><span class="line">		<span class="comment">//cur.next 新 copy</span></span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">rand</span> = cur.<span class="built_in">rand</span> != <span class="built_in">null</span> ? cur.<span class="built_in">rand</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node res = head.<span class="built_in">next</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="comment">// split</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">next</span> = <span class="built_in">next</span> != <span class="built_in">null</span> ? <span class="built_in">next</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两个可能有环链表的交点"><a href="#两个可能有环链表的交点" class="headerlink" title="两个可能有环链表的交点"></a>两个可能有环链表的交点</h4><hr>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">head</span> = new <span class="keyword">Node</span><span class="title">(1</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node2</span> = new <span class="keyword">Node</span><span class="title">(2</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node3</span> = new <span class="keyword">Node</span><span class="title">(3</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node4</span> = new <span class="keyword">Node</span><span class="title">(4</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node5</span> = new <span class="keyword">Node</span><span class="title">(5</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node6</span> = new <span class="keyword">Node</span><span class="title">(6</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node7</span> = new <span class="keyword">Node</span><span class="title">(7</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node8</span> = new <span class="keyword">Node</span><span class="title">(8</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node9</span> = new <span class="keyword">Node</span><span class="title">(9</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node10</span> = new <span class="keyword">Node</span><span class="title">(10</span>);</span><br><span class="line"></span><br><span class="line">        head.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        node7.next = node8;</span><br><span class="line">        node8.next = node9;</span><br><span class="line">        node9.next = node10;</span><br><span class="line">        node10.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span> <span class="title">crossNode</span> = getLoopNode(head);</span><br><span class="line">        System.out.println(crossNode.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getIntersection</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || <span class="attr">head2=</span>=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop1</span> = getLoopNode(head1);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop2</span> = getLoopNode(head2);</span><br><span class="line">        if(<span class="attr">loop1=</span>=null &amp;&amp; <span class="attr">loop2=</span>=null)&#123;</span><br><span class="line">            return noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(loop1!=null &amp;&amp; loop2!=null)&#123;</span><br><span class="line">            return  bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一个链表第一个入环的节点</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getLoopNode</span>(<span class="keyword">Node</span> <span class="title">head</span>)&#123;</span><br><span class="line">        if(head ==null || head.next ==null || head.next.next == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // n1 慢 n2 快</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n1</span> = head.next; //n1-&gt;slow</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n2</span> = head.next.next; //n2-&gt;fast</span><br><span class="line">        while(n1 != n2)&#123;</span><br><span class="line">            if(n2.next == null || n2.next.next == null)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head;  //n2-&gt;walk again from head</span><br><span class="line">        while(n1!=n2)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果两个无环链表相交返回第一个相交的节点，如果不相交返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">noLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || head2 == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = head1;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = head2;</span><br><span class="line">        int n = <span class="number">0</span>;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur1 != cur2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //n : 链表<span class="number">1</span>的长度减去链表<span class="number">2</span>的长度</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; //长的变为cur1</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //两个链表都有环，返回第一个相交的节点，不相交则返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">bothLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">loop1</span>, <span class="keyword">Node</span> <span class="title">head2</span>, <span class="keyword">Node</span> <span class="title">loop2</span>)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = null;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = null;</span><br><span class="line">        if(loop1 == loop2)&#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            int n = <span class="number">0</span>;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur2!=loop2)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 :head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur1!=cur2)&#123;</span><br><span class="line">                <span class="attr">cur1=</span> cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                if(cur1 == loop2)&#123;</span><br><span class="line">                    return loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> minPos = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = temp;</span><br><span class="line">			arr[minPos] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2021/04/05/2021_04_05_AQS/</url>
    <content><![CDATA[<h3 id="1-AQS简单介绍"><a href="#1-AQS简单介绍" class="headerlink" title="1.AQS简单介绍"></a>1.AQS简单介绍</h3><p>AQS的全称为（<code>AbstractQueueSyncgronizer</code>），这个类在java.util.concurrent.locks包下面。AQS是一个用来构建锁和同步器的框架，使用AQS能简单高效地构造出应用广泛的大量同步器，比如我们提到的<code>ReentrantLock</code>,<code>Semaphore</code>，其他的诸如<code>ReentrantReadWriteLock</code>,<code>SyschronousQueue</code>,<code>FutureTask</code>等等皆是基于AQS非常轻松容易的构造出符合我们自己需求的同步器。</p>
<a id="more"></a>
<h3 id="2-AQS原理"><a href="#2-AQS原理" class="headerlink" title="2.AQS原理"></a>2.AQS原理</h3><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
<h4 id="2-1-原理概述"><a href="#2-1-原理概述" class="headerlink" title="2.1.原理概述"></a>2.1.原理概述</h4><p><strong>AQS核心的思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的<code>getState</code>,<code>setState</code>,<code>compareAndSetState</code>进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-AQS对资源的共享方式"><a href="#2-2-AQS对资源的共享方式" class="headerlink" title="2.2.AQS对资源的共享方式"></a>2.2.AQS对资源的共享方式</h4><p>AQS定义两种资源共享方式</p>
<p><strong>1）Exclusive（独占）</strong></p>
<p>只有一个线程能执行，如ReetrantLock。又可分为公平锁和非公平锁，ReetrantLock同时支持两种锁，下面ReentrantLock对这两种锁的定义做介绍：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，先通过两次CAS操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p>
<p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：公平锁和非公平锁只有两处不同：</strong></p>
<ol>
<li>非公平锁在调用lock后，首先就会调用一次CAS进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接获取到锁返回了。</li>
<li>非公平锁在CAS失败后，和公平锁一样都会进入到<code>tryAcquire</code>方法，在<code>tryAcquire</code>方法中，如果发现了锁这个时候被释放了(state==0)，非公平锁会直接CAS抢锁，但是公平锁会判断等待队列是否有线程出去等待状态，如果没有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说非公平锁会有更好的性能，因为它的吞吐量大。当然，非公平锁让获取锁的时间更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<p><strong>2）Share（共享）</strong></p>
<p>多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、CyclicBarrier、ReadWriteLock我们都会在后面讲到。</p>
<p>ReentrantReadWriteLock可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层帮我们实现好了。</p>
<h4 id="2-3-AQS底层使用了模板方法模式"><a href="#2-3-AQS底层使用了模板方法模式" class="headerlink" title="2.3.AQS底层使用了模板方法模式"></a>2.3.AQS底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p>
<blockquote>
<p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p>
</blockquote>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。<strong>但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</strong></p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h3 id="3-Semaphore（信号量）-允许多个线程同时访问"><a href="#3-Semaphore（信号量）-允许多个线程同时访问" class="headerlink" title="3.Semaphore（信号量）-允许多个线程同时访问"></a>3.Semaphore（信号量）-允许多个线程同时访问</h3><p><strong>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</strong></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p>
<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p>
<p>Semaphore 有两种模式，公平模式和非公平模式。</p>
<ul>
<li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p><strong>Semaphore 对应的两个构造方法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<blockquote>
<p>Semaphore 与 CountDownLatch 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 permits。当执行任务的线程数量超出 permits,那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 release 方法，release 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 permits 数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
</blockquote>
<h3 id="4-CountDownLatch-倒计时器"><a href="#4-CountDownLatch-倒计时器" class="headerlink" title="4.CountDownLatch(倒计时器)"></a>4.CountDownLatch(倒计时器)</h3><p><code>CountDownLatch</code>允许<code>count</code>个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
<h4 id="4-1-CountDownLatch的两种典型方法"><a href="#4-1-CountDownLatch的两种典型方法" class="headerlink" title="4.1.CountDownLatch的两种典型方法"></a>4.1.CountDownLatch的两种典型方法</h4><ol>
<li>某一个线程在开始运行前等待n个线程执行完毕。将<code>CountDownLatch</code>的计数器初始化为n：<code>new CountDownLatch(n)</code>,每当一个任务线程完成后，就将计数器减1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li>
</ol>
<h4 id="4-2-CountDownLacth的使用用例"><a href="#4-2-CountDownLacth的使用用例" class="headerlink" title="4.2.CountDownLacth的使用用例"></a>4.2.CountDownLacth的使用用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了请求的数量为550，当这个550请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code></p>
<p>与<code>CountDownLatch</code>的第一个交互是主线程等待其它线程。主线程必须在启动其它线程后立即调用<code>CountDownLatch.await()</code>方法。这样主线程的操作就会在这个方法上阻塞，直到其它线程完成各自的任务。</p>
<p>其它N个线程必须引用闭锁对象，因为他们需要通知<code>CountDownLatch</code>对象，他们已经完成了各自的任务。这种机制是通过<code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调用了这个方法，count的值等于0，然后主线程就能通过<code>await()</code>方法，恢复执行自己的任务。</p>
<p>注意：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待</p>
<h4 id="4-3-CountDownLatch的不足"><a href="#4-3-CountDownLatch的不足" class="headerlink" title="4.3.CountDownLatch的不足"></a>4.3.CountDownLatch的不足</h4><p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制能对其再次设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p>
<h4 id="4-4-CountDownLatch常见的面试题"><a href="#4-4-CountDownLatch常见的面试题" class="headerlink" title="4.4.CountDownLatch常见的面试题"></a>4.4.CountDownLatch常见的面试题</h4><ol>
<li>解释一下CountDownLatch的概念？</li>
<li>CountDownLatch和CyclicBarrier的不同之处？</li>
<li>给出一些CountDownLatch使用的例子？</li>
<li>CountDownLatch类中主要的方法？</li>
</ol>
<h3 id="5-CyclicBarrier（循环栅栏）"><a href="#5-CyclicBarrier（循环栅栏）" class="headerlink" title="5.CyclicBarrier（循环栅栏）"></a>5.CyclicBarrier（循环栅栏）</h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p>
<blockquote>
<p>CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。</p>
</blockquote>
<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>
<p>再来看一下它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>
<h4 id="5-1-CylicBarrier的应用场景"><a href="#5-1-CylicBarrier的应用场景" class="headerlink" title="5.1.CylicBarrier的应用场景"></a>5.1.CylicBarrier的应用场景</h4><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>
<h4 id="5-2-CylicBarrier的使用示例"><a href="#5-2-CylicBarrier的使用示例" class="headerlink" title="5.2.CylicBarrier的使用示例"></a>5.2.CylicBarrier的使用示例</h4><p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              test(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">          cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行</p>
<p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------当线程数达到之后，优先执行------&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              test(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">              <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-CyclicBarrier-源码分析"><a href="#5-3-CyclicBarrier-源码分析" class="headerlink" title="5.3.CyclicBarrier 源码分析"></a>5.3.CyclicBarrier 源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dowait(false, 0L)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout减1</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                <span class="comment">// 下一波执行开始</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<h4 id="5-4-CyclicBarrier-和-CountDownLatch-的区别"><a href="#5-4-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="5.4.CyclicBarrier 和 CountDownLatch 的区别"></a>5.4.CyclicBarrier 和 CountDownLatch 的区别</h4><p><strong>下面这个是国外一个大佬的回答：</strong></p>
<p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>
</blockquote>
<p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis笔记</title>
    <url>/2021/04/10/2021_04_10_mybatis/</url>
    <content><![CDATA[<h3 id="1-CURD"><a href="#1-CURD" class="headerlink" title="1.CURD"></a>1.CURD</h3><h4 id="1-1-namespace"><a href="#1-1-namespace" class="headerlink" title="1.1.namespace"></a>1.1.namespace</h4><p>namespace中的包名要和Dao/mapper接口的包名一致！</p>
<h4 id="1-2-select"><a href="#1-2-select" class="headerlink" title="1.2.select"></a>1.2.select</h4><p>选择、查询语句</p>
<ul>
<li><p>id:对应的namespace中的方法名</p>
</li>
<li><p>resultType:Sql执行的返回值 </p>
</li>
<li><p>parameterType:参数类型</p>
</li>
</ul>
<a id="more"></a>  

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       select * from user</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       select * from user where id = #&#123;id&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-3-insert"><a href="#1-3-insert" class="headerlink" title="1.3.insert"></a>1.3.insert</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性可以直接取出来--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       insert into user (id, name, pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-update"><a href="#1-4-update" class="headerlink" title="1.4.update"></a>1.4.update</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-delete"><a href="#1-5-delete" class="headerlink" title="1.5.delete"></a>1.5.delete</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意点：增删改需要提交事务，否则数据库中不会同步</strong></p>
<h4 id="1-6-万能Map"><a href="#1-6-万能Map" class="headerlink" title="1.6.万能Map"></a>1.6.万能Map</h4><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//万能的Map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, pwd) values(#&#123;userid&#125;,#&#123;username&#125;,#&#123;password&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Map传递参数，直接在sql中取出key即可。</p>
<p>对象传递参数，直接在sql中取出对象属性即可。</p>
<p>只有一个基本类型参数的情况下，可以直接在sql中取到。</p>
<p>多个参数用Map，或者注解。</p>
<h4 id="1-7-思考题"><a href="#1-7-思考题" class="headerlink" title="1.7.思考题"></a>1.7.思考题</h4><p>模糊查询怎么写？</p>
<ol>
<li><p>Java代码执行的时候，传递通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list = userDao.getUserLike(<span class="string">&quot;%王%&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在sql拼接中使用通配符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user where name like &quot;%&quot;#&#123;name&#125;&quot;%&quot;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-配置解析"><a href="#2-配置解析" class="headerlink" title="2.配置解析"></a>2.配置解析</h3><h4 id="2-1-核心配置文件"><a href="#2-1-核心配置文件" class="headerlink" title="2.1.核心配置文件"></a>2.1.核心配置文件</h4><ul>
<li>mybatis-config.xml</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">configuration</span>（配置）</span><br><span class="line"><span class="title">properties</span>（属性）</span><br><span class="line"><span class="title">settings</span>（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line"><span class="title">objectFactory</span>（对象工厂）</span><br><span class="line"><span class="title">plugins</span>（插件）</span><br><span class="line"><span class="title">environments</span>（环境配置）</span><br><span class="line"><span class="title">environment</span>（环境变量）</span><br><span class="line"><span class="title">transactionManager</span>（事务管理器）</span><br><span class="line"><span class="title">dataSource</span>（数据源）</span><br><span class="line"><span class="title">databaseIdProvider</span>（数据库厂商标识）</span><br><span class="line"><span class="title">mappers</span>（映射器）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-环境配置（environments）"><a href="#2-2-环境配置（environments）" class="headerlink" title="2.2.环境配置（environments）"></a>2.2.环境配置（environments）</h4><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>学会配置使用多套配置环境。</p>
<p>Mybatis默认的事务管理器就是JDBC，连接池：POOLED</p>
<h4 id="2-3-属性（properties）"><a href="#2-3-属性（properties）" class="headerlink" title="2.3.属性（properties）"></a>2.3.属性（properties）</h4><p>可以通过properties属性来视线引用配置文件。</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【jdbc.properties】</p>
<p>编写一个配置文件 <strong>jdbc.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在核心配置文件中引入</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一字段，优先使用配置文件的</li>
</ul>
<h4 id="2-4-类型别名（typeAliases）"><a href="#2-4-类型别名（typeAliases）" class="headerlink" title="2.4.类型别名（typeAliases）"></a>2.4.类型别名（typeAliases）</h4><ul>
<li>类型别名可为 Java 类型设置一个缩写名字。 </li>
<li>它仅用于 XML 配置，意在降低冗余的全限定类名书写。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.caosh.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultType=<span class="string">&quot;author&quot;</span></span><br></pre></td></tr></table></figure>

<p>在实体类比较少的时候使用第一种，如果实体类较多，建议使用第二种。</p>
<h4 id="2-5-设置（settings）"><a href="#2-5-设置（settings）" class="headerlink" title="2.5.设置（settings）"></a>2.5.设置（settings）</h4><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<h4 id="2-6-映射器（mappers）"><a href="#2-6-映射器（mappers）" class="headerlink" title="2.6.映射器（mappers）"></a>2.6.映射器（mappers）</h4><p>MapperRegistry：注册绑定我们的Mapper文件</p>
<p>方式1：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个mapper.xml都需要一个在Mybatis核心配置文件中注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/caosh/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式2：使用class文件绑定注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和它的Mapper文件必须同名</li>
<li>接口和它的Mapper文件必须在同一个包下</li>
</ul>
<p>方式3：使用扫描包进行注入绑定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.caosh.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和它的Mapper文件必须同名</li>
<li>接口和它的Mapper文件必须在同一个包下</li>
</ul>
<h4 id="2-7-作用域（Scope）和生命周期"><a href="#2-7-作用域（Scope）和生命周期" class="headerlink" title="2.7.作用域（Scope）和生命周期"></a>2.7.作用域（Scope）和生命周期</h4><p>生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>
<p><strong>SqlSessionFactoryBuilder：</strong></p>
<ul>
<li>一旦创建了 SqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory：</strong></p>
<ul>
<li>可以想象为：数据库连接池</li>
<li> 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong>。</li>
<li>SqlSessionFactory 的最佳作用域是应用作用域</li>
<li>最简单的就是使用<strong>单例模式</strong>或者<strong>静态单例</strong>模式。</li>
</ul>
<p><strong>SqlSession：</strong></p>
<ul>
<li>连接到请求池的一个请求</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li>
<li>用完之后需要关闭，否则资源被浪费</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">SqlSession</th>
<th>Mapper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SqlSessionFactory</td>
<td align="center">SqlSession</td>
<td>Mapper</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Sqlsession</td>
<td>Mapper</td>
</tr>
</tbody></table>
<p>一个SqlSession可以对应多个Mapper，就代表一个具体业务。</p>
<h3 id="3-解决属性名和字段不一致的问题"><a href="#3-解决属性名和字段不一致的问题" class="headerlink" title="3.解决属性名和字段不一致的问题"></a>3.解决属性名和字段不一致的问题</h3><h4 id="3-1-问题"><a href="#3-1-问题" class="headerlink" title="3.1.问题"></a>3.1.问题</h4><p>数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">name</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<ul>
<li>起别名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id,name,pwd as password from user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-ResultMap"><a href="#3-2-ResultMap" class="headerlink" title="3.2.ResultMap"></a>3.2.ResultMap</h4><p>结果集映射</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> 	<span class="built_in">name</span> 	pwd</span><br><span class="line"><span class="built_in">id</span> 	<span class="built_in">name</span> 	password</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果集映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">select * from user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</li>
<li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li>
<li><code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。</li>
</ul>
<h3 id="4-日志"><a href="#4-日志" class="headerlink" title="4.日志"></a>4.日志</h3><h4 id="4-1-日志工厂"><a href="#4-1-日志工厂" class="headerlink" title="4.1.日志工厂"></a>4.1.日志工厂</h4><p>如果一个数据库操作出现了异常，我们需要排错，日志就是最好的助手！</p>
<p>曾经：sout、debug</p>
<p>现在：日志工厂</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>在MyBatis具体使用哪个日志，需要在设置中指定。</p>
<p><strong>STDOUT_LOGGING标准日志输出</strong></p>
<p>在mybatis的核心配置文件中配置日志</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-LOG4J"><a href="#4-2-LOG4J" class="headerlink" title="4.2.LOG4J"></a>4.2.LOG4J</h4><p>什么是LOG4J？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li>
<li>通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<h5 id="4-2-1-导入"><a href="#4-2-1-导入" class="headerlink" title="4.2.1.导入"></a>4.2.1.导入</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-log4j-properties"><a href="#4-2-2-log4j-properties" class="headerlink" title="4.2.2.log4j.properties"></a>4.2.2.log4j.properties</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将等级为DEBUG的日志信息输出到console和file这两个目的地</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%c]-%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">./log/caosh.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10mb</span></span><br><span class="line"><span class="meta">log4j.appender.file.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-配置log4j为日志的实现"><a href="#4-2-3-配置log4j为日志的实现" class="headerlink" title="4.2.3.配置log4j为日志的实现"></a>4.2.3.配置log4j为日志的实现</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-log4j的使用"><a href="#4-2-4-log4j的使用" class="headerlink" title="4.2.4.log4j的使用"></a>4.2.4.log4j的使用</h5><p>直接测试运行</p>
<h3 id="5-分页"><a href="#5-分页" class="headerlink" title="5.分页"></a>5.分页</h3><p><strong>思考：为什么要分页？</strong></p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h4 id="5-1-使用Limit进行分页"><a href="#5-1-使用Limit进行分页" class="headerlink" title="5.1.使用Limit进行分页"></a>5.1.<strong>使用Limit进行分页</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> startIndex, pageSize;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">3</span>; <span class="comment">#[0,n]</span></span><br></pre></td></tr></table></figure>

<p>使用Mybatis实现分页，核心SQL</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String, Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;进入到TestGetUserByLImit&quot;</span>);</span><br><span class="line">    SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;startIndex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;pageSize&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserByLimit(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User u : userList)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-2-RowBounds"><a href="#5-2-RowBounds" class="headerlink" title="5.2.RowBounds"></a>5.2.RowBounds</h4><p>不再使用SQL实现分页</p>
<p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页2</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByRowBounds</span><span class="params">(Map&lt;String, Integer&gt; map;</span></span></span><br></pre></td></tr></table></figure>

<p>2.mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByRowBounds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRowBounds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//通过Java代码层面实现分页</span></span><br><span class="line">    List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;com.caosh.dao.UserDao.getUserByRowBounds&quot;</span>, <span class="keyword">null</span>, rowBounds);</span><br><span class="line">    <span class="keyword">for</span>(User user : list)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-分页插件"><a href="#5-3-分页插件" class="headerlink" title="5.3.分页插件"></a>5.3.分页插件</h4><p><strong>MyBatis分页插件PageHelper</strong></p>
<h3 id="6-使用注解开发"><a href="#6-使用注解开发" class="headerlink" title="6.使用注解开发"></a>6.使用注解开发</h3><h4 id="6-1-面向接口编程"><a href="#6-1-面向接口编程" class="headerlink" title="6.1.面向接口编程"></a>6.1.面向接口编程</h4><ul>
<li>在真正的开发中，很多时候我们会选择面向接口编程</li>
<li><strong>根本原因：解耦、可拓展、提高复用，分层开发中，上层不用管具体实现，大家都遵守共同的标准，使得开发变得容易，规范性更好</strong></li>
</ul>
<p><strong>关于接口的理解</strong></p>
<ul>
<li>接口从更深层次的理解，应该是定义（规范，约束）与实现（名实分离的原则）的分离。</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解。</li>
<li>接口应有两类：第一类是对一个个体的抽象，对应一个抽象体（abstract class）;第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）</li>
<li>一个个体可能有多个抽象面，抽象体与抽象面有区别</li>
</ul>
<h4 id="6-2-使用注解开发"><a href="#6-2-使用注解开发" class="headerlink" title="6.2.使用注解开发"></a>6.2.使用注解开发</h4><ol>
<li><p>注解在接口上实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在核心配置文件中绑定接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.dao.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
</li>
</ol>
<p>本质：反射机制实现</p>
<p>底层：动态代理</p>
<p><strong>MyBatis详细的执行流程</strong></p>
<ol>
<li>通过<strong>Resources</strong>获取加载mybatis全局配置文件</li>
<li>实例化<strong>SqlSessionFactoryBuilder</strong>构造器</li>
<li><strong>XMLConfigBuilder</strong> 解析配置文件流</li>
<li><strong>Configuration</strong>  所有的配置信息</li>
<li><strong>SqlSessionFactory</strong>实例化</li>
<li><strong>transaction</strong>事务管理</li>
<li>创建<strong>executor</strong>执行器</li>
<li>创建<strong>SqlSession</strong></li>
<li>实现CRUD</li>
</ol>
<h4 id="6-3-CRUD"><a href="#6-3-CRUD" class="headerlink" title="6.3.CRUD"></a>6.3.CRUD</h4><p>可以在工具类创建的时候实现自动提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写接口，增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法存在多个参数时，所有的参数前面必须加上@Param</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update(&quot;update user set name=#&#123;name&#125;, pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：必须将接口注册绑定到mybatis的核心配置文件上</strong></p>
<p><strong>关于@Param()注解</strong></p>
<ul>
<li>基本数据类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型，可以不加</li>
<li>sql中应用的就是@Param(“<strong>uid</strong>“)中的<strong>uid</strong></li>
</ul>
<h3 id="7-Lombok"><a href="#7-Lombok" class="headerlink" title="7.Lombok"></a>7.Lombok</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在实体类上加注解</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span>：无参构造，get,set,toString,hashCode,equals</span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br></pre></td></tr></table></figure>

<h3 id="8-多对一处理"><a href="#8-多对一处理" class="headerlink" title="8.多对一处理"></a>8.多对一处理</h3><ul>
<li>多个学生，对应一个老师</li>
<li>对于学生这边而言，关联…  多个学生关联一个老师【多对一】</li>
<li>对于老师而言，集合，一个老师有很多学生【一对多】</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`teacher`</span>(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(<span class="string">`id`</span>,<span class="string">`name`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;秦老师&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`student`</span>(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`tid`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">`fktid`</span> (<span class="string">`tid`</span>),</span><br><span class="line">    <span class="keyword">constraint</span> <span class="string">`fktid`</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="string">`tid`</span>) <span class="keyword">references</span> <span class="string">`teacher`</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (<span class="keyword">id</span>,<span class="keyword">name</span>,tid) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (<span class="keyword">id</span>,<span class="keyword">name</span>,tid) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (<span class="keyword">id</span>,<span class="keyword">name</span>,tid) <span class="keyword">values</span> (<span class="number">3</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (<span class="keyword">id</span>,<span class="keyword">name</span>,tid) <span class="keyword">values</span> (<span class="number">4</span>,<span class="string">&#x27;兰兰&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (<span class="keyword">id</span>,<span class="keyword">name</span>,tid) <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a><strong>测试环境搭建</strong></h5><ol>
<li>导入Lombok</li>
<li>新建实体类Teacher，Student</li>
<li>新建Mapper接口</li>
<li>新建Mapper.xml文件</li>
<li>在核心配置文件中绑定注册mapper接口或者文件</li>
<li>测试查询是否成功</li>
</ol>
<h5 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a><strong>按照查询嵌套处理</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子查询</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    1.查询所有学生的信息</span></span><br><span class="line"><span class="comment">    2.根据查询出来学生的tid,寻找对应的老师</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂的属性需要单独处理</span></span><br><span class="line"><span class="comment">        对象：association</span></span><br><span class="line"><span class="comment">        集合：使用collection</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="按照结果嵌套查询"><a href="#按照结果嵌套查询" class="headerlink" title="按照结果嵌套查询"></a><strong>按照结果嵌套查询</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--按照结果嵌套处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.name tname from student s, teacher t where s.tid=t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>回顾MySql多对一查询方式：</p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<h3 id="9-一对多处理"><a href="#9-一对多处理" class="headerlink" title="9.一对多处理"></a>9.一对多处理</h3><p>比如一个老师拥有多个学生</p>
<p>对于老师而言就是一对多的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a><strong>按照结果嵌套处理</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--按照结果嵌套查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid, s.name sname, t.name tname, t.id tid</span><br><span class="line">    from student s, teacher t</span><br><span class="line">    where s.tid = t.id and t.id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a><strong>按照查询嵌套处理</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent2&quot;</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentById&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where tid = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol>
<li>关联-association【多对一】</li>
<li>集合-collection 【一对多】</li>
<li>javaType &amp; ofType<ul>
<li>javaType用来指定实体类中属性的类型</li>
<li>ofType用来指定映射到List或集合中的pojo类型，泛型中的约束类型</li>
</ul>
</li>
</ol>
<p><strong>注意点：</strong></p>
<ul>
<li>保证SQL的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一中，属性名和字段的问题</li>
<li>如果问题不好排查，建议使用log4j</li>
</ul>
<h3 id="10-动态SQL"><a href="#10-动态SQL" class="headerlink" title="10.动态SQL"></a>10.动态SQL</h3><p><strong>什么是动态SQL：动态SQL就是根据不同的条件生成不同的SQL语句</strong></p>
<p>如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</span><br><span class="line"></span><br><span class="line">if</span><br><span class="line">choose (when, otherwise)</span><br><span class="line">trim (where, set)</span><br><span class="line">foreach</span><br></pre></td></tr></table></figure>

<h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> blog <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> title = <span class="comment">#&#123;title&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> <span class="keyword">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span><br><span class="line">        <span class="keyword">and</span> author = <span class="comment">#&#123;author&#125;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                and author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                and views = #&#123;views&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            and title = #&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            and author = #&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            author = #&#123;author&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>所谓的动态SQL，本质还是SQL语句。只是我们可以在SQL层面，去执行一个逻辑代码</strong></p>
<h4 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h4><p>有的时候，我们可能会将一些功能的公共部分抽取出来，方便复用！</p>
<ol>
<li><p>使用SQL标签抽取公共的部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        and title = #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">        and author = #&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要的地方使用include标签引用即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li>最好基于单表来定义SQL片段！</li>
<li>不要存在where标签</li>
</ul>
<h4 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogByForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-缓存"><a href="#11-缓存" class="headerlink" title="11.缓存"></a>11.缓存</h3><h4 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1.简介"></a>11.1.简介</h4><ol>
<li><p>什么是缓存【cache】？</p>
<ul>
<li>存在内存中的临时数据</li>
<li>将用户经常查询的数据放在缓存中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决高并发系统的性能问题。</li>
</ul>
</li>
<li><p>为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>
</ul>
</li>
<li><p>什么样的数据能使用缓存？</p>
<ul>
<li>经常查询并且不改变的数据</li>
</ul>
</li>
</ol>
<h4 id="11-2-Mybatis缓存"><a href="#11-2-Mybatis缓存" class="headerlink" title="11.2.Mybatis缓存"></a>11.2.Mybatis缓存</h4><ul>
<li>mybatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提升查询效率。</li>
<li>mybatis系统默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>
<li>默认情况下，只有一级缓存开启。（sqlsession级别的缓存，也称本地缓存）</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，mybatis定义了缓存接口cache。我们可以同过cache接口来定义缓存。</li>
</ul>
</li>
</ul>
<h4 id="11-3-一级缓存"><a href="#11-3-一级缓存" class="headerlink" title="11.3.一级缓存"></a>11.3.一级缓存</h4><p>缓存失效的情况：</p>
<ol>
<li>查询不同的东西</li>
<li>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</li>
<li>查询不同的Mapper.xml</li>
<li>sqlsession清理缓存</li>
</ol>
<p>小结：一级缓存是默认开启的，只在一次sqlsession中有效，也就是拿到连接到关闭连接这个区间段</p>
<h4 id="11-4-二级缓存"><a href="#11-4-二级缓存" class="headerlink" title="11.4.二级缓存"></a>11.4.二级缓存</h4><ul>
<li>耳机缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</li>
<li>工作机制<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li>
<li>新的会话查询信息就可以从二级缓存中获取内容</li>
<li>不同的mapper查出的数据会放在自己对应的缓存中</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>开启全局缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示的开启全局缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在要使用二级缓存的mpper中开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以自定义参数</p>
</li>
<li><p>测试</p>
<ul>
<li><p>需要将实体类序列化，否则就会报错</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Cause</span>: <span class="selector-tag">java</span><span class="selector-class">.io</span><span class="selector-class">.NotSerializableException</span>: <span class="selector-tag">com</span><span class="selector-class">.caosh</span><span class="selector-class">.pojo</span><span class="selector-class">.User</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>小结：</p>
<ul>
<li>只要开启了二级缓存，在同一个mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中</li>
<li>只有当会话提交或者关闭的时候，才会提交到二级缓存中</li>
</ul>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring笔记</title>
    <url>/2021/04/13/2021_04_13_spring/</url>
    <content><![CDATA[<h3 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h4><ul>
<li>spring：跟软件行业带来了春天</li>
<li>2002年，首次推出了Spring框架的雏形：interface21框架</li>
<li>2004年3月24推出1.0版本</li>
<li>Rod Johnson：Spring框架的创始人，同时也是SpringSource的联合创始人。Spring是面向切面编程（AOP）和控制反转（IoC)的容器框架。</li>
<li>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！</li>
</ul>
<a id="more"></a>

<ul>
<li>SSH：Struct2+Spring+Hibernate</li>
<li>SSM：SpringMVC + Spring + Mybatis</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2.优点"></a>1.2.优点</h4><ul>
<li>Spring是一个开源的免费框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程(AOP)</li>
<li>对事务的处理，对框架整合的支持</li>
</ul>
<p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架（AOP）</strong></p>
<h4 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3.组成"></a>1.3.组成</h4><h4 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4.拓展"></a>1.4.拓展</h4><p>在spring的官网有这个介绍：现代化的Java开发，说白了就是基于Spring的开发</p>
<ul>
<li>Spring Boot：构建一切<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速的开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud：协调一切<ul>
<li>Spring Cloud是基于SpringBoot实现的</li>
</ul>
</li>
<li>Spring Cloud Data Flow：连接一切</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC。承上启下的作用。</p>
<p>弊端：发展太久了，违背了原来的理念，配置是非繁琐</p>
<h3 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2.IOC理论推导"></a>2.IOC理论推导</h3><ol>
<li>UserDao 接口</li>
<li>UserDaoImpl 实现类</li>
<li>UserService 业务接口</li>
<li>UserServiceImpl 业务实现类</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序的代码量非常大，修改一次的成本非常昂贵</p>
<p>我们使用一个Set接口实现，发生了革命性的变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用set进行动态值的注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>之前程序是主动创建对象，控制权在程序员手上</li>
<li>使用了set注入后，程序不再具有主动性，二十变成了被动的接受对象</li>
</ul>
<p>这种思想，从本质上解决了问题，程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上。这是IOC的原型。</p>
<h4 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a><strong>IOC本质</strong></h4><p><strong>控制反转IOC（Inversion of control），是一种设计思想，DI(依赖注入)是实现IOC的一种方法，</strong>也有人认为DI只是Ioc的另一种说法。没有Ioc的程序中，我们使用面向对象编程时，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建移交给第三方，个人认为控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现来中，从而达到零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection, DI）</strong></p>
<h3 id="3-HelloSpring"><a href="#3-HelloSpring" class="headerlink" title="3.HelloSpring"></a>3.HelloSpring</h3><h4 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a>思考问题？</h4><ul>
<li><p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的</p>
</li>
<li><p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的</p>
</li>
</ul>
<p>这个过程就叫控制反转：</p>
<p><strong>控制</strong>：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p><strong>反转</strong>：程序本身不船舰对象，而是变成被动的接收对象。</p>
<p><strong>依赖注入</strong>：就是利用set方法来进行注入的。</p>
<p><strong>IOC是一种编程思想，由主动编程变为被动接收。</strong></p>
<p>可以通过newClassPathXmlAppalicationContext去浏览一下底层源码。</p>
<h3 id="4-IOC创建对象的方式"><a href="#4-IOC创建对象的方式" class="headerlink" title="4.IOC创建对象的方式"></a>4.IOC创建对象的方式</h3><p>1.使用无参构造创建对象（默认）</p>
<p>2.假设我们需要使用有参构造创建对象</p>
<ol>
<li><p>下标赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下标赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span>--&gt;</span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;有参&quot;</span>/&gt;</span>--&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型赋值(不建议使用)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;有参2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接通过参数名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;有参&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了</p>
<h3 id="5-Spring配置"><a href="#5-Spring配置" class="headerlink" title="5.Spring配置"></a>5.Spring配置</h3><h4 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1.别名"></a>5.1.别名</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2.Bean的配置"></a>5.2.Bean的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.UserT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;usert1, usert2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;USerT&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id：bean 的唯一标识符，也就是我们的对象名</p>
<p>class：bean 对象所对应的权限定名： 包名+类型</p>
<p>name: 也是别名，而且name更高级</p>
<h4 id="5-3-Import"><a href="#5-3-Import" class="headerlink" title="5.3.Import"></a>5.3.Import</h4><p>一般用于团队开发使用，可以将多个配置文件，导入合并为一个</p>
<h3 id="6-DI依赖注入"><a href="#6-DI依赖注入" class="headerlink" title="6.DI依赖注入"></a>6.DI依赖注入</h3><h4 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1.构造器注入"></a>6.1.构造器注入</h4><p>上一节说过</p>
<h4 id="6-2-set方式注入【重点】"><a href="#6-2-set方式注入【重点】" class="headerlink" title="6.2.set方式注入【重点】"></a>6.2.set方式注入【重点】</h4><ul>
<li>依赖注入：set注入<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<p>复杂类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.caosh.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addres;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addres;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddres</span><span class="params">(String addres)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addres = addres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实测试对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Address address;</span><br><span class="line"><span class="keyword">private</span> String[] books;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; card;</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line"><span class="keyword">private</span> String wife;</span><br><span class="line"><span class="keyword">private</span> Properties info;</span><br></pre></td></tr></table></figure>

<p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addres&quot;</span> <span class="attr">value</span>=<span class="string">&quot;东大&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通值注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;韩寒&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--list--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>敲代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--map--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;111111111111&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3124135425346&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--set--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>DOD<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--null--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>2019262285<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3.拓展方式注入"></a>6.3.拓展方式注入</h4><p>可以使用p命名空间和c命名空间进行注入</p>
<p>官方解释：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--p是property的意思--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;韩寒&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c命名空间通过构造器注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;李丹&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意p命名和c命名不能直接使用，需要导入xml约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4.bean的作用域"></a>6.4.bean的作用域</h4><ol>
<li><p>单例模式【默认模式】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;李丹&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型模式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;李丹&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>每次从容器中get时都会产生新对象</p>
</li>
<li><p>其余的request、session、application、websocket这些只有在web开发中使用到</p>
</li>
</ol>
<h3 id="7-Bean的自动装配"><a href="#7-Bean的自动装配" class="headerlink" title="7.Bean的自动装配"></a>7.Bean的自动装配</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中由三种自动装配的方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在Java中显示的配置</li>
<li>隐士的自动装配bean【重要】</li>
</ol>
<h4 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1.测试"></a>7.1.测试</h4><p>环境搭建：一个人有两个宠物</p>
<h4 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2.ByName自动装配"></a>7.2.ByName自动装配</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--byName:会自动在容器上下文中查找,和自己set方法后面的值对应的bean id--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨憨&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3.ByType自动装配"></a>7.3.ByType自动装配</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--byType:会自动在容器上下文中查找,和自己对象属性类型对应的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.caosh.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;憨憨&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-使用注解自动注入"><a href="#7-4-使用注解自动注入" class="headerlink" title="7.4.使用注解自动注入"></a>7.4.使用注解自动注入</h4><p><strong>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.</strong></p>
<p>要使用注解须知：</p>
<ol>
<li>导入约束       xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></li>
<li>配置注解的支持     <a href="context:annotation-config/">context:annotation-config/</a></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方式上使用！</p>
<p>使用Autowired 可以不再编写set方法，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字。</p>
<p>如果显示定义了@Autowired(required = false)，则说明这个对象可以为空</p>
<p>如果Autowired的自动装配环境比较复杂，自动装配无法通过一个注解【Autowired】完成的时候，我们可以通过使用@Qualifier(value = “beanID”)去配合它的使用。</p>
<p><strong>@Resource</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>@Autowired和@Resource的区别：</p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired通过byType的方式实现，而且这个对象必须存在！</li>
<li>@Resource 默认通过byName的方式实现，如果找不到名字，则通过byType实现。如果两个都找不到就报错</li>
<li>执行顺序不同：@Autowired通过byType的方式实现。@Resource 默认通过byName的方式实现。</li>
</ul>
<h3 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8.使用注解开发"></a>8.使用注解开发</h3><p><strong>在Spring4之后，要使用注解开发，必须保证aop的包导入了。</strong></p>
<p><strong>使用注解开发需要导入context约束，增加注解的支持！</strong></p>
<ol>
<li>bean</li>
<li>属性如何注入</li>
<li>衍生的注解</li>
<li>自动装配</li>
<li>作用域</li>
<li>小结</li>
</ol>
<p><strong>@Component</strong>：组件：放在类上，说明这个类被Spring管理了，就是bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价于    &lt;bean id=&quot;user&quot; class=&quot;com.caosh.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Component</span></span><br></pre></td></tr></table></figure>

<p><strong>属性如何注入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于 &lt;property name=&quot;name&quot; value=&quot;&quot;&gt;</span></span><br><span class="line">    <span class="meta">@Value(&quot;韩寒&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>衍生的注解</strong></p>
<p>@Component 有几个衍生注解，我们在web开发中，会按照三层架构分层</p>
<ul>
<li><p>dao 【@Repository】</p>
</li>
<li><p>service 【@Service】</p>
</li>
<li><p>controller 【@Controller】</p>
<p>这四个注解功能都是一样的，都是代表将某个类注册到容器中，装配Bean。</p>
</li>
</ul>
<p><strong>自动装配</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Autowired</span>：自动装配通过类型</span><br><span class="line">	如果Autowired不能唯一自动装配属性，则需要通过<span class="variable">@Qualifier</span>(value=<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="variable">@Nullable</span> 字段标记了这个注解，说明这个字段可以为null</span><br><span class="line"><span class="variable">@Resource</span>  自动装配通过名字。类型。</span><br></pre></td></tr></table></figure>

<p><strong>作用域</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;韩寒&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护比较方便</li>
<li>注解 不是自己的类使用不了，维护相对复杂</li>
</ul>
<p>xml与注解最佳实践：</p>
<ul>
<li>用来管理bean;</li>
<li>注解只负责完成属性的注入</li>
<li>我们在使用的过程中，只需要注意一个问题：只需让注解生效，就需要开启注解的支持</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包,这个包下的注解就会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.caosh&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="9-使用Java的方式配置Spring"><a href="#9-使用Java的方式配置Spring" class="headerlink" title="9.使用Java的方式配置Spring"></a>9.使用Java的方式配置Spring</h3><p>现在完全不使用Spring的xml配置了，全权交给Java来做。</p>
<p>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个注解的意思是这个类被Spring对象接管了,注册到了容器中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;韩寒&quot;)</span><span class="comment">//属性注入值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个也会被Spring容器托管,注册到容器中,因为它本身就是一个@Component</span></span><br><span class="line"><span class="comment">//@Configuration代表这是一个配置类,就和我们之前看的beans.xml一样</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.caosh.pojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个bean,相当于我们之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">//这个方法的名字,相当于bean标签的id属性</span></span><br><span class="line">    <span class="comment">//这个方法的返回值,就相当于bean标签的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">//返回要注入到bean的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果完全使用配置类方式去做,我们就只能通过AnnotationConfig 上下文来获取容器,通过配置类的class对象加载</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(UserConfig.class);</span><br><span class="line">        User user = (User) context.getBean(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种纯Java配置的方式，在SpringBoot中随处可见</p>
<h3 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10.代理模式"></a>10.代理模式</h3><p>为什么要学习代理模式？因为这就是SpringAOP的底层。【SpringAOP和SpringMVC】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h4 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1.静态代理"></a>10.1.静态代理</h4><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实的角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<p>代码步骤：</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.caosh.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//租房接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东要出租房了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.caosh.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;中介收费&quot;);</span></span><br><span class="line">        host.rent();</span><br><span class="line">        seeHouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介带你看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>代理模式的好处：</p>
<ul>
<li>可以是真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共的业务就交给代理角色，实现了业务分工</li>
<li>公共业务发生扩展的时候，方便集中管理</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍</li>
</ul>
<h4 id="10-2-加深理解"><a href="#10-2-加深理解" class="headerlink" title="10.2.加深理解"></a>10.2.加深理解</h4><p>AOP横向切进去</p>
<p>dao-&gt;service-&gt;controller-&gt;前端</p>
<h4 id="10-3-动态代理"><a href="#10-3-动态代理" class="headerlink" title="10.3.动态代理"></a>10.3.动态代理</h4><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul>
<li>基于接口的：JDK动态代理</li>
<li>基于类的：cglib</li>
<li>java字节码实现：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy, InnvovationHandler</p>
<p>动态代理的好处：</p>
<ul>
<li>可以是真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共的业务就交给代理角色，实现了业务分工</li>
<li>公共业务发生扩展的时候，方便集中管理</li>
<li>一个动态代理类代理的是一个接口，一般就是对应的一类业务（可以代理多个接口）</li>
<li>一个动态代理类可以代理多个类，只要实现了同一个接口即可</li>
</ul>
<h3 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h3><h4 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1.什么是AOP"></a>11.1.什么是AOP</h4><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑的各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h4 id="11-2-AOP在Spring中作用"><a href="#11-2-AOP在Spring中作用" class="headerlink" title="11.2.AOP在Spring中作用"></a>11.2.AOP在Spring中作用</h4><p><strong>提供声明式事务：允许用户自定义切面</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或者功能。即与业务逻辑无关的 ，但是我们需要关注的部分，就是横切关注点。如日志、安全、缓存、事务等。</li>
<li>切面（ASPECT）：横切关注点 被模块化的特殊对象。是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知与执行的”地点“的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点</li>
</ul>
<p>即Aop能在不改变原有代码的情况下，去增加新的功能。</p>
<h4 id="11-3-使用Spring实现Aop"><a href="#11-3-使用Spring实现Aop" class="headerlink" title="11.3.使用Spring实现Aop"></a>11.3.使用Spring实现Aop</h4><p>【重点】使用Aop织入，需要导入一个依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式一：使用Spring的API接口</p>
<p>方式二：自定义来实现AOP</p>
<p>方式三：使用注解实现AOP</p>
<h3 id="12-整合MyBatis"><a href="#12-整合MyBatis" class="headerlink" title="12.整合MyBatis"></a>12.整合MyBatis</h3><p>1.编写数据源配置</p>
<p>2.SqlSessionFactory</p>
<p>3.SqlSessionTemplate</p>
<p>4.需要给接口加实现类</p>
<p>5.将自己写的实现类，注入到Spring中</p>
<p>6.测试</p>
<h3 id="13-声明式事务"><a href="#13-声明式事务" class="headerlink" title="13.声明式事务"></a>13.声明式事务</h3><h4 id="13-1-回顾事务"><a href="#13-1-回顾事务" class="headerlink" title="13.1.回顾事务"></a>13.1.回顾事务</h4><ul>
<li>把一组操作当成一个业务来做，要么都成功，要么都失败</li>
<li>事务在项目开发中，十分重要，涉及到数据一致性的问题</li>
<li>确保一致性</li>
</ul>
<p>事务的ACID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性<ul>
<li>多个业务操作同一资源，防止数据损坏</li>
</ul>
</li>
<li>持久性<ul>
<li>事务一旦提交，无论系统发生什么，结果都不会影响</li>
</ul>
</li>
</ul>
<h4 id="13-2-Spring中的事务管理"><a href="#13-2-Spring中的事务管理" class="headerlink" title="13.2.Spring中的事务管理"></a>13.2.Spring中的事务管理</h4><ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中进行事务的管理</li>
</ul>
<p>思考：</p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况；</li>
<li>如果我们不在Spring开发中去配置声明式事务，就需要在代码中手动去配置</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性问题</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化</title>
    <url>/2021/05/26/2021_05_26_mysql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="MySQL分层"><a href="#MySQL分层" class="headerlink" title="MySQL分层"></a>MySQL分层</h3><h4 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h4><p>最上层是一些客户端和连接服务，包含本地的sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<h4 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2.服务层"></a>2.服务层</h4><p>第二层架构主要完成大所属的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建响应的内部解析树，并完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统性能。</p>
<h4 id="3-引擎层"><a href="#3-引擎层" class="headerlink" title="3.引擎层"></a>3.引擎层</h4><p>存储引擎层，存储引擎真正负责了MYSQL中数据的存储和提取，服务器通过API与引擎进行通信。不同的存储引擎具有的功能不同，这样可以根据自己的实际需要进行选取。</p>
<h4 id="4-存储层"><a href="#4-存储层" class="headerlink" title="4.存储层"></a>4.存储层</h4><p>数据存储层，主要是将数据存储在运行与裸设备之上的文件系统上，并完成与存储引擎的交互。</p>
<h3 id="机器读取sql语句的顺序"><a href="#机器读取sql语句的顺序" class="headerlink" title="机器读取sql语句的顺序"></a>机器读取sql语句的顺序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_condition&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>



<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>MySQL对索引的定义为：索引是帮助MySQL高效获取数据的数据结构。可以得到索引的本质是数据结构。可以简单的理解为“排好序的快速查找数据结构”</p>
</blockquote>
<p>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引等。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>类似大学图书馆建数目索引，提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的小号</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变换后的索引信息。</li>
<li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间建立最优秀的索引，或者优化查询</li>
</ul>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：即一个索引包含多个列</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>创建</p>
<ul>
<li><pre><code class="sql">CREATE [UNIQUE] INDEX indexName ON mytable(columnName(length))
ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnName(length));
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">删除</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>查看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name\G</span><br></pre></td></tr></table></figure>



<h4 id="mysql索引结构"><a href="#mysql索引结构" class="headerlink" title="mysql索引结构"></a>mysql索引结构</h4><p><strong>BTree索引结构</strong></p>
<p>Hash索引</p>
<p>full-text全文索引</p>
<p>R-Tree索引</p>
<h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><ol>
<li>主键自动创建索引</li>
<li>频繁作为查询的字段应该作为索引</li>
<li>查询表中云其他表关联的字段，外键关系建立索引</li>
<li>频繁更新的字段不适合创建索引</li>
<li>WHERE条件里用不到的字段不用创建索引</li>
<li>单值索引/组合索引的选择问题，who?(在高并发下倾向创建组合索引)</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h4 id="哪些情况不要建索引？"><a href="#哪些情况不要建索引？" class="headerlink" title="哪些情况不要建索引？"></a>哪些情况不要建索引？</h4><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布平均的表字段，因此应该职位最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
</ol>
<h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> + <span class="keyword">SQL</span>语句</span><br><span class="line">执行计划包含的信息： <span class="keyword">id</span> | select_type | <span class="keyword">table</span> | <span class="keyword">type</span> | possible_keys | <span class="keyword">key</span> | key_len | <span class="keyword">ref</span> | <span class="keyword">rows</span> | Extra  </span><br></pre></td></tr></table></figure>

<h4 id="各字段解释"><a href="#各字段解释" class="headerlink" title="各字段解释"></a><strong>各字段解释</strong></h4><p><strong>id:</strong> <code>select</code>查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<ul>
<li>id相同，执行顺序由上而下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有的组中，id值越大，优先级越高，越先执行</li>
</ul>
<p><strong>select_type</strong></p>
<ol>
<li><code>SIMPLE</code>——简单的select查询，查询中不包含子查询或UNION</li>
<li><code>PRIMARY</code>——查询中若包含任何复杂的子部分，最外层查询则被标记为</li>
<li><code>SUBQUERY</code>——在SELECT或WHERE列表中包含了子查询</li>
<li><code>DERIVED</code>——在FROM列表中包含的子查询被标记为DERIVED（衍生）。MYSQL会递归执行这些子查询，把结果放在临时表里。</li>
<li><code>UNION</code>——若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层的SELECT将被标记为：DERIVED</li>
<li><code>UNION RESULT</code>——从UNION表获取结果的SELECT</li>
</ol>
<p><strong>table</strong>: 显示这一行的数据是关于哪张表的</p>
<p><strong>type</strong></p>
<p>显示查询使用了何种类型（访问类型），从最好到最差依次是：</p>
<p><code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></p>
<ul>
<li><code>system</code> 表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个也可以忽略</li>
<li><code>const</code> 表示通过索引一次就找到，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，<code>Mysql</code>就能将改查询转换为一个常量</li>
<li><code>eq_ref</code>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
<li><code>ref</code>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>
<li><code>range</code>只检索给定范围的行，使用一个索引来选择行。<code>key</code>列显示使用了哪个索引。一般就是在你的<code>where</code>语句中出现了<code>between</code>、&lt;、&gt;、<code>in</code>等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引</li>
<li><code>index</code> <code>Full Index Scan</code>、<code>index</code>与<code>ALL</code>区别为<code>index</code>类型只遍历索引树。这通常比ALL快，因为索引文件通常需要比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读取的）</li>
<li><code>all</code> <code>Full Table Scan</code> ，将遍历全表以找到匹配的行</li>
</ul>
<p><strong>possible_keys</strong></p>
<p>显示可能应用在这张表中的索引，一个或多个。查询所设计到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<p><strong>key</strong></p>
<p>实际中使用的索引，如果为NULL，则没用使用索引；查询中如使用了覆盖索引，则该索引仅出现在key列表中</p>
<p><strong><code>key_len</code></strong> 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。<code>key_len</code>显示的值为索引字段的最大可能长度，<strong>并非实际使用长度</strong>，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索计算的</p>
<p><strong>ref</strong></p>
<p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
<p><strong>row</strong></p>
<p>根据表统计信息及索引选用情况，大致估算出找到目的记录需要读取的行数</p>
<p><strong>Extra</strong></p>
<p>包含不适合在其它列中显示但十分重要的额外信息</p>
<ol>
<li><code>Using filesort</code> 说明<code>MySQL</code>会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<code>MySQL</code>中无法利用索引完成的排序操作称为“文件排序”</li>
<li><code>Using temporary</code> 使用了临时表保存中间结果，MySQL在对查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组查询<code>group by</code> </li>
<li><code>Using index</code> 表示相应的select操作中使用了覆盖索引（<code>Covering Index</code>），避免访问了表的数据行，效率不错！如果同时出现<code>using where</code>，表明索引被用来执行索引键值的查找；如果没有同时出现<code>using where</code>，表明索引用来读取数据而非执行查找动作。（<strong>覆盖索引，查询列要被所键的索引覆盖</strong>）</li>
<li><code>Using where</code></li>
<li><code>using join buffer </code> 使用了连接缓存</li>
<li><code>impossible where</code> where子句的值总是false，不能用来获取任何元组</li>
<li><code>select tables optimized away</code> </li>
<li><code>distinct</code></li>
</ol>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少被优化器查询</li>
</ul>
<h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><h5 id="索引失效的原因"><a href="#索引失效的原因" class="headerlink" title="索引失效的原因"></a>索引失效的原因</h5><ol>
<li>全值匹配</li>
<li>最佳左前缀法则  如果索引了多列，要遵守最左前缀发展。指的是查询从索引的最左前列开始并且<strong>不跳过索引中的列</strong>。</li>
<li>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少使用select*（using index）</li>
<li><code>MySQL</code>在使用不等于（!=或&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li><code>is null, is not null</code> 也无法使用索引</li>
<li><code>like</code>以通配符开头<code>(&#39;%abc...&#39;)</code> <code>mysql</code>索引失效会变成全表扫描的操作(使用覆盖索引)</li>
<li>字符串不加单引号索引失效</li>
<li>少用or,用它来连接时会索引失效</li>
</ol>
<p>假设<code>index(a,b,c)</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where子句                                               索引是否被使用</span><br><span class="line">where a=3                                               Y,使用到a</span><br><span class="line">where a=3 and b=5                                       Y,使用到a,b</span><br><span class="line">where a=3 and b=5 and c=4								Y,使用到a,b,c</span><br><span class="line">where b=3 或者 where b=3 and c=4 或者 where c=4			 N</span><br><span class="line">where a=3 and c=5										Y,使用到了a，但是c不可以，因为b中间断了</span><br><span class="line">where a=3 and b&gt;5 and c=4								使用到了a,b, c不能用在范围之后，b断了</span><br><span class="line">where a=3 and b like&#x27;kk%&#x27; and c=4						Y,  使用到了a,b,c   range</span><br><span class="line">where a=3 and b like&#x27;%kk&#x27; and c=4						Y， 使用到了a        ref 没有使用like</span><br><span class="line">where a=3 and b like&#x27;%kk%&#x27; and c=4						Y,  使用到了a        ref 没有使用like</span><br><span class="line">where a=3 and b like&#x27;k%kk%&#x27; and c=4                     Y, 使用到了a,b,c     range</span><br></pre></td></tr></table></figure>



<p><code>where</code>后索引只要相邻列的索引出现就行，不要求顺序，但<code>order by</code>要求顺序</p>
<p><code>where   col1==&#39;a&#39;  and col2=&#39;b&#39; and col3=&#39;c&#39;</code>   与    <code>where   col2==&#39;b&#39;  and col1=&#39;a&#39; and col3=&#39;c&#39;</code></p>
<p>上面效果一样</p>
<p>但</p>
<p><code>order by c1, c2</code>   和 <code>order by c2,c1</code> 不一样， 后者会出现<code>Using filesort</code></p>
<p><code>explain select * from table1 where c1=&#39;a1&#39; and c2=&#39;a2&#39; order by c3,c2</code></p>
<p>此时不会出现<code>Using filesort</code>，因为后面的<code>c2</code>在排序时，已经为常量了</p>
<h4 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h4><ol>
<li>慢查询的开启并捕获</li>
<li>explain+慢SQL分析</li>
<li>show profile查询SQL在mysql服务器里面的执行细节和生命周期情况</li>
<li>SQL数据库服务器参数调优</li>
</ol>
<h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><ul>
<li><p>永远小表驱动大表，即小的数据驱动大的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id = B.id</span><br><span class="line">当B表的数据集小于A表的数据集时，用<span class="keyword">in</span>优于<span class="keyword">exists</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id</span><br><span class="line">当A表的数据集小于B表时，用<span class="keyword">exists</span>优于<span class="keyword">in</span></span><br><span class="line">注意：A表与B表的</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (subquery)</span><br><span class="line">该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（<span class="literal">TRUE</span>或<span class="literal">FALSE</span>）来决定主查询的数据结果是否得以保留</span><br><span class="line"></span><br><span class="line">提示</span><br><span class="line"><span class="number">1.</span><span class="keyword">EXISTS</span>（subquery）只返回了<span class="literal">TRUE</span>或<span class="literal">FALSE</span>，因此子查询中的<span class="keyword">SELECT</span>＊也可以是<span class="keyword">SELECT</span> <span class="number">1</span> 或<span class="keyword">SELECT</span> <span class="string">&#x27;X&#x27;</span>，官方说法是实际执行会忽略<span class="keyword">SELECT</span>清单，因此没有区别</span><br><span class="line"><span class="number">2.</span><span class="keyword">EXISTS</span>子查询的实际执行过程可能经过了优化而不是我们理解的逐条对比，如果担忧效率问题，可以进行检验以确定是否有效率问题</span><br><span class="line"><span class="number">3.</span><span class="keyword">EXISTS</span>子查询往往也可以用条件表达式、其它子查询或者<span class="keyword">JOIN</span>来代替，何种最优需要具体问题具体分析</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="ORDER-BY关键字优化"><a href="#ORDER-BY关键字优化" class="headerlink" title="ORDER BY关键字优化"></a>ORDER BY关键字优化</h4><ul>
<li><p><code>MySQL</code>支持两种方式的排序，<code>FileSort</code>和<code>Index</code>，<code>Index</code>效率高，它指<code>Mysql</code>扫描索引本身完成排序。<code>FileSort</code>方式效率较低</p>
<p><code>ORDER BY</code>满足两种情况，会使用<code>Index</code>方式排序：</p>
<p>1.order by语句使用索引最左前列 </p>
<p>2.使用where子句与order by子句条件列组合满足索引最左前列</p>
</li>
</ul>
<ul>
<li>order by 子句，尽量使用Index方式排序，避免使用FileSort方式排序</li>
<li>尽可能在索引列上完成排序操作，遵照索引键的最佳左前缀</li>
<li>如果不在索引列上，filesort有两种算法：MySQL就就要启动双路排序和单路排序</li>
<li>优化策略<ul>
<li>增大sort_buffer_size参数</li>
<li>增大max_length_for_sort_data参数</li>
<li>why</li>
</ul>
</li>
</ul>
<h5 id="为排序使用索引"><a href="#为排序使用索引" class="headerlink" title="为排序使用索引"></a>为排序使用索引</h5><ul>
<li><code>Mysql</code>有两种排序方式：文件排序或扫描有序索引排序</li>
<li><code>Mysql</code>能为排序与查询使用相同的索引</li>
</ul>
<p><code>KEY　a_b_c(a,b,c)</code></p>
<p>order by 能使用索引最左前缀</p>
<ul>
<li><code>order by a</code></li>
<li><code>order by a,b</code></li>
<li><code>order by a,b,c</code></li>
<li><code>order by a desc, b desc, c desc</code></li>
</ul>
<p>如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</p>
<ul>
<li><code>WHERE a=const ORDER BY b,c</code></li>
<li><code>WHERE a = const AND b = const ORDER BY c</code></li>
<li><code>WHERE a = const ORDER BY b,c</code></li>
<li><code>WHERE a = const AND b&gt;const ORDER BY b,c</code></li>
</ul>
<p>不能使用索引进行排序</p>
<ul>
<li><code>ORDER BY a ASC, B DESC, c DESC</code>   <em>排序不一致</em></li>
<li><code>WHERE g=const ORDER BY b,c</code> <em>丢失a索引</em></li>
<li><code>WHERE a=const ORDER BY c</code> <em>丢失b索引</em></li>
<li><code>WHERE a=const ORDER BY a,d</code>  <em>d不是索引的一部分</em></li>
</ul>
<h4 id="GROUP-BY-关键字优化"><a href="#GROUP-BY-关键字优化" class="headerlink" title="GROUP BY 关键字优化"></a>GROUP BY 关键字优化</h4><ul>
<li>group by 实质是先排序后在分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大max_length_for_sort_data参数+增大sort_buffer_size参数</li>
<li>where 高于 having， 能写在where限定条件就不要去having限定了</li>
</ul>
<p><code>show variables like &#39;long_query_time&#39;;</code></p>
<p><code>set gloabl long_query_time=3;</code></p>
<p><code>show variables like &#39;profiling&#39;;</code></p>
<p><code>set profiling=on;</code></p>
<p><code>show profiles;</code></p>
<p><code>show profile cpu,block io for query 1;</code></p>
<h3 id="mysql锁机制"><a href="#mysql锁机制" class="headerlink" title="mysql锁机制"></a><code>mysql</code>锁机制</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ul>
<li>从多数据的操作类型分（读\写）<ul>
<li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响</li>
<li>写锁（排它锁）：当前写操作没有完成前，他会铸锻其他写锁和读锁</li>
</ul>
</li>
<li>从对数据操作的粒度分<ul>
<li>表锁：偏向<code>MyISAM</code>存储引擎，开销小，加锁快；无死锁；锁定力度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行锁： 偏向<code>Innodb</code>存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最下，发生锁冲突的概率最低，并发度高。</li>
</ul>
</li>
</ul>
<p><code>Innodb</code>和<code>MyISAM</code>的最大不同有两点：一是支持事务，二十采用了行级锁</p>
<p><strong>MYISAM</strong></p>
<p><strong>加读锁</strong></p>
<p><code>session_1</code>                                                                     <code>session_2</code></p>
<p>获得表<code>myblock</code>的READ锁定                                        连接终端</p>
<p><code>lock table myblock read;</code></p>
<p>当前session可以查询表                                                 其他session也可以查询</p>
<p>当前session不能查看其它没有锁定的表                    其它session可以查看和更新未锁定的表</p>
<p>当前session中插入或者更新锁定的表都会提示错误      其它session插入或更新表会一直等待来获得锁</p>
<p><strong>加写锁</strong></p>
<table>
<thead>
<tr>
<th align="center">session_1</th>
<th align="center">session_2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获得表<code>mylock</code>的write锁定</td>
<td align="center">待session1开启后，session2再连接终端</td>
</tr>
<tr>
<td align="center">当前session对锁定表的查询+更新+插入操作都可以执行</td>
<td align="center">其它session对锁定表的查询将被阻塞，需要等待锁被释放</td>
</tr>
</tbody></table>
<p> 简而言之，就是读锁会阻塞写，但是不会阻塞度，而写锁则会把读和写都阻塞</p>
<h4 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h4><p><code>show open tables;</code>查看哪些表被加锁了</p>
<p><strong>如何分析表锁定</strong></p>
<p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定</p>
<p>sql:<code>show status like &#39;table%&#39;</code></p>
<p>table_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即去锁值加1</p>
<p>table_locks_waited：出现标记锁定征用而发生等待的次数（不能立即获取锁，每等待依次锁值加1），此值高则说明纯在着较严重的表级锁征用情况</p>
<p>此外，<code>myisam</code>的读写调度是写优先，这也是<code>mysiam</code>不适合做写为主表的引擎。因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞</p>
<h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p>由于行锁支持事务，并发事务的处理会带来下面的问题：</p>
<ul>
<li>更新丢失</li>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<p><strong>事务隔离级别</strong></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">读数据一致性</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读取未提交</td>
<td align="center">最低界别，只能保证不读取物理上的损坏数据</td>
<td align="center">⚪</td>
<td align="center">⚪</td>
<td align="center">⚪</td>
</tr>
<tr>
<td align="center">读取已提交</td>
<td align="center">语句级</td>
<td align="center"></td>
<td align="center">⚪</td>
<td align="center">⚪</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">事务级</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">⚪</td>
</tr>
<tr>
<td align="center">可序列化</td>
<td align="center">最高级别，事务级</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>索引失效会导致行锁变表锁</strong></p>
<ul>
<li><code>varchar</code>类型使用整数赋值</li>
</ul>
<p><strong>什么是间隙锁</strong></p>
<p>当我们用范围条件，而不是相等条件检索数据，并请求共享或者排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；遂于键值在条件范围内但并不存在的记录，叫做“间隙（gap）”,InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁（Next-key锁）。</p>
<p><strong>危害</strong></p>
<p>因为Query执行过程中通过范围查找的话，他会锁定整个范围内的所有索引键值，即使这个键值并不存在，间隙锁有一个比较知名的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内任何数据。在某些场景下这可能会对性能造成很大的危害。</p>
<p><strong>如何锁定一行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> my_table <span class="keyword">where</span> a=<span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;//锁定某一行后，其它的操作会被阻塞，直到锁定行的会话提交<span class="keyword">commit</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>



<p>通过检查INNODB_ROW_LOCK装填变量来分析系统上的行锁的争夺情况</p>
<p><code>show status like&#39;innodb_row_lock%&#39;</code></p>
<p>对各个状态量的说明如下：</p>
<p><code>innodb_row_lock_current_waits</code>:当前正在等待锁定的数量</p>
<p><code>innodb_row_lock_time</code>: 从系统启动到现在锁定的总时间长度</p>
<p><code>innodb_row_lock_time_avg</code>: 每次等待的平均时间</p>
<p><code>innodb_row_lock_time_max</code>: 从系统启动到现在等待最长的依次所花时间</p>
<p><code>innodb_row_lock_waits</code>: 系统启动到现在总共等待的次数</p>
<p>对于这5各状态变量，比较重要的是</p>
<p><code>innodb_row_lock_time_avg</code>:等待平均时长</p>
<p><code>innodb_row_lock_waits</code>: 总共等待的次数</p>
<p><code>innodb_row_lock_time</code>: 等待总时间长度</p>
<p><strong>优化建议</strong></p>
<ul>
<li>尽可能让所有数据检索都通过索引来完成，避免五索引行锁升级为表锁</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能较少的检索条件，避免间隙锁</li>
<li>尽可能控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可能低级别的事务隔离</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><strong>复制的基本原理：</strong></p>
<p>slave会从master读取binlog来进行数据同步</p>
<p><strong>复制过程</strong></p>
<ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events</li>
<li>slave将master的binary log events拷贝到它的中继日志（relay log）</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中。Mysql复制是一步串行化的</li>
</ol>
<p><strong>复制的基本原则</strong></p>
<ul>
<li>每个slave只有一个master</li>
<li>每个slave只能由一个唯一的服务器ID</li>
<li>每个master可以由多个slave</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的扩容机制和底层源码</title>
    <url>/2021/03/27/HashMap/</url>
    <content><![CDATA[<h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p>
<p>JDK1.8之前HashMap由<strong>数组+链表（1.7）</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</p>
<p>JDK1.8之后HashMap的组成多了红黑树，在满足下面两个条件后，会执行链表转换为红黑树操作，依次来加快搜索速度。</p>
<ul>
<li>链表长度大于阈值（默认为8）</li>
<li>HashMap数组长度超过64<a id="more"></a>

</li>
</ul>
<h4 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h4><h5 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a><strong>JDK1.8之前</strong></h5><p>JDK1.8之前HashMap底层是<strong>数组+链表</strong>结合在一起使用也就是<strong>链表散列</strong>。</p>
<p>HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过**(n-1) &amp; hash**判断当前元素存放的位置（n为数组长度），如果当前位置存在元素的话，就判断该元素与要存入元素的hash值以及key是否相同，如果相同，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK1.8 HashMap的hash方法源码：</strong></p>
<p>JDK1.8的hash方法 相比于JDK１.７方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// key.hashCode():返回散列值也就是hashCode</span></span><br><span class="line">    <span class="comment">// ^:按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key==<span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下JDK１.７的HashMap的hash方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于JDK１.８的hash方法，JDK1.7的hash方法的性能稍微会差一点，因为毕竟扰动了4次。</p>
<p>所谓“拉链法”就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一个就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="D:\blog\imge\jdk1.8之前的内部结构.png"></p>
<h5 id="JDK１-８之后"><a href="#JDK１-８之后" class="headerlink" title="JDK１.８之后"></a>JDK１.８之后</h5><p>相比于之前的版本，JDK１.８以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为８）时，会首先调用　treeifyBIn() 的方法。这个方法会根据HashMap数组来决定是否转换为红黑树。只有当数组长度大于或者等于64的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行resize() 方法对数组扩容。</p>
<p><img src="D:\blog\imge\up-bba283228693dae74e78da1ef7a9a04c684.png"></p>
<p><strong>类的属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loadFactor 加载因子</strong></li>
</ul>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据（entry）也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<ul>
<li><strong>threshold</strong></li>
</ul>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
<p><strong>Node节点源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树节点类源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><p>HashMap中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a><strong>putMapEntries方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h5><p>HashMap只是提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对putVal方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素，就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不同，就判断p是否为一个树节点，如果是就调用 <code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加进入。如果不是就遍历链表插入（插入的是链表尾部）。</li>
</ol>
<p><img src="D:\blog\imge\put方法.png"></p>
<p>说明：上图有两个小问题：</p>
<ul>
<li>直接覆盖之后就会return，不会有后续操作。</li>
<li>当链表长度大于阈值（默认为8）并且HashMap数组长度超过64的时候才会执行链表转化为红黑树的操作，否则就只是对数组的扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下JDK1.7 put代码方法的代码</strong></p>
<p><strong>对比put方法的分析如下：</strong></p>
<ul>
<li>如果定位的数组位置没有元素就直接插入</li>
<li>如果定位的数组位置有元素，遍历这个元素为头节点的链表，依次和插入的key比较，如果相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123;</span><br><span class="line">    	inflateTable(threshold);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>进行扩容，会伴随着一次重新分配hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编程中，要尽量避免resize.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>java容器</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码</title>
    <url>/2021/03/28/LinkedList/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>LinkedList是一个实现了List接口和Deque接口的双端链表。LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用Collections中的synchronizedList方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>

<h4 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a>内部结构分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//节点值</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>add(E e)方法：将元素添加到链表尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkLast(e);<span class="comment">//这里就只调用了这一个方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     last = newNode;<span class="comment">//新建节点</span></span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;<span class="comment">//指向后继元素也就是指向下一个元素</span></span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**add(int index,E e)**：在指定位置添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       checkPositionIndex(index); <span class="comment">//检查索引是否处于[0-size]之间</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (index == size)<span class="comment">//添加在链表尾部</span></span><br><span class="line">           linkLast(element);</span><br><span class="line">       <span class="keyword">else</span><span class="comment">//添加在链表中间</span></span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>linkBefore</code>方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了<code>Node(index)</code>去找到index对应的node</p>
<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1:检查index范围是否在size之内</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">           succ = <span class="keyword">null</span>;</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           succ = node(index);</span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">           <span class="comment">//创建新节点</span></span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       size += numNew;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面可以看出addAll方法通常包括下面四个步骤：</p>
<ol>
<li>检查index范围是否在size之内</li>
<li>toArray()方法把集合的数据存到对象数组中</li>
<li>得到插入位置的前驱和后继节点</li>
<li>遍历数据，将数据插入到指定位置</li>
</ol>
<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      linkFirst(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建节点，以头节点为后继节点</span></span><br><span class="line">       first = newNode;</span><br><span class="line">       <span class="comment">//如果链表为空，last节点也指向该节点</span></span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           last = newNode;</span><br><span class="line">       <span class="comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h5><p><strong>get(int index)：</strong> 根据指定索引返回数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">       <span class="keyword">return</span> node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>获取头节点（index=0）数据方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> f.item;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong> getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>
<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">      <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> l.item;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">      <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>两者区别：</strong> <strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>
<h5 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a>根据对象得到索引的方法</h5><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从头遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从头遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = size;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从尾遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从尾遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="检查链表是否包含某对象的方法"><a href="#检查链表是否包含某对象的方法" class="headerlink" title="检查链表是否包含某对象的方法"></a>检查链表是否包含某对象的方法</h5><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>removeLast(),pollLast():</strong> 删除尾节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>
<p><strong>remove(Object o):</strong> 删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果删除对象为null</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从头开始遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="comment">//找到元素</span></span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从头开始遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="comment">//找到元素</span></span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                   <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<p>**remove(int index)**：删除指定位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index范围</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//将节点删除</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a>LinkedList类常用方法测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存放int类型的linkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/************************** linkedList的基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>); <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>); <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>); <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList（直接输出的）: &quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;getFirst()获得第一个元素: &quot;</span> + linkedList.getFirst()); <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getLast()获得第最后一个元素: &quot;</span> + linkedList.getLast()); <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;removeFirst()删除第一个元素并返回: &quot;</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;removeLast()删除最后一个元素并返回: &quot;</span> + linkedList.removeLast()); <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After remove:&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;contains()方法判断列表是否包含1这个元素:&quot;</span> + linkedList.contains(<span class="number">1</span>)); <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;该linkedList的大小 : &quot;</span> + linkedList.size()); <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After set(1, 3):&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;get(1)获得指定位置（这里为1）的元素: &quot;</span> + linkedList.get(<span class="number">1</span>)); <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Search操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;indexOf(3): &quot;</span> + linkedList.indexOf(<span class="number">3</span>)); <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">&quot;lastIndexOf(3): &quot;</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Queue操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;peek(): &quot;</span> + linkedList.peek()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">&quot;element(): &quot;</span> + linkedList.element()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll(); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After poll():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;After remove():&quot;</span> + linkedList); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After offer(4):&quot;</span> + linkedList); <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Deque操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>); <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After offerFirst(2):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>); <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After offerLast(5):&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;peekFirst(): &quot;</span> + linkedList.peekFirst()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;peekLast(): &quot;</span> + linkedList.peekLast()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst(); <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pollFirst():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.pollLast(); <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pollLast():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>); <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After push(2):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.pop(); <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pop():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After removeFirstOccurrence(3):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After removeFirstOccurrence(3):&quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 遍历操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Iterator：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;for：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;for2：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;pollFirst()或pollLast()：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;removeFirst()或removeLast()：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>源码</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList的扩容机制和底层源码</title>
    <url>/2021/03/28/ArrayList/</url>
    <content><![CDATA[<h3 id="1-ArrayList简介"><a href="#1-ArrayList简介" class="headerlink" title="1.ArrayList简介"></a>1.ArrayList简介</h3><p>ArrayList 的底层是数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。在添加大量元素前，应用成勋可以使用ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
<p>ArrayList 继承于 AbstractList , 实现了List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RandomAccess 是一个标志接口，表明实现这个接口的List集合是支持快速访问的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone（），能被克隆。</li>
<li>ArrayList 实现了 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>
</ul>
<h4 id="1-1-ArrayList-和-Vector-的区别？"><a href="#1-1-ArrayList-和-Vector-的区别？" class="headerlink" title="1.1.ArrayList 和 Vector 的区别？"></a>1.1.ArrayList 和 Vector 的区别？</h4><ol>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全。</li>
<li><code>Vector </code>是 <code>List</code> 的古老实现类，底层使用 Object[] 存储，线程安全。</li>
</ol>
<h4 id="1-2-ArrayList-和-LinkedList-的区别？"><a href="#1-2-ArrayList-和-LinkedList-的区别？" class="headerlink" title="1.2.ArrayList 和 LinkedList 的区别？"></a>1.2.ArrayList 和 LinkedList 的区别？</h4><ol>
<li><strong>是否保证线程安全</strong>：<code>ArrayList </code>和<code> LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>：<code>ArrayList </code>底层使用的是Object[] 数组；<code>LinkedList</code> 底层采用的是双向链表；</li>
<li><strong>插入和删除是否受到元素位置的影响</strong>：① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问</strong>：<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h3 id="2-ArrayList核心源码解读"><a href="#2-ArrayList核心源码解读" class="headerlink" title="2.ArrayList核心源码解读"></a>2.ArrayList核心源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-ArrayList-扩容机制分析"><a href="#3-ArrayList-扩容机制分析" class="headerlink" title="3.ArrayList 扩容机制分析"></a>3.ArrayList 扩容机制分析</h3><h4 id="3-1-先从ArrayList的构造函数说起"><a href="#3-1-先从ArrayList的构造函数说起" class="headerlink" title="3.1.先从ArrayList的构造函数说起"></a>3.1.先从ArrayList的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>细心的同学一定会发现：以午餐构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。下面我们在分析ArrayList扩容时，会讲到这一点内容！</p>
<p>补充：JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建<strong>类似于单例的饿汉式</strong>，而jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</p>
<h4 id="3-2-一步一步分析ArrayList扩容机制"><a href="#3-2-一步一步分析ArrayList扩容机制" class="headerlink" title="3.2.一步一步分析ArrayList扩容机制"></a>3.2.一步一步分析ArrayList扩容机制</h4><p>这里以无参构造函数创建的ArrayList为例分析</p>
<h5 id="3-2-1add-方法"><a href="#3-2-1add-方法" class="headerlink" title="3.2.1add()方法"></a>3.2.1add()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
<h5 id="3-2-2-ensureCapacityInternal-方法"><a href="#3-2-2-ensureCapacityInternal-方法" class="headerlink" title="3.2.2.ensureCapacityInternal() 方法"></a>3.2.2.ensureCapacityInternal() 方法</h5><p>（JDK7）可以看到add方法首先调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当要 add 第一个元素的时候，minCapacity 为1，在Math.max之后，minCapacity为10。</strong></p>
<h5 id="3-2-3-ensureExplicitCapacity-方法"><a href="#3-2-3-ensureExplicitCapacity-方法" class="headerlink" title="3.2.3.ensureExplicitCapacity() 方法"></a>3.2.3.ensureExplicitCapacity() 方法</h5><p>如果调用 ensureCapacityInternal() 方法就一定会（执行）这个方法，下面我们来研究这个方法的源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 <code>add</code> 进第一个元素时，<code>elementData.length</code> 为0（因为此时还是一个空的list），因为执行了 <code>ensureCapacityInternal() </code>方法，所以此时<code>minCapacity</code> 为10。此时，<code>minCapacity - elementData.length&gt;0</code>成立，所以会进入 <code>grow(minCapacity) </code>方法。</li>
<li>当 add 第2个元素时，<code>minCapacity</code> 为2， 此时<code>elementData.length</code>在添加第一个元素后扩容为10，此时，<code>minCapacity - elementData.length&gt;0</code>不成立，所以不会进入 <code>grow(minCapacity) </code>方法。</li>
<li>添加第3、4、、、、10个元素时，依然不会执行 <code>grow</code> 方法，数组容量为10。</li>
<li>直到添加第11个元素，<code>minCapacity</code>(为11)比<code>elementData.length</code>(为10)要大。进入grow方法扩容。</li>
</ul>
<h5 id="3-2-4-grow-方法"><a href="#3-2-4-grow-方法" class="headerlink" title="3.2.4 grow() 方法"></a>3.2.4 grow() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以ArrayList每次扩容之后都会变为原来的1.5倍左右（oldCapacity为偶数就是1.5倍，否则就是1.5倍左右）。</p>
<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h5 id="3-2-5-hugeCapacity-方法"><a href="#3-2-5-hugeCapacity-方法" class="headerlink" title="3.2.5.hugeCapacity()方法"></a>3.2.5.hugeCapacity()方法</h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-System-arrayCopy-和Arrays-copyOf-方法"><a href="#3-3-System-arrayCopy-和Arrays-copyOf-方法" class="headerlink" title="3.3.System.arrayCopy()和Arrays.copyOf()方法"></a>3.3.System.arrayCopy()和Arrays.copyOf()方法</h4><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h5 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1.System.arraycopy() 方法"></a>3.3.1.System.arraycopy() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们写一个简单的方法测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2.Arrays.copyOf()方法"></a>3.3.2.Arrays.copyOf()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-两者的联系和区别"><a href="#3-3-3-两者的联系和区别" class="headerlink" title="3.3.3.两者的联系和区别"></a>3.3.3.两者的联系和区别</h5><p><strong>联系</strong>：</p>
<p>看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法</p>
<p><strong>区别</strong>：</p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h4 id="3-4-ensureCapacity方法"><a href="#3-4-ensureCapacity方法" class="headerlink" title="3.4.ensureCapacity方法"></a>3.4.ensureCapacity方法</h4><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="line"> *</span><br><span class="line"> * @param   <span class="keyword">min</span>Capacity   所需的最小容量</span><br><span class="line"> */</span><br><span class="line">public void ensureCapacity(int <span class="keyword">min</span>Capacity) &#123;</span><br><span class="line">    int <span class="keyword">min</span>Expand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        // <span class="literal">any</span> size if not <span class="keyword">default</span> element <span class="built_in">table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        // larger than <span class="keyword">default</span> <span class="keyword">for</span> <span class="keyword">default</span> empty <span class="built_in">table</span>. It&#x27;s already</span><br><span class="line">        // supposed <span class="keyword">to</span> be at <span class="keyword">default</span> size.</span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    if (<span class="keyword">min</span>Capacity &gt; <span class="keyword">min</span>Expand) &#123;</span><br><span class="line">        ensureExplicitCapacity(<span class="keyword">min</span>Capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
]]></content>
      <categories>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>java容器</tag>
        <tag>源码</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
</search>
