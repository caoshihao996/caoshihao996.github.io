<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CoinsWay</title>
    <url>/2020/12/28/CoinWays/</url>
    <content><![CDATA[<h4 id="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"><a href="#使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张" class="headerlink" title="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"></a>使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张</h4><pre><code>从左到右的模型，依次判断index位置上的纸币用几张，当index到达length时，如果rest==0，则该方法有效
返回1，否则返回0.在由暴力递归改成动态规划时，要考虑枚举问题。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ways1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：0~index-1位置上的货币使用已经确定，从index之后的货币使用方法数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选用index位置上的货币</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">1</span>; zhang*arr[<span class="keyword">index</span>] &lt;= rest; zhang++)&#123;</span><br><span class="line">		p2 += process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest - zhang*arr[<span class="keyword">index</span>]);<span class="comment">//选用index位置上的货币，至少一张</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法，每个格子有枚举行为，细粒度划分</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			<span class="built_in">int</span> ways = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">0</span>; zhang*arr[<span class="keyword">index</span>]&lt;=rest; zhang++)&#123;</span><br><span class="line">				ways += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-zhang*arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划方法，省去枚举行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];<span class="comment">//没有使用cur位置上的</span></span><br><span class="line">			<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>][rest-arr[<span class="keyword">index</span>]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CardInLine</title>
    <url>/2020/12/27/CardInLine/</url>
    <content><![CDATA[<h4 id="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"><a href="#玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值" class="headerlink" title="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"></a>玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值</h4><pre><code>给定一个整形数组arr，代表数值不同的纸牌拍成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后
拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都决定聪明。请问最后获胜者的分数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( L==R )&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(arr[L] + s(arr, L+<span class="number">1</span>, R), arr[R] + s(arr, L, R<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;			<span class="comment">//先手函数选了arr[L]</span></span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">min</span>(f(arr, L+<span class="number">1</span>, R), f(arr, L, R<span class="number">-1</span>));<span class="comment">//对手会让你选择最小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>), s(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpWay</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr ==null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">	<span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; i++)&#123;</span><br><span class="line">		f[i][i] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//s[i][i]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = i;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;N &amp;&amp; R&lt;N)&#123;</span><br><span class="line">			f[L][R] = Math.<span class="built_in">max</span>(arr[L]+s[L+<span class="number">1</span>][R], arr[R]+s[L][R<span class="number">-1</span>]);</span><br><span class="line">			s[L][R] = Math.<span class="built_in">min</span>(arr[L]+f[L+<span class="number">1</span>][R], arr[R]+f[L][R<span class="number">-1</span>]);</span><br><span class="line">			L++;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f[<span class="number">0</span>][N<span class="number">-1</span>], s[<span class="number">0</span>][N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2021/03/19/BinaryTreeLayer/</url>
    <content><![CDATA[<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;<span class="type">Integer</span>&gt; PrintFromTopToBottom(TreeNode root)&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;<span class="type">Integer</span>&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			ret.<span class="keyword">add</span>(t.val);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.left);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h4 id="二叉树的多行遍历"><a href="#二叉树的多行遍历" class="headerlink" title="二叉树的多行遍历"></a>二叉树的多行遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			list.<span class="keyword">add</span>(t.val);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.lef);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">			ret.<span class="keyword">add</span>(list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt; &gt; ret = <span class="built_in">new</span> ArrayList;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.<span class="keyword">add</span>(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">reverse</span> = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    	ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> cnt = queue.size();</span><br><span class="line">    	<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">    		TreeNode t = queue.poll();</span><br><span class="line">    		<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		list.<span class="keyword">add</span>(t.val);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.left);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">reverse</span>)</span><br><span class="line">    		Colllections.reverse(list);</span><br><span class="line">    	<span class="keyword">reverse</span>=!<span class="keyword">reverse</span>;</span><br><span class="line">    	<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">    		ret.<span class="keyword">add</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>广度优先遍历</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">	<span class="comment">//找出数组中最大值和最小值</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">max</span> = Integer.MIN_VALUE;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化计数数组count[]</span></span><br><span class="line">	<span class="comment">//长度为最大值减去最小值加1，再加1</span></span><br><span class="line">	<span class="type">int</span>[] <span class="built_in">count</span> = new <span class="type">int</span>[<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数，并确保count[0]永远为0</span></span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">count</span>[num-<span class="built_in">min</span>+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计数数组变形，新元素是的值是前面元素的累加之和的值</span></span><br><span class="line">	for(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">count</span>.length;i++)&#123;</span><br><span class="line">		<span class="built_in">count</span>[i] += <span class="built_in">count</span>[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建结果数组</span></span><br><span class="line">	<span class="type">int</span>[] result = new <span class="type">int</span>[arr.length];</span><br><span class="line">	<span class="comment">//遍历arr中的元素，填充到结果数组中去，从前往后遍历</span></span><br><span class="line">	for(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]] = arr[j];</span><br><span class="line">		<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ConvertToLetters</title>
    <url>/2020/12/27/ConvertToLetters/</url>
    <content><![CDATA[<h4 id="将数字转化为字母有多少种方法，从左往右的尝试模型"><a href="#将数字转化为字母有多少种方法，从左往右的尝试模型" class="headerlink" title="将数字转化为字母有多少种方法，从左往右的尝试模型"></a>将数字转化为字母有多少种方法，从左往右的尝试模型</h4><pre><code>规定1和A对应、2和B对应、3和C对应...的规则。那么一个数字字符串比如“111”就可以转化为AAA、KA、AK。给定一个只
有数字字符串组成的字符串str,返回有多少种转化结果。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> numbers(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span> == <span class="keyword">null</span> || <span class="built_in">str</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(<span class="built_in">str</span>.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str[0..i-1]已经转化完了，固定了</span></span><br><span class="line"><span class="comment">//返回值：从i开始到结尾有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process1(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str[i] == &#x27;3&#x27;~&#x27;9&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> process(<span class="built_in">str</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="built_in">int</span> N = <span class="built_in">str</span>.length;</span><br><span class="line">	<span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>];</span><br><span class="line">	dp[N] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>NQueens</title>
    <url>/2020/12/27/NQueens/</url>
    <content><![CDATA[<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><pre><code>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n
返回n种皇后的摆法有多少种。
n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//record[i]-&gt;i行的皇后，放在了第几列</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//潜台词：record[0...i-1]的皇后，任何两个皇后都不共行、不共列、不共斜线</span></span><br><span class="line"><span class="comment">//目前来到了第i行</span></span><br><span class="line"><span class="comment">//record[0..i-1]表示之前的行，放了皇后的列的序号</span></span><br><span class="line"><span class="comment">//返回值，接着把i...之后摆完，有多少种摆法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//i来到证明前面的摆法有效，返回1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//依次尝试i行的皇后摆放在什么位置</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isValid</span>(record, i, j))&#123;</span><br><span class="line">			record[i] = j;</span><br><span class="line">			res += <span class="built_in">process</span>(i+<span class="number">1</span>, record, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(record[k] ==j || Math.<span class="built_in">abs</span>(k-i) == Math.<span class="built_in">abs</span>(recod[k]-j))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用位运算计算不超过32皇后的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&lt;<span class="number">32</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果你是9皇后问题，limit最右9个是1，其他都是0</span></span><br><span class="line">	<span class="keyword">int</span> limit = n == <span class="number">32</span> ? <span class="number">-1</span> : (<span class="number">1</span>&lt;&lt;n) <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit 划定了问题的规模，是固定的</span></span><br><span class="line"><span class="comment">//colLim 列的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDiaLim, <span class="keyword">int</span> rightDiaLim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colLim == limit)&#123;<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有候选皇后的位置，都在pos上</span></span><br><span class="line">    <span class="comment">//colLim | leftDiaLim | rightDigLim -&gt; 总限制</span></span><br><span class="line">    <span class="comment">//~(colLim | leftDiaLim | rightDigLim) -&gt; 左侧的一坨0干扰，右侧每个1可尝试</span></span><br><span class="line">    <span class="comment">//所有可以放皇后都在pos上</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//提取中pos最右侧的1，剩下位置都是0</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(limit, colLim | mostRightOne, (leftDiaLim|mostRightOne)&lt;&lt;<span class="number">1</span>,</span><br><span class="line">                (rightDiaLim|mostRightOne)&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2020/12/27/Knapsack/</url>
    <content><![CDATA[<h4 id="背包问题，从左往右的尝试模型"><a href="#背包问题，从左往右的尝试模型" class="headerlink" title="背包问题，从左往右的尝试模型"></a>背包问题，从左往右的尝试模型</h4><pre><code>给定两个长度都为N的数组weights和values，weight[i]和values[i]分别代表物品的重量和价值。给定一个正数bag
表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不变：w[] v[] bag</span></span><br><span class="line"><span class="comment">//index... 最大价值</span></span><br><span class="line"><span class="comment">//0...index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span></span><br><span class="line"><span class="comment">//如果返回-1则认为没有方法，如果不返回-1，则认为返回的值是真实值</span></span><br><span class="line"><span class="comment">//函数返回值为index之后的最大价值</span></span><br><span class="line">public <span class="type">int</span> process(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> alreadyW, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="keyword">if</span>(alreadyW&gt;bag)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//index到达length时，剩余货物的最大价值为0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW, bag);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW+w[<span class="keyword">index</span>], bag);<span class="comment">//yes</span></span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="type">int</span> process1(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest-w[<span class="keyword">index</span>]);</span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">public <span class="type">int</span> dpWay(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="type">int</span> N = w.<span class="built_in">length</span>;</span><br><span class="line">	<span class="type">int</span>[][] dp = new <span class="type">int</span>[N+<span class="number">1</span>][bag+<span class="number">1</span>];<span class="comment">//dp[N][...]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">index</span>=N<span class="number">-1</span>;<span class="keyword">index</span>&gt;=<span class="number">0</span>;<span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//dp[index][rest]=?</span></span><br><span class="line">			<span class="type">int</span> p1 = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rest - w[<span class="keyword">index</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				p2 = v[<span class="keyword">index</span>] + dp[<span class="keyword">index</span>+<span class="number">1</span>][rest - w[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PrintAllPermutations</title>
    <url>/2020/12/27/PrintAllPermutations/</url>
    <content><![CDATA[<h5 id="打印一个字符串的全部排列方式"><a href="#打印一个字符串的全部排列方式" class="headerlink" title="打印一个字符串的全部排列方式"></a>打印一个字符串的全部排列方式</h5><hr>
<pre><code>从左往右的尝试模型，排列组合的方式就是先固定0位置上的字符，即0~length-1上的字符都有可能来到0位置上，确
定0位置上的字符以后，再确定1位置上的字符，即1~length-1上的字符都有可能来到1位置上...依次类推。

在要求无重复的排列中，可以通过哈希表的方式，来记录一个字符是否在某个位置上出现过，没有出现过才进行递归。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str[0...i-1]都已经做好决定了</span></span><br><span class="line"><span class="comment">//str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">//i为终止位置，str当前的位置就是一种结果-&gt;res</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArrayList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有终止，那么i之后位置上的字符都可以来到i位置上</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; <span class="built_in">str</span>.length; j ++)&#123;</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		process(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> swap(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] temp = <span class="built_in">str</span>[i];</span><br><span class="line">	<span class="built_in">str</span>[i] = <span class="built_in">str</span>[j];</span><br><span class="line">	<span class="built_in">str</span>[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串的所有排序方式，没有重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArratList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">boolean</span>[] visit = <span class="keyword">new</span> <span class="built_in">boolean</span>[<span class="number">26</span>];<span class="comment">//26个字母，当前位置，不与其他位置共享</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;<span class="built_in">str</span>.length; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">false</span>)&#123;</span><br><span class="line">			visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">			process2(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span>[] radixSort(<span class="built_in">int</span>[] arr， <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">	<span class="built_in">int</span>[] <span class="built_in">count</span> = new <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">len</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> division = (<span class="built_in">int</span>)Math.pow(<span class="number">10</span>,i);</span><br><span class="line">		for(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[j]/division%<span class="number">10</span>;</span><br><span class="line">			<span class="built_in">count</span>[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> m=<span class="number">1</span>; m&lt;count.length;m++)&#123;</span><br><span class="line">			<span class="built_in">count</span>[m] = <span class="built_in">count</span>[m] + <span class="built_in">count</span>[m-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> <span class="built_in">n</span>=arr.length-<span class="number">1</span>;<span class="built_in">n</span>&gt;=<span class="number">0</span>;<span class="built_in">n</span>--)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[<span class="built_in">n</span>] / division % <span class="number">10</span>;</span><br><span class="line">			result[<span class="built_in">count</span>[num]]=arr[<span class="built_in">n</span>];</span><br><span class="line">			<span class="built_in">count</span>[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		Arrays.fill(<span class="built_in">count</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>printAllSubSquence</title>
    <url>/2020/12/27/PrintAllSubsquences/</url>
    <content><![CDATA[<h4 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h4><hr>
<pre><code>从左往右的尝试模型，从0位置出发，依次判断每个位置的字符是否选择，当index到达字符串末尾时，将所形成的字符
path加入结果的集合中。</code></pre>
<hr>
<a id="more"></a>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subs(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	List&lt;<span class="keyword">String</span>&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	process1(<span class="built_in">str</span>, <span class="number">0</span>, ans, path);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str固定参数</span></span><br><span class="line"><span class="comment">//index，此时进行判断的位置下标，要 or 不要</span></span><br><span class="line"><span class="comment">//如果index来到str的终止位置，就把沿途路径所形成的答案放在ans中</span></span><br><span class="line"><span class="comment">//之前做出的选择就是path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, List&lt;<span class="keyword">String</span>&gt; ans, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		ans.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一个字符串的全部子序列，且要求不要重复出现的子序列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subsNoRepeate(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	process2(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">set</span>, path);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span>, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="built_in">set</span>.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotMove</title>
    <url>/2020/12/27/RobotMove/</url>
    <content><![CDATA[<h4 id="机器人的移动问题"><a href="#机器人的移动问题" class="headerlink" title="机器人的移动问题"></a>机器人的移动问题</h4><pre><code>假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个）。
如果机器人来打1位置上，那么下一步一定只能往右走来打2位置；如果机器人来到N位置，那么下一步只能往左来到N-1
的位置；如果机器人来打中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也
是1~N中的一个）的方法有多少种，给定四个参数N、M、K、P，返回方法数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//总共N个位置，从M点出发，还剩K步，返回最终能到达P的方法数</span></span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, M, K, P)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N:位置1~N，固定参数</span></span><br><span class="line"><span class="comment">//cur:当前在cur位置，可变参数</span></span><br><span class="line"><span class="comment">//rest:剩余的步数，可变参数</span></span><br><span class="line"><span class="comment">//P：最终的目标位置</span></span><br><span class="line"><span class="comment">//该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果没有剩余步数了，当前的cur位置就是最后的位置</span></span><br><span class="line">    <span class="comment">//如果最后的位置停在P上，那么之前做的移动是有效的</span></span><br><span class="line">    <span class="comment">//如果最后的位置没在P上，那么之前做的移动式无效</span></span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> cur==P ? <span class="number">1</span> : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span></span><br><span class="line">    <span class="comment">//后续的过程就是，来到2位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, <span class="number">2</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span></span><br><span class="line">	<span class="comment">//后续的过程就是，来到N-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以想左也可以向右</span></span><br><span class="line">    <span class="comment">//走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">//走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P) + walk(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">waysCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;=N; row++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;=K;col++)&#123;</span><br><span class="line">			dp[row][col]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walkCache</span><span class="params">(N, M, K, P, dp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表方法，把cur和rest所有方法加入到缓存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walkCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[cur][rest]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		dp[cur][rest] = cur == P ? <span class="number">1</span> : 0;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, <span class="number">2</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[cur][rest] = walkCache(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P, dp) + walkCache(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">	<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">dpWays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	dp[P][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//dp[!P][...]=0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= K; rest++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">1</span>; cur &lt;= N; cur++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">				dp[cur][rest] = dp[<span class="number">2</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(cur==N)</span></span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[N<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[cur+<span class="number">1</span>][rest<span class="number">-1</span>]+dp[cur<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[M][P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2021/03/25/mysql/</url>
    <content><![CDATA[<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5之前）。虽然性能极佳，而且提供大量的特性，包括全文索引、压缩、空间函数等，单MyISAM不支持事务和行级锁，最大的缺陷就是崩溃后无法安全回复。不过，5.5版本之后，MySQL引入了InnoDB（事务性性数据库引擎），MySQL5.5版本后默认的引擎为InnoDB。</p>
<a id="more"></a>
<p>大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用MyISAM也是合适的比如读密集的情况下。（如果不介意崩溃恢复的问题）。</p>
<p><strong>两者的对比</strong></p>
<ol>
<li><strong>是否支持行级锁</strong>：MyISAM只有表级锁（table-level locking）,而InnoDB支持行级锁（row-level locking）和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持，外部键等高级数据库功能。具有事务（commit）、回滚（rollback）和崩溃修复能力和事务安全型表。</li>
<li><strong>是否支持外键</strong>：MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong>：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在READ COMMITTED和REPEATABLE READ 两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现；各数据库中MVCC实现并不统一。</li>
</ol>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong>和<strong>哈希索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议使用BTree索引。</p>
<p>MySQL的BTree索引使用的是B+Tree，但是对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM</strong>：B+Tree叶节点的data域存放的数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB</strong>：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务时逻辑上的一组操作，要么执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说的例子就是转账。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的月增加1000元。万一这两个操作之间突然出现错误比如银行系统崩溃，导致小明的余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都失败。</p>
<h4 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h4><ul>
<li><strong>原子性（Atomicity）</strong>：事务时最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）</strong>：执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务干扰，个并发事务之间的数据库是独立的；</li>
<li><strong>持久性（Durability）</strong>：一个事务被提交之后。它对数据库中数据的改变是永久的，即使数据库发生故障也不应对其有任何影响。</li>
</ul>
<h4 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个任务对同一数据操作）。并发虽然是必须的，单可能会导致以下问题。</p>
<ul>
<li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到这个数据是“脏数据”，一句脏数据所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）</strong>：指在一个事务内多次读取数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内修改结果就被丢失，因此称丢失修改。</li>
<li><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问了该数据。那么第一个事务两次读取的数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据可能不一样的情况，依次称为不可重读。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本根本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="事务隔离级别有哪些？MySQL的默认隔离级别是？"><a href="#事务隔离级别有哪些？MySQL的默认隔离级别是？" class="headerlink" title="事务隔离级别有哪些？MySQL的默认隔离级别是？"></a>事务隔离级别有哪些？MySQL的默认隔离级别是？</h4><p><strong>SQL标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，</strong>可能会导致脏读、幻读或不可重复读。**</li>
<li><strong>READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，</strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。**</li>
<li><strong>REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，</strong>可以阻止脏读和不可重复读，但是幻读仍有可能发生。**</li>
<li><strong>SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说该级别</strong>可以防止脏读、不可重复读以及幻读。**</li>
</ul>
<p><strong>InnoDB引擎默认支持的隔离级别是REPEATABLE-READ（可重复读</strong>）。与SQL标准不同的地方在于，InnoDB在可重读事务隔离级别下使用的是<strong>Next-key Lock</strong>锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以锁InnoDB存储引擎的默认支持隔离级别已经完全可以保证事务的隔离性要求，即达到了SQL标准的<strong>SERIALIZABLE</strong>隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取已提交)**，但是需要知道的是InnoDB存储引擎默认使用</strong>REPEATABLE-READ（可重复读**）不会有任何性能损失。</p>
<p><strong>InnoDB引擎</strong>在分布式事务的情况下会用到<strong>SERIALIZABLE</strong>（可串行化）隔离级别。</p>
<h4 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h4><p><strong>MyISAM与InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁；</li>
<li>InnoDB采用行级锁和表级锁，默认使用行级锁。</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁</strong>：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和MySQL都是支持表级锁。</li>
<li><strong>行级锁</strong>：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种</strong>：</p>
<ul>
<li>Record　lock：单个行记录上的锁；</li>
<li>Gap　lock：间隙锁，锁定一个范围，不包括记录本省</li>
<li>Next-Key　lock：record＋Gap　锁定一个范围，包含巨鹿本身。</li>
</ul>
<p><strong>相关知识点</strong>：</p>
<ol>
<li>InnoDB对于行的查询使用了next-key lock</li>
<li>next-key lock为了解决幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显示关闭gap锁：A.将事务隔离级别设置为RC B.将参数innodb_lock_unsafe_for_binlog设置为1</li>
</ol>
<h4 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<p>1.<strong>限定数据范围</strong></p>
<p>务必禁止不带任何限制数据范围条件的查询语句。</p>
<p>2.<strong>读/写分离</strong></p>
<p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<p>3.<strong>垂直分区</strong></p>
<p>简单来说垂直分区是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><strong>垂直拆分的优点</strong>：可以使得列数据变小，在查询时减少读取的Block数，减少I/o次数。此外，垂直分区可以简化表结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起join操作，可以通过应用层进行Join来解决。此外，垂直分区会让事务变得更复杂。</p>
<p>4.<strong>水平分区</strong></p>
<p>保持表的结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对</p>
<p>于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。</p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。<strong>尽量不要对数据分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong>，一般数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案</strong>：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常见的实现。</strong></li>
<li><strong>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的MyCat、260的Atlas、网易的DDB等等都是这种架构。</strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/12/28/SnackWays/</url>
    <content><![CDATA[<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><pre><code>背包容量为w，一共有n袋零食，第i袋零食体积为v[i], 总体积不超过背包容量的
情况下，一共有多少种零食方法？（总体积为0也算一种方法）</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> nums(<span class="built_in">int</span>[] v, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == <span class="literal">null</span> || v.length==<span class="number">0</span> || w &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(v, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//rest&gt;=0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的零食</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>]=&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		p2 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest-arr[<span class="keyword">index</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span> || w&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][w+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest&lt;=w; rest++)&#123;</span><br><span class="line">		dp[N][rest] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N<span class="number">-1</span>; <span class="keyword">index</span> &lt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest &lt;= w; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line">			<span class="keyword">if</span>(rest-arr[<span class="keyword">index</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QucikSort</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">		int[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		<span class="built_in">sort</span>(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		<span class="built_in">print</span>(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">sort</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		int mid = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);<span class="comment">//获取pivot的位置</span></span><br><span class="line">		<span class="built_in">sort</span>(arr,<span class="keyword">left</span>,mid-<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,<span class="keyword">right</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int start, int end)&#123;</span><br><span class="line">		int <span class="keyword">left</span> = start;</span><br><span class="line">		int <span class="keyword">right</span> = end - <span class="number">1</span>;</span><br><span class="line">		int pivot = arr[end];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">left</span>]&lt;=pivot)<span class="keyword">left</span>++;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">right</span>]&gt;pivot)<span class="keyword">right</span>--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)<span class="built_in">swap</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(arr, <span class="keyword">left</span>, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">print</span>(int[] arr)&#123;</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="type">System</span>.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">			h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">//初始化gap的方法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap=h;gap&gt;<span class="number">0</span>;gap=(gap<span class="number">-1</span>)/<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;gap<span class="number">-1</span>;j-=gap)&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		arr[i] = arr[j] + arr[i];</span><br><span class="line">		arr[j] = arr[i] - arr[j];</span><br><span class="line">		arr[i] = arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> boolean exist(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">num</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="comment">//防止溢出</span></span><br><span class="line">	  mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">if</span>(arr[mid]==<span class="built_in">num</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;<span class="built_in">num</span>) right = mid - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">else</span> left = left + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid] == <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static <span class="built_in">int</span> nearestIndex(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">value</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">index</span> = -<span class="number">1</span>;//记录最左侧的下标</span><br><span class="line">	while(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span> - <span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;=<span class="built_in">value</span>)&#123;</span><br><span class="line">			<span class="built_in">index</span> = <span class="built_in">mid</span>;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">index</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> getLessIndex(<span class="built_in">int</span>[] arr)&#123;</span><br><span class="line">	<span class="built_in">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>])&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr[arr.length - <span class="number">2</span>] &gt; arr[arr.length - <span class="number">1</span>])&#123;</span><br><span class="line">		return arr.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	while(<span class="built_in">left</span>&lt;<span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span>-<span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else <span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> + <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4><a id="more"></a>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PrintTreeTest &#123;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">class</span> Node&#123;</span><br><span class="line">        <span class="built_in">int</span> value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="constructor">Node(<span class="params">int</span> <span class="params">v</span>)</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">Tree(Node <span class="params">head</span>)</span>&#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Binary Tree&quot;</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>, 0, <span class="string">&quot;H&quot;</span>, 17)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">InOrder(Node <span class="params">head</span>, <span class="params">int</span> <span class="params">height</span>, String <span class="params">to</span>, <span class="params">int</span> <span class="params">len</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head<span class="operator"> == </span>null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">right</span>, <span class="params">height</span>+1, <span class="string">&quot;v&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        String <span class="keyword">val</span> = <span class="keyword">to</span> + head.value + <span class="keyword">to</span>;</span><br><span class="line">        <span class="built_in">int</span> lenM = <span class="keyword">val</span>.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> lenL = (len - lenM)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        <span class="keyword">val</span> = get<span class="constructor">Space(<span class="params">lenL</span>)</span> + <span class="keyword">val</span> +get<span class="constructor">Space(<span class="params">lenR</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(get<span class="constructor">Space(<span class="params">height</span><span class="operator">*</span><span class="params">len</span>)</span> + <span class="keyword">val</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">left</span>, <span class="params">height</span>+1, <span class="string">&quot;^&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String get<span class="constructor">Space(<span class="params">int</span> <span class="params">num</span>)</span>&#123;</span><br><span class="line">        String space = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        return buf.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="返回二叉树中指定节点的后续节点"><a href="#返回二叉树中指定节点的后续节点" class="headerlink" title="返回二叉树中指定节点的后续节点"></a>返回二叉树中指定节点的后续节点</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">	int</span> value;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">left</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">right</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">parent</span>;</span><br><span class="line">	<span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在中序遍历中的后继节点</span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getSuccessorNode</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node.right!=null)&#123;</span><br><span class="line">		return getLeftMost(node.right);</span><br><span class="line">	&#125;else&#123;//无右子树</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">parent</span> = node.parent;</span><br><span class="line">		while(parent != null &amp;&amp; parent.left != <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">			node</span> = parent;</span><br><span class="line">			parent = node.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getLeftMost</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	&#125;</span></span><br><span class="line"><span class="title">	while</span>(node.left!=null)&#123;</span><br><span class="line">		<span class="keyword">node</span> <span class="title">= node</span>.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="纸对折，依次输出折痕的方向"><a href="#纸对折，依次输出折痕的方向" class="headerlink" title="纸对折，依次输出折痕的方向"></a>纸对折，依次输出折痕的方向</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归过程</span></span><br><span class="line"><span class="comment">//i是节点的层数，N一共的层数，down==true凹 down==false凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(down ? <span class="string">&quot;凹&quot;</span> : <span class="string">&quot;凸&quot;</span>);</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanced</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">			value = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">		<span class="keyword">boolean</span> isBalanced;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">			isBalanced = h;</span><br><span class="line">			<span class="built_in">height</span> = h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">		Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span> = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isBalanced = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Math.<span class="built_in">abs</span>(leftInfo.<span class="built_in">height</span> - rightInfo.<span class="built_in">height</span> &lt;<span class="number">2</span>)	&amp;&amp; leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced)&#123;</span><br><span class="line">			isBalanced = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, <span class="built_in">height</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">process</span>(head).isBalanced;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"><a href="#给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）" class="headerlink" title="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"></a>给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(head).distacne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">		distance = d;</span><br><span class="line">		<span class="built_in">height</span> = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意思考结果的可能性，常见的就是结果与当前节点有关和无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">	Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> heigth = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> distance = Math.<span class="built_in">max</span>(</span><br><span class="line">		Math.<span class="built_in">max</span>(leftInfo.distance, rightInfo.distance), </span><br><span class="line">		leftInfo.<span class="built_in">height</span>+rightInfo.<span class="built_in">height</span>+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(distance, <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点</h4><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> data)&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node getMaxSubBalancedTree(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process(head).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	<span class="built_in">boolean</span> isAllBST;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span>;</span><br><span class="line">	Node head;</span><br><span class="line">	<span class="keyword">public</span> Info(<span class="built_in">boolean</span> is, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span> mi, <span class="built_in">int</span> ma, Node h)&#123;</span><br><span class="line">		isAllBST = is;</span><br><span class="line">		maxSubSize = <span class="built_in">size</span>;</span><br><span class="line">		<span class="built_in">min</span> = mi;</span><br><span class="line">		<span class="built_in">max</span> = ma;</span><br><span class="line">		head = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Info process(Node X)&#123;</span><br><span class="line">	<span class="keyword">if</span>(X==<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = process(X.left);</span><br><span class="line">	Info rightInfo = process(X.right);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span> = X.value;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span> = X.value;</span><br><span class="line">	Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, leftInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, leftInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, rightInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, rightInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可能性1，与x节点无关</span></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = leftInfo.maxSubSize;</span><br><span class="line">		head = leftInfo.head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = Math.<span class="built_in">max</span>(maxSubSize, rightInfo.maxSubSize);</span><br><span class="line">		<span class="keyword">if</span>(maxSubSize&lt;rightInfo.maxSubSize)&#123;</span><br><span class="line">			head = rightInfo.head;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST) &amp;&amp; </span><br><span class="line">		(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST) &amp;&amp;</span><br><span class="line">		(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.<span class="built_in">max</span> &lt; X.value) &amp;&amp;</span><br><span class="line">		(right == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.<span class="built_in">min</span> &gt; X.value))&#123;</span><br><span class="line"></span><br><span class="line">			maxSubSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize) + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">			isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			head = X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubSize, <span class="built_in">min</span>, <span class="built_in">max</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="派对的快乐值"><a href="#派对的快乐值" class="headerlink" title="派对的快乐值"></a>派对的快乐值</h4><pre><code>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。数的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些不来，规则：
1.如果某员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</code></pre>
<hr>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee&#123;</span><br><span class="line">	<span class="built_in">public</span> happy;</span><br><span class="line">	<span class="built_in">public</span> List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> Employee(<span class="type">int</span> h)&#123;</span><br><span class="line">		happy = h;</span><br><span class="line">		nexts = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> maxHappy(Employee boss)&#123;</span><br><span class="line">	<span class="keyword">if</span>(boss == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">Info</span> <span class="keyword">all</span> = process(boss);</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="keyword">all</span>.yes, <span class="keyword">all</span>.<span class="keyword">no</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Info</span>&#123;</span><br><span class="line">	<span class="type">int</span> yes;//x来情况下的最大happy</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span>;//x不来情况下的最大happy</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Info</span>(<span class="type">int</span> y, <span class="type">int</span> n)&#123;</span><br><span class="line">		yes = y;</span><br><span class="line">		<span class="keyword">no</span> = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">Info</span> process(Employee x)&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.nexts.isEmpty)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(x.happy, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> yes = x.happy;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(Employee next : x.nexts)&#123;</span><br><span class="line">		<span class="keyword">Info</span> nextInfo = process(next);</span><br><span class="line">		yes += nextInfo.<span class="keyword">no</span>;</span><br><span class="line">		<span class="keyword">no</span> += Math.max(nextInfo.yes,nextInfo.<span class="keyword">no</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(yes, <span class="keyword">no</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Node1</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(<span class="built_in">int</span> value)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">in</span>(head.left);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">in</span>(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Satck&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			head = stack.pop();</span><br><span class="line">			System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		s1.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">			head = s1.pop();</span><br><span class="line">			s2.push(head);</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.print(s2.pop().value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用一个栈实现非递归的后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos2</span>(<span class="params">Node1 h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h != <span class="literal">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node1 c = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(c.left != <span class="literal">null</span> &amp;&amp; h!=c.left &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.right != <span class="literal">null</span> &amp;&amp; h!=c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(stack.pop()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                h=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历，非递归方法</span></span><br><span class="line"><span class="comment">//1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty() || head!=<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head);</span><br><span class="line">				head = head.left;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				head = stack.pop();</span><br><span class="line">				System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">				head = head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现二叉树的按层遍历</span></span><br><span class="line"><span class="comment"> * 1）其实就是宽度优先遍历，用队列</span></span><br><span class="line"><span class="comment"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWithUseMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	levelMap.<span class="built_in">put</span>(head, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> curLevel = <span class="number">1</span>;<span class="comment">//当前正在统计哪一层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">int</span> curNodeLevel = levelMap.<span class="built_in">get</span>(cur);</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.left, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.right, curLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span></span><br><span class="line">		<span class="keyword">if</span>(curNodeLevel == curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">max</span> = <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，不使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	Node1 curEnd = head;<span class="comment">//当前层，最右节点</span></span><br><span class="line">	Node1 nextEnd = head;<span class="comment">//下一层，最右节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的节点数</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">			nextEnd = cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">			nextEnd = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		<span class="keyword">if</span>(cur == curEnd)&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevelNodes = <span class="number">0</span>;</span><br><span class="line">			curEnd = nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历序列化与重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">preSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">	Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pres</span>(<span class="params">Node head, Queue&lt;<span class="built_in">String</span>&gt; ans</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		ans.add(<span class="literal">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByPreQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prelist == <span class="literal">null</span> || prelist.size()==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">preb</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">String</span> value = prelist.poll();</span><br><span class="line">	<span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">	head.left = preb(prelist);</span><br><span class="line">	head.right = preb(prelist);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">levelSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">    Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        ans.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByLevelQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; levelList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(levelList == <span class="literal">null</span> || levelList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNode(levelList.poll());</span><br><span class="line">        node.right = generateNode(levelList.poll());</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="function"><span class="title">generateNode</span>(<span class="params"><span class="built_in">String</span> val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MergeSort&#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args)&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		sort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> sort(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(start==<span class="keyword">end</span>)<span class="keyword">return</span>;</span><br><span class="line">		//分成两块</span><br><span class="line">		<span class="type">int</span> mid = <span class="keyword">start</span> + (<span class="keyword">end</span> - <span class="keyword">start</span>)/<span class="number">2</span>;</span><br><span class="line">		//左边排序</span><br><span class="line">		sort(arr, <span class="keyword">start</span>, mid);</span><br><span class="line">		//右边排序</span><br><span class="line">		sort(arr, mide + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">		merge(arr, <span class="keyword">start</span>, mid + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)&#123;</span><br><span class="line">		<span class="type">int</span> i = left;</span><br><span class="line">		<span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt;= arr[j])<span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="keyword">temp</span>.length; m++)&#123;</span><br><span class="line">			arr[left+m] = <span class="keyword">temp</span>[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，只有一种数出现了奇数次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> eor = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.<span class="keyword">out</span>.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，有两种数出现了两次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// eor = a^b</span></span><br><span class="line">	<span class="comment">// eor != 0</span></span><br><span class="line">	<span class="comment">// eor必然有一个位置是1</span></span><br><span class="line">	<span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>)&#123;</span><br><span class="line">			onlyOne ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="built_in">println</span>(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有3个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		stack.<span class="keyword">push</span>(cur);</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.value != stack.<span class="keyword">pop</span>().value)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head = head.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//need o(1) extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome2(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 = head;</span><br><span class="line">	NOde n2 = head;</span><br><span class="line">	<span class="keyword">while</span>(n2.<span class="keyword">next</span>!= <span class="keyword">null</span> &amp;&amp; n2.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>;<span class="comment">//n1-&gt;mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>.<span class="keyword">next</span>;<span class="comment">//n2-&gt;end</span></span><br><span class="line">	&#125;</span><br><span class="line">	n2 = n1.<span class="keyword">next</span>;<span class="comment">//n2-&gt;right part first node</span></span><br><span class="line">	n1.<span class="keyword">next</span> = <span class="keyword">null</span>;<span class="comment">//mid.next-&gt;null</span></span><br><span class="line">	Node n3 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n2!=<span class="keyword">null</span>)&#123;<span class="comment">//right part convert</span></span><br><span class="line">		n3 = n2.<span class="keyword">next</span>;<span class="comment">//n3-&gt;save the node</span></span><br><span class="line">		n2.<span class="keyword">next</span> = n1;<span class="comment">//next of right node convert</span></span><br><span class="line">		n1 = n2;<span class="comment">//n1 move</span></span><br><span class="line">		n2 = n3;<span class="comment">//n2 move</span></span><br><span class="line">	&#125;</span><br><span class="line">	n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">	n2 = head; <span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">	<span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2!= <span class="keyword">null</span>)&#123; <span class="comment">// check palindrome</span></span><br><span class="line">		<span class="keyword">if</span>(n1.value != n2.value)&#123;</span><br><span class="line">			res = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>; <span class="comment">// left to mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>; <span class="comment">// right to mid</span></span><br><span class="line">	&#125;</span><br><span class="line">	n1 = n3.<span class="keyword">next</span>;</span><br><span class="line">	n3.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">		n2 = n1.<span class="keyword">next</span>;</span><br><span class="line">		n1.<span class="keyword">next</span> = n3;</span><br><span class="line">		n3 = n1;</span><br><span class="line">		n1 = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node listPartition1(Node head, <span class="built_in">int</span> piovt)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i!=nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] = cur;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i != nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> arrPartition(Node[] nodeArr, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	<span class="built_in">int</span> samll = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">int</span> big = nodeArr.length;</span><br><span class="line">	<span class="built_in">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">index</span>!=big)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,<span class="keyword">index</span>++);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value==piovt)&#123;</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(nodeArr, --big, <span class="keyword">index</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试方法</span></span><br><span class="line"><span class="keyword">public</span> Node listPartition2(Node head, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	Node sH = <span class="literal">null</span>;<span class="comment">//small head</span></span><br><span class="line">	Node sT = <span class="literal">null</span>;<span class="comment">//samll tail</span></span><br><span class="line">	Node eH = <span class="literal">null</span>;<span class="comment">//equal head</span></span><br><span class="line">	Node eT = <span class="literal">null</span>;<span class="comment">//equal tail</span></span><br><span class="line">	Node mH = <span class="literal">null</span>;<span class="comment">//big head</span></span><br><span class="line">	Node MT = <span class="literal">null</span>;<span class="comment">//big tail</span></span><br><span class="line">	Node <span class="keyword">next</span> = <span class="literal">null</span>;<span class="comment">//save the node</span></span><br><span class="line">	<span class="comment">//every node distributed to three lists</span></span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(head.value &lt; pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sH == <span class="literal">null</span>)&#123;</span><br><span class="line">				sH = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				sT.<span class="keyword">next</span> = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(eH == <span class="literal">null</span>)&#123;</span><br><span class="line">				eH = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				eT.<span class="keyword">next</span> = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mH == <span class="literal">null</span>)&#123;</span><br><span class="line">				mH = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				mT.<span class="keyword">next</span> = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head = <span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//小于区域的尾巴，连等于区域的头，等于区域的尾巴</span></span><br><span class="line">	<span class="keyword">if</span>(sT!=<span class="literal">null</span>)&#123;<span class="comment">//如果有小于区域</span></span><br><span class="line">		sT.<span class="keyword">next</span> = eH;</span><br><span class="line">		eT = eT == <span class="literal">null</span> ? sT : eT;<span class="comment">//下一步，谁去连大于区域的头</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的if，不管跑了没有，et</span></span><br><span class="line">	<span class="comment">//all reconnect</span></span><br><span class="line">	<span class="keyword">if</span>(et!=<span class="literal">null</span>)&#123;</span><br><span class="line">		eT.<span class="keyword">next</span> = mH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="一种特殊的单链表节点描述一下"><a href="#一种特殊的单链表节点描述一下" class="headerlink" title="一种特殊的单链表节点描述一下"></a>一种特殊的单链表节点描述一下</h4><pre><code>class Node&#123;
    int value;
    Node next;
    Node rand;
    Node(int val)&#123;
        value = val;
    &#125;
&#125;
rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</code></pre>
<hr>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">//笔试方法，使用HashMap</span></span><br><span class="line">public Node copyListWithRand1(Node head)&#123;</span><br><span class="line">	HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="built_in">null</span>)&#123;</span><br><span class="line">		map.put(cur, new Node(cur.<span class="built_in">value</span>));</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老节点</span></span><br><span class="line">		<span class="comment">//map.get(cur)新节点</span></span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">next</span> = map.<span class="built_in">get</span>(cur.<span class="built_in">next</span>);</span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">rand</span> = map.<span class="built_in">get</span>(<span class="built_in">cut</span>.<span class="built_in">rand</span>);</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp.<span class="built_in">get</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试用的方法</span></span><br><span class="line">public Node copyListWithRand2(Node head)&#123;</span><br><span class="line">	if(head == <span class="built_in">null</span>)&#123;</span><br><span class="line">		return <span class="built_in">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	Node <span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//copy node and link to every node</span></span><br><span class="line">	<span class="comment">//1-&gt;2</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = new Node(cur.<span class="built_in">value</span>);</span><br><span class="line">		cur.<span class="built_in">next</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	Node curCopy = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//set copy node rand</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2-&gt;2&#x27;</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老</span></span><br><span class="line">		<span class="comment">//cur.next 新 copy</span></span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">rand</span> = cur.<span class="built_in">rand</span> != <span class="built_in">null</span> ? cur.<span class="built_in">rand</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node res = head.<span class="built_in">next</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="comment">// split</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">next</span> = <span class="built_in">next</span> != <span class="built_in">null</span> ? <span class="built_in">next</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两个可能有环链表的交点"><a href="#两个可能有环链表的交点" class="headerlink" title="两个可能有环链表的交点"></a>两个可能有环链表的交点</h4><hr>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">head</span> = new <span class="keyword">Node</span><span class="title">(1</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node2</span> = new <span class="keyword">Node</span><span class="title">(2</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node3</span> = new <span class="keyword">Node</span><span class="title">(3</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node4</span> = new <span class="keyword">Node</span><span class="title">(4</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node5</span> = new <span class="keyword">Node</span><span class="title">(5</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node6</span> = new <span class="keyword">Node</span><span class="title">(6</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node7</span> = new <span class="keyword">Node</span><span class="title">(7</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node8</span> = new <span class="keyword">Node</span><span class="title">(8</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node9</span> = new <span class="keyword">Node</span><span class="title">(9</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node10</span> = new <span class="keyword">Node</span><span class="title">(10</span>);</span><br><span class="line"></span><br><span class="line">        head.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        node7.next = node8;</span><br><span class="line">        node8.next = node9;</span><br><span class="line">        node9.next = node10;</span><br><span class="line">        node10.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span> <span class="title">crossNode</span> = getLoopNode(head);</span><br><span class="line">        System.out.println(crossNode.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getIntersection</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || <span class="attr">head2=</span>=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop1</span> = getLoopNode(head1);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop2</span> = getLoopNode(head2);</span><br><span class="line">        if(<span class="attr">loop1=</span>=null &amp;&amp; <span class="attr">loop2=</span>=null)&#123;</span><br><span class="line">            return noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(loop1!=null &amp;&amp; loop2!=null)&#123;</span><br><span class="line">            return  bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一个链表第一个入环的节点</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getLoopNode</span>(<span class="keyword">Node</span> <span class="title">head</span>)&#123;</span><br><span class="line">        if(head ==null || head.next ==null || head.next.next == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // n1 慢 n2 快</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n1</span> = head.next; //n1-&gt;slow</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n2</span> = head.next.next; //n2-&gt;fast</span><br><span class="line">        while(n1 != n2)&#123;</span><br><span class="line">            if(n2.next == null || n2.next.next == null)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head;  //n2-&gt;walk again from head</span><br><span class="line">        while(n1!=n2)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果两个无环链表相交返回第一个相交的节点，如果不相交返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">noLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || head2 == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = head1;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = head2;</span><br><span class="line">        int n = <span class="number">0</span>;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur1 != cur2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //n : 链表<span class="number">1</span>的长度减去链表<span class="number">2</span>的长度</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; //长的变为cur1</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //两个链表都有环，返回第一个相交的节点，不相交则返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">bothLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">loop1</span>, <span class="keyword">Node</span> <span class="title">head2</span>, <span class="keyword">Node</span> <span class="title">loop2</span>)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = null;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = null;</span><br><span class="line">        if(loop1 == loop2)&#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            int n = <span class="number">0</span>;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur2!=loop2)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 :head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur1!=cur2)&#123;</span><br><span class="line">                <span class="attr">cur1=</span> cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                if(cur1 == loop2)&#123;</span><br><span class="line">                    return loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">					arr[j<span class="number">-1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> minPos = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = temp;</span><br><span class="line">			arr[minPos] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的扩容机制和底层源码</title>
    <url>/2021/03/27/HashMap/</url>
    <content><![CDATA[<h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p>
<p>JDK1.8之前HashMap由<strong>数组+链表（1.7）</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</p>
<p>JDK1.8之后HashMap的组成多了红黑树，在满足下面两个条件后，会执行链表转换为红黑树操作，依次来加快搜索速度。</p>
<ul>
<li>链表长度大于阈值（默认为8）</li>
<li>HashMap数组长度超过64<a id="more"></a>

</li>
</ul>
<h4 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h4><h5 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a><strong>JDK1.8之前</strong></h5><p>JDK1.8之前HashMap底层是<strong>数组+链表</strong>结合在一起使用也就是<strong>链表散列</strong>。</p>
<p>HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过**(n-1) &amp; hash**判断当前元素存放的位置（n为数组长度），如果当前位置存在元素的话，就判断该元素与要存入元素的hash值以及key是否相同，如果相同，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK1.8 HashMap的hash方法源码：</strong></p>
<p>JDK1.8的hash方法 相比于JDK１.７方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// key.hashCode():返回散列值也就是hashCode</span></span><br><span class="line">    <span class="comment">// ^:按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key==<span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下JDK１.７的HashMap的hash方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于JDK１.８的hash方法，JDK1.7的hash方法的性能稍微会差一点，因为毕竟扰动了4次。</p>
<p>所谓“拉链法”就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一个就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="D:\blog\imge\jdk1.8之前的内部结构.png"></p>
<h5 id="JDK１-８之后"><a href="#JDK１-８之后" class="headerlink" title="JDK１.８之后"></a>JDK１.８之后</h5><p>相比于之前的版本，JDK１.８以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为８）时，会首先调用　treeifyBIn() 的方法。这个方法会根据HashMap数组来决定是否转换为红黑树。只有当数组长度大于或者等于64的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行resize() 方法对数组扩容。</p>
<p><img src="D:\blog\imge\up-bba283228693dae74e78da1ef7a9a04c684.png"></p>
<p><strong>类的属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loadFactor 加载因子</strong></li>
</ul>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据（entry）也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<ul>
<li><strong>threshold</strong></li>
</ul>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
<p><strong>Node节点源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树节点类源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><p>HashMap中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a><strong>putMapEntries方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h5><p>HashMap只是提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对putVal方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素，就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不同，就判断p是否为一个树节点，如果是就调用 <code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加进入。如果不是就遍历链表插入（插入的是链表尾部）。</li>
</ol>
<p><img src="D:\blog\imge\put方法.png"></p>
<p>说明：上图有两个小问题：</p>
<ul>
<li>直接覆盖之后就会return，不会有后续操作。</li>
<li>当链表长度大于阈值（默认为8）并且HashMap数组长度超过64的时候才会执行链表转化为红黑树的操作，否则就只是对数组的扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下JDK1.7 put代码方法的代码</strong></p>
<p><strong>对比put方法的分析如下：</strong></p>
<ul>
<li>如果定位的数组位置没有元素就直接插入</li>
<li>如果定位的数组位置有元素，遍历这个元素为头节点的链表，依次和插入的key比较，如果相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123;</span><br><span class="line">    	inflateTable(threshold);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>进行扩容，会伴随着一次重新分配hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编程中，要尽量避免resize.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>源码</tag>
        <tag>java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/03/28/Proxy/</url>
    <content><![CDATA[<h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h3><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真是对象（real object ）的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个执行方法前后你可以增加一些自定义的操作。</strong></p>
<h3 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2.静态代理"></a>2.静态代理</h3><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的。实际场景中非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p><strong>上面我们是从实现和应用的角度来说静态代理，从JVM层面来说，静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。</strong></p>
<p>静态代理实现步骤：</p>
<ol>
<li>定义一个接口机器实现类；</li>
<li>创建一个代理类同样实现这个接口；</li>
<li>将目标对象注入代理类，然后再代理类的对应方法调用目标类的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以再目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类（CGLIB动态代理机制）。</p>
<p><strong>从JVM角度来说，动态代理是在运行时动态生成类字节码，并加载到JVM中。</strong></p>
<p>说到动态代理，Spring AOP、RPC框架应该是不得不提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理再我们日常开发总使用的相对较少，但是再框架中几乎是是比用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常用帮助。</strong></p>
<p>就Java来时，动态代理的实现方式有很多种，比如JDK动态代理、CGLIB动态代理等等。</p>
<h4 id="3-1-JDK动态代理机制"><a href="#3-1-JDK动态代理机制" class="headerlink" title="3.1.JDK动态代理机制"></a>3.1.JDK动态代理机制</h4><h5 id="3-1-1介绍"><a href="#3-1-1介绍" class="headerlink" title="3.1.1介绍"></a>3.1.1介绍</h5><p><strong>在Java动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p>Proxy类中使用频率最高的方法是： <code>newProxyInstance()</code>，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有三个参数：</p>
<ol>
<li>loader:类加载器，用于加载代理对象。</li>
<li>interfaces:被代理类实现的一些接口。</li>
<li>h : 实现了 <code>InvocationHandler</code> 接口的对象。</li>
</ol>
<p>要实现动态代理的话，还必须要实现 <code>InvocationHandler</code>来自定义处理逻辑。当我们的动态代理对象调用一个方法的时候，这个方法的调用就会被转发到实现 <code>InvocationHandler</code>接口类的 <code>invoke</code>方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h5 id="3-1-2-JDK动态代理类使用步骤"><a href="#3-1-2-JDK动态代理类使用步骤" class="headerlink" title="3.1.2.JDK动态代理类使用步骤"></a>3.1.2.JDK动态代理类使用步骤</h5><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义<code>InnvocationHandler</code>并重写 <code>invoke()</code>方法，在 <code>invoke()</code>方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象。</li>
</ol>
<h5 id="3-1-3-代码示例"><a href="#3-1-3-代码示例" class="headerlink" title="3.1.3.代码示例"></a>3.1.3.代码示例</h5><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个JDK动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-CGLIB动态代理机制"><a href="#3-2-CGLIB动态代理机制" class="headerlink" title="3.2.CGLIB动态代理机制"></a>3.2.CGLIB动态代理机制</h4><h5 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1.介绍"></a>3.2.1.介绍</h5><p><strong>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用CGLIB动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>methodProxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h5 id="3-2-2-CGLIB动态代理类使用步骤"><a href="#3-2-2-CGLIB动态代理类使用步骤" class="headerlink" title="3.2.2.CGLIB动态代理类使用步骤"></a>3.2.2.CGLIB动态代理类使用步骤</h5><ol>
<li>自定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h5 id="3-2-3-代码示例"><a href="#3-2-3-代码示例" class="headerlink" title="3.2.3.代码示例"></a>3.2.3.代码示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-JDK动态代理和CGLIB动态代理对比"><a href="#3-3-JDK动态代理和CGLIB动态代理对比" class="headerlink" title="3.3.JDK动态代理和CGLIB动态代理对比"></a>3.3.JDK动态代理和CGLIB动态代理对比</h4><ol>
<li><strong>JDK动态代理只能实现奈雪儿实现了接口的类或者直至代理接口，而CGLIB可以代理未实现任何接口的类。</strong>另外，CGLIB动态代理是通过一个被代理类的子拦截器来拦截被代理类的方法调用，因此不能代理生声明为final类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="４-静态代理和动态代理的对比"><a href="#４-静态代理和动态代理的对比" class="headerlink" title="４.静态代理和动态代理的对比"></a>４.静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
      <categories>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>静态代理</tag>
        <tag>jdk动态代理</tag>
        <tag>cglib动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList源码</title>
    <url>/2021/03/28/LinkedList/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>LinkedList是一个实现了List接口和Deque接口的双端链表。LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用Collections中的synchronizedList方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure>

<h4 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a>内部结构分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//节点值</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>add(E e)方法：将元素添加到链表尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkLast(e);<span class="comment">//这里就只调用了这一个方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     last = newNode;<span class="comment">//新建节点</span></span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;<span class="comment">//指向后继元素也就是指向下一个元素</span></span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**add(int index,E e)**：在指定位置添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       checkPositionIndex(index); <span class="comment">//检查索引是否处于[0-size]之间</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (index == size)<span class="comment">//添加在链表尾部</span></span><br><span class="line">           linkLast(element);</span><br><span class="line">       <span class="keyword">else</span><span class="comment">//添加在链表中间</span></span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>linkBefore</code>方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了<code>Node(index)</code>去找到index对应的node</p>
<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1:检查index范围是否在size之内</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">           succ = <span class="keyword">null</span>;</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           succ = node(index);</span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">           <span class="comment">//创建新节点</span></span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       size += numNew;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面可以看出addAll方法通常包括下面四个步骤：</p>
<ol>
<li>检查index范围是否在size之内</li>
<li>toArray()方法把集合的数据存到对象数组中</li>
<li>得到插入位置的前驱和后继节点</li>
<li>遍历数据，将数据插入到指定位置</li>
</ol>
<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      linkFirst(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建节点，以头节点为后继节点</span></span><br><span class="line">       first = newNode;</span><br><span class="line">       <span class="comment">//如果链表为空，last节点也指向该节点</span></span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           last = newNode;</span><br><span class="line">       <span class="comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h5><p><strong>get(int index)：</strong> 根据指定索引返回数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">       <span class="keyword">return</span> node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>获取头节点（index=0）数据方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> f.item;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong> getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>
<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">      <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      <span class="keyword">return</span> l.item;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">      <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>两者区别：</strong> <strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>
<h5 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a>根据对象得到索引的方法</h5><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从头遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从头遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = size;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从尾遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从尾遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">               index--;</span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="检查链表是否包含某对象的方法"><a href="#检查链表是否包含某对象的方法" class="headerlink" title="检查链表是否包含某对象的方法"></a>检查链表是否包含某对象的方法</h5><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>removeLast(),pollLast():</strong> 删除尾节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>
<p><strong>remove(Object o):</strong> 删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果删除对象为null</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从头开始遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="comment">//找到元素</span></span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从头开始遍历</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="comment">//找到元素</span></span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                   <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<p>**remove(int index)**：删除指定位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index范围</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//将节点删除</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a>LinkedList类常用方法测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存放int类型的linkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/************************** linkedList的基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>); <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>); <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>); <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList（直接输出的）: &quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;getFirst()获得第一个元素: &quot;</span> + linkedList.getFirst()); <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;getLast()获得第最后一个元素: &quot;</span> + linkedList.getLast()); <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;removeFirst()删除第一个元素并返回: &quot;</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;removeLast()删除最后一个元素并返回: &quot;</span> + linkedList.removeLast()); <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After remove:&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;contains()方法判断列表是否包含1这个元素:&quot;</span> + linkedList.contains(<span class="number">1</span>)); <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;该linkedList的大小 : &quot;</span> + linkedList.size()); <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After set(1, 3):&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;get(1)获得指定位置（这里为1）的元素: &quot;</span> + linkedList.get(<span class="number">1</span>)); <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Search操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;indexOf(3): &quot;</span> + linkedList.indexOf(<span class="number">3</span>)); <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">&quot;lastIndexOf(3): &quot;</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Queue操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;peek(): &quot;</span> + linkedList.peek()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">&quot;element(): &quot;</span> + linkedList.element()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll(); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After poll():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;After remove():&quot;</span> + linkedList); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After offer(4):&quot;</span> + linkedList); <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Deque操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>); <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After offerFirst(2):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>); <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After offerLast(5):&quot;</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">&quot;peekFirst(): &quot;</span> + linkedList.peekFirst()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;peekLast(): &quot;</span> + linkedList.peekLast()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst(); <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pollFirst():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.pollLast(); <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pollLast():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>); <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After push(2):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.pop(); <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After pop():&quot;</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After removeFirstOccurrence(3):&quot;</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After removeFirstOccurrence(3):&quot;</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 遍历操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Iterator：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;for：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;for2：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;pollFirst()或pollLast()：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;removeFirst()或removeLast()：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>java容器</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList的扩容机制和底层源码</title>
    <url>/2021/03/28/ArrayList/</url>
    <content><![CDATA[<h3 id="1-ArrayList简介"><a href="#1-ArrayList简介" class="headerlink" title="1.ArrayList简介"></a>1.ArrayList简介</h3><p>ArrayList 的底层是数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。在添加大量元素前，应用成勋可以使用ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p>
<p>ArrayList 继承于 AbstractList , 实现了List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RandomAccess 是一个标志接口，表明实现这个接口的List集合是支持快速访问的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone（），能被克隆。</li>
<li>ArrayList 实现了 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>
</ul>
<h4 id="1-1-ArrayList-和-Vector-的区别？"><a href="#1-1-ArrayList-和-Vector-的区别？" class="headerlink" title="1.1.ArrayList 和 Vector 的区别？"></a>1.1.ArrayList 和 Vector 的区别？</h4><ol>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全。</li>
<li><code>Vector </code>是 <code>List</code> 的古老实现类，底层使用 Object[] 存储，线程安全。</li>
</ol>
<h4 id="1-2-ArrayList-和-LinkedList-的区别？"><a href="#1-2-ArrayList-和-LinkedList-的区别？" class="headerlink" title="1.2.ArrayList 和 LinkedList 的区别？"></a>1.2.ArrayList 和 LinkedList 的区别？</h4><ol>
<li><strong>是否保证线程安全</strong>：<code>ArrayList </code>和<code> LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>：<code>ArrayList </code>底层使用的是Object[] 数组；<code>LinkedList</code> 底层采用的是双向链表；</li>
<li><strong>插入和删除是否受到元素位置的影响</strong>：① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问</strong>：<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h3 id="2-ArrayList核心源码解读"><a href="#2-ArrayList核心源码解读" class="headerlink" title="2.ArrayList核心源码解读"></a>2.ArrayList核心源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-ArrayList-扩容机制分析"><a href="#3-ArrayList-扩容机制分析" class="headerlink" title="3.ArrayList 扩容机制分析"></a>3.ArrayList 扩容机制分析</h3><h4 id="3-1-先从ArrayList的构造函数说起"><a href="#3-1-先从ArrayList的构造函数说起" class="headerlink" title="3.1.先从ArrayList的构造函数说起"></a>3.1.先从ArrayList的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>细心的同学一定会发现：以午餐构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。下面我们在分析ArrayList扩容时，会讲到这一点内容！</p>
<p>补充：JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建<strong>类似于单例的饿汉式</strong>，而jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</p>
<h4 id="3-2-一步一步分析ArrayList扩容机制"><a href="#3-2-一步一步分析ArrayList扩容机制" class="headerlink" title="3.2.一步一步分析ArrayList扩容机制"></a>3.2.一步一步分析ArrayList扩容机制</h4><p>这里以无参构造函数创建的ArrayList为例分析</p>
<h5 id="3-2-1add-方法"><a href="#3-2-1add-方法" class="headerlink" title="3.2.1add()方法"></a>3.2.1add()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
<h5 id="3-2-2-ensureCapacityInternal-方法"><a href="#3-2-2-ensureCapacityInternal-方法" class="headerlink" title="3.2.2.ensureCapacityInternal() 方法"></a>3.2.2.ensureCapacityInternal() 方法</h5><p>（JDK7）可以看到add方法首先调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当要 add 第一个元素的时候，minCapacity 为1，在Math.max之后，minCapacity为10。</strong></p>
<h5 id="3-2-3-ensureExplicitCapacity-方法"><a href="#3-2-3-ensureExplicitCapacity-方法" class="headerlink" title="3.2.3.ensureExplicitCapacity() 方法"></a>3.2.3.ensureExplicitCapacity() 方法</h5><p>如果调用 ensureCapacityInternal() 方法就一定会（执行）这个方法，下面我们来研究这个方法的源码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 <code>add</code> 进第一个元素时，<code>elementData.length</code> 为0（因为此时还是一个空的list），因为执行了 <code>ensureCapacityInternal() </code>方法，所以此时<code>minCapacity</code> 为10。此时，<code>minCapacity - elementData.length&gt;0</code>成立，所以会进入 <code>grow(minCapacity) </code>方法。</li>
<li>当 add 第2个元素时，<code>minCapacity</code> 为2， 此时<code>elementData.length</code>在添加第一个元素后扩容为10，此时，<code>minCapacity - elementData.length&gt;0</code>不成立，所以不会进入 <code>grow(minCapacity) </code>方法。</li>
<li>添加第3、4、、、、10个元素时，依然不会执行 <code>grow</code> 方法，数组容量为10。</li>
<li>直到添加第11个元素，<code>minCapacity</code>(为11)比<code>elementData.length</code>(为10)要大。进入grow方法扩容。</li>
</ul>
<h5 id="3-2-4-grow-方法"><a href="#3-2-4-grow-方法" class="headerlink" title="3.2.4 grow() 方法"></a>3.2.4 grow() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以ArrayList每次扩容之后都会变为原来的1.5倍左右（oldCapacity为偶数就是1.5倍，否则就是1.5倍左右）。</p>
<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h5 id="3-2-5-hugeCapacity-方法"><a href="#3-2-5-hugeCapacity-方法" class="headerlink" title="3.2.5.hugeCapacity()方法"></a>3.2.5.hugeCapacity()方法</h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-System-arrayCopy-和Arrays-copyOf-方法"><a href="#3-3-System-arrayCopy-和Arrays-copyOf-方法" class="headerlink" title="3.3.System.arrayCopy()和Arrays.copyOf()方法"></a>3.3.System.arrayCopy()和Arrays.copyOf()方法</h4><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h5 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1.System.arraycopy() 方法"></a>3.3.1.System.arraycopy() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们写一个简单的方法测试以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2.Arrays.copyOf()方法"></a>3.3.2.Arrays.copyOf()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-两者的联系和区别"><a href="#3-3-3-两者的联系和区别" class="headerlink" title="3.3.3.两者的联系和区别"></a>3.3.3.两者的联系和区别</h5><p><strong>联系</strong>：</p>
<p>看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法</p>
<p><strong>区别</strong>：</p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>
<h4 id="3-4-ensureCapacity方法"><a href="#3-4-ensureCapacity方法" class="headerlink" title="3.4.ensureCapacity方法"></a>3.4.ensureCapacity方法</h4><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="line"> *</span><br><span class="line"> * @param   <span class="keyword">min</span>Capacity   所需的最小容量</span><br><span class="line"> */</span><br><span class="line">public void ensureCapacity(int <span class="keyword">min</span>Capacity) &#123;</span><br><span class="line">    int <span class="keyword">min</span>Expand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        // <span class="literal">any</span> size if not <span class="keyword">default</span> element <span class="built_in">table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        // larger than <span class="keyword">default</span> <span class="keyword">for</span> <span class="keyword">default</span> empty <span class="built_in">table</span>. It&#x27;s already</span><br><span class="line">        // supposed <span class="keyword">to</span> be at <span class="keyword">default</span> size.</span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    if (<span class="keyword">min</span>Capacity &gt; <span class="keyword">min</span>Expand) &#123;</span><br><span class="line">        ensureExplicitCapacity(<span class="keyword">min</span>Capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
]]></content>
      <categories>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>java容器</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
</search>
