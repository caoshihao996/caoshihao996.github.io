<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BubbleSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">				if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j+1];</span><br><span class="line">					arr[j+1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;1,4,7,8,3,6,9&#125;;</span><br><span class="line">		sort(arr, 0, arr.length-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(int[] arr, int start, int end)&#123;</span><br><span class="line">		if(start&#x3D;&#x3D;end)return;</span><br><span class="line">		&#x2F;&#x2F;分成两块</span><br><span class="line">		int mid &#x3D; start + (end - start)&#x2F;2;</span><br><span class="line">		&#x2F;&#x2F;左边排序</span><br><span class="line">		sort(arr, start, mid);</span><br><span class="line">		&#x2F;&#x2F;右边排序</span><br><span class="line">		sort(arr, mide + 1, end);</span><br><span class="line"></span><br><span class="line">		merge(arr, start, mid + 1, end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void merge(int[] arr, int left, int mid, int right)&#123;</span><br><span class="line">		int i &#x3D; left;</span><br><span class="line">		int j &#x3D; mid + 1;</span><br><span class="line">		int k &#x3D; 0;</span><br><span class="line">		int[] temp &#x3D; new int[right - left + 1];</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">			if(arr[j] &lt;&#x3D; arr[j])temp[k++] &#x3D; arr[i++];</span><br><span class="line">			else temp[k++] &#x3D; arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid) temp[k++] &#x3D; arr[i++];</span><br><span class="line">		while(j&lt;&#x3D;right) temp[k++] &#x3D; arr[j++];</span><br><span class="line"></span><br><span class="line">		for(int m&#x3D;0; m&lt;temp.length; m++)&#123;</span><br><span class="line">			arr[left+m] &#x3D; temp[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; arr[j];</span><br><span class="line">		arr[j] &#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InsertSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;i;j&gt;0;j--)&#123;</span><br><span class="line">				if(arr[j]&lt;arr[j-1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j-1];</span><br><span class="line">					arr[j-1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShellSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;3,2,4,1,8,5,6&#125;;</span><br><span class="line"></span><br><span class="line">		int h &#x3D; 1;</span><br><span class="line">		while(h&lt;&#x3D;arr.length&#x2F;3)&#123;</span><br><span class="line">			h&#x3D;h*3+1;</span><br><span class="line">		&#125;&#x2F;&#x2F;初始化gap的方法</span><br><span class="line"></span><br><span class="line">		for(int gap&#x3D;h;gap&gt;0;gap&#x3D;(gap-1)&#x2F;3)&#123;</span><br><span class="line">			for(int i&#x3D;gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				for(int j&#x3D;i;j&gt;gap-1;j-&#x3D;gap)&#123;</span><br><span class="line">					if(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		arr[i] &#x3D; arr[j] + arr[i];</span><br><span class="line">		arr[j] &#x3D; arr[i] - arr[j];</span><br><span class="line">		arr[i] &#x3D; arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SelectionSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int arr[] &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for(int i &#x3D; 0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">			int minPos &#x3D; i;</span><br><span class="line"></span><br><span class="line">			for(int j&#x3D;i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos &#x3D; arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; temp;</span><br><span class="line">			arr[minPos] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
