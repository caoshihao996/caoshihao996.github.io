<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CardInLine</title>
    <url>/2020/12/27/CardInLine/</url>
    <content><![CDATA[<h4 id="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"><a href="#玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值" class="headerlink" title="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"></a>玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值</h4><pre><code>给定一个整形数组arr，代表数值不同的纸牌拍成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都决定聪明。请问最后获胜者的分数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先手函数</span><br><span class="line">public int f(int[] arr, int L, int R)&#123;</span><br><span class="line">	if( L&#x3D;&#x3D;R )&#123;</span><br><span class="line">		return arr[L];</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(arr[L] + s(arr, L+1, R), arr[R] + s(arr, L, R-1));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;后手函数</span><br><span class="line">public int s(int[] arr, int L, int R)&#123;</span><br><span class="line">	if(L &#x3D;&#x3D; R)&#123;</span><br><span class="line">		return arr[L];</span><br><span class="line">	&#125;			&#x2F;&#x2F;先手函数选了arr[L]</span><br><span class="line">	return Math.min(f(arr, L+1, R), f(arr, L, R-1));&#x2F;&#x2F;对手会让你选择最小的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int maxValue(int[] arr)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(f(arr, 0, arr.length-1), s(arr, 0, arr.length-1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态规划</span><br><span class="line">public int dpWay(int[] arr)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D;null || arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int N &#x3D; arr.length;</span><br><span class="line">	int[][] f &#x3D; new int[N][N];</span><br><span class="line">	int[][] s &#x3D; new int[N][N];</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 0; i&lt; N; i++)&#123;</span><br><span class="line">		f[i][i] &#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;s[i][i]&#x3D;0</span><br><span class="line">	for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">		int L &#x3D; 0;</span><br><span class="line">		int R &#x3D; i;</span><br><span class="line">		while(L&lt;N &amp;&amp; R&lt;N)&#123;</span><br><span class="line">			f[L][R] &#x3D; Math.max(arr[L]+s[L+1][R], arr[R]+s[L][R-1]);</span><br><span class="line">			s[L][R] &#x3D; Math.min(arr[L]+f[L+1][R], arr[R]+f[L][R-1]);</span><br><span class="line">			L++;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(f[0][N-1], s[0][N-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CoinsWay</title>
    <url>/2020/12/28/CoinWays/</url>
    <content><![CDATA[<h4 id="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"><a href="#使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张" class="headerlink" title="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"></a>使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张</h4><pre><code>从左到右的模型，依次判断index位置上的纸币用几张，当index到达length时，如果rest==0，则该方法有效返回1，否则返回0.在由暴力递归改成动态规划时，要考虑枚举问题。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int ways1(int[] arr, int aim)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0 || aim &lt; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return process1(arr, 0, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回值：0~index-1位置上的货币使用已经确定，从index之后的货币使用方法数</span><br><span class="line">public int process1(int[] arr, int index, int rest)&#123;</span><br><span class="line">	if(rest &lt; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(index &#x3D;&#x3D; arr.length)&#123;</span><br><span class="line">		return rest &#x3D;&#x3D; 0 ? 1 : 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int p1 &#x3D; process1(arr, index+1, rest);&#x2F;&#x2F;不选用index位置上的货币</span><br><span class="line">	int p2 &#x3D; 0;</span><br><span class="line">	for(int zhang&#x3D;1; zhang*arr[index] &lt;&#x3D; rest; zhang++)&#123;</span><br><span class="line">		p2 +&#x3D; process1(arr, index+1, rest - zhang*arr[index]);&#x2F;&#x2F;选用index位置上的货币，至少一张</span><br><span class="line">	&#125;</span><br><span class="line">	return p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态规划的方法，每个格子有枚举行为，细粒度划分</span><br><span class="line">public int dpWays(int[] arr, int aim)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0 || aim &lt; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int N &#x3D; arr.length;</span><br><span class="line">	int dp[][] &#x3D; new int[N+1][aim+1];</span><br><span class="line">	dp[N][0] &#x3D; 1;&#x2F;&#x2F;d[N][...] &#x3D; 0</span><br><span class="line">	for(int index &#x3D; N - 1; index&gt;&#x3D;0; index--)&#123;</span><br><span class="line">		for(int rest&#x3D;0; rest&lt;&#x3D;aim; rest++)&#123;</span><br><span class="line">			int ways &#x3D; 0;</span><br><span class="line">			for(int zhang&#x3D;0; zhang*arr[index]&lt;&#x3D;rest; zhang++)&#123;</span><br><span class="line">				ways +&#x3D; dp[index+1][rest-zhang*arr[index]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[index][rest] &#x3D; ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[0][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态规划方法，省去枚举行为</span><br><span class="line">public int dpWays(int[] arr, int aim)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0 || aim &lt; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int N &#x3D; arr.length;</span><br><span class="line">	int dp[][] &#x3D; new int[N+1][aim+1];</span><br><span class="line">	dp[N][0] &#x3D; 1;&#x2F;&#x2F;d[N][...] &#x3D; 0</span><br><span class="line">	for(int index &#x3D; N - 1; index&gt;&#x3D;0; index--)&#123;</span><br><span class="line">		for(int rest&#x3D;0; rest&lt;&#x3D;aim; rest++)&#123;</span><br><span class="line">			dp[index][rest] &#x3D; dp[index+1][rest];&#x2F;&#x2F;没有使用cur位置上的</span><br><span class="line">			if(rest - arr[index] &gt; 0)&#123;</span><br><span class="line">				dp[index][rest] +&#x3D; dp[index][rest-arr[index]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[0][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2020/12/27/Knapsack/</url>
    <content><![CDATA[<h4 id="背包问题，从左往右的尝试模型"><a href="#背包问题，从左往右的尝试模型" class="headerlink" title="背包问题，从左往右的尝试模型"></a>背包问题，从左往右的尝试模型</h4><pre><code>给定两个长度都为N的数组weights和values，weight[i]和values[i]分别代表物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;不变：w[] v[] bag</span><br><span class="line">&#x2F;&#x2F;index... 最大价值</span><br><span class="line">&#x2F;&#x2F;0...index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span><br><span class="line">&#x2F;&#x2F;如果返回-1则认为没有方法，如果不返回-1，则认为返回的值是真实值</span><br><span class="line">&#x2F;&#x2F;函数返回值为index之后的最大价值</span><br><span class="line">public int process(int[] w, int[] v, int index, int alreadyW, int bag)&#123;</span><br><span class="line">	if(alreadyW&gt;bag)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(index &#x3D;&#x3D; w.length)&#123;</span><br><span class="line">		return 0;&#x2F;&#x2F;index到达length时，剩余货物的最大价值为0</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int p1 &#x3D; process(w, v, index+1, alreadyW, bag);&#x2F;&#x2F;不选择index位置上的货物</span><br><span class="line"></span><br><span class="line">	int p2Next &#x3D; process(w, v, index+1, alreadyW+w[index], bag);&#x2F;&#x2F;yes</span><br><span class="line">	int p2 &#x3D; -1;</span><br><span class="line">	if(p2Next !&#x3D; -1)&#123;</span><br><span class="line">		p2 &#x3D; v[index] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int process1(int[] w, int[] v, int index, int rest)&#123;</span><br><span class="line">	if(rest&lt;0)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(index &#x3D;&#x3D; w.length)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int p1 &#x3D; process(w, v, index+1, rest);&#x2F;&#x2F;不选择index位置上的货物</span><br><span class="line"></span><br><span class="line">	int p2Next &#x3D; process(w, v, index+1, rest-w[index]);</span><br><span class="line">	int p2 &#x3D; -1;</span><br><span class="line">	if(p2Next !&#x3D; -1)&#123;</span><br><span class="line">		p2 &#x3D; v[index] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	return Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态规划</span><br><span class="line">public int dpWay(int[] w, int[] v, int bag)&#123;</span><br><span class="line">	int N &#x3D; w.length;</span><br><span class="line">	int[][] dp &#x3D; new int[N+1][bag+1];&#x2F;&#x2F;dp[N][...]&#x3D;0</span><br><span class="line">	for(int index&#x3D;N-1;index&gt;&#x3D;0;index--)&#123;</span><br><span class="line">		for(int rest &#x3D; 0; rest &lt;&#x3D; bag; rest++)&#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;dp[index][rest]&#x3D;?</span><br><span class="line">			int p1 &#x3D; dp[index+1][rest];</span><br><span class="line"></span><br><span class="line">			int p2 &#x3D; -1;</span><br><span class="line">			if(rest - w[index] &gt;&#x3D; 0)&#123;</span><br><span class="line">				p2 &#x3D; v[index] + dp[index+1][rest - w[index]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[index][rest] &#x3D; Math.max(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[0][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] countSort(int[] arr)&#123;</span><br><span class="line">	&#x2F;&#x2F;找出数组中最大值和最小值</span><br><span class="line">	int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">	int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">	for(int num:arr)&#123;</span><br><span class="line">		max &#x3D; Math.max(max, num);</span><br><span class="line">		min &#x3D; Math.min(min, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化计数数组count[]</span><br><span class="line">	&#x2F;&#x2F;长度为最大值减去最小值加1，再加1</span><br><span class="line">	int[] count &#x3D; new int[max-min+1+1];</span><br><span class="line">	&#x2F;&#x2F;计数，并确保count[0]永远为0</span><br><span class="line">	for(int num:arr)&#123;</span><br><span class="line">		count[num-min+1]++;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;计数数组变形，新元素是的值是前面元素的累加之和的值</span><br><span class="line">	for(int i&#x3D;1;i&lt;count.length;i++)&#123;</span><br><span class="line">		count[i] +&#x3D; count[i-1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建结果数组</span><br><span class="line">	int[] result &#x3D; new int[arr.length];</span><br><span class="line">	&#x2F;&#x2F;遍历arr中的元素，填充到结果数组中去，从前往后遍历</span><br><span class="line">	for(int j&#x3D;0;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[count[arr[j]-min]] &#x3D; arr[j];</span><br><span class="line">		count[arr[j]-min]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ConvertToLetters</title>
    <url>/2020/12/27/ConvertToLetters/</url>
    <content><![CDATA[<h4 id="将数字转化为字母有多少种方法，从左往右的尝试模型"><a href="#将数字转化为字母有多少种方法，从左往右的尝试模型" class="headerlink" title="将数字转化为字母有多少种方法，从左往右的尝试模型"></a>将数字转化为字母有多少种方法，从左往右的尝试模型</h4><pre><code>规定1和A对应、2和B对应、3和C对应...的规则。那么一个数字字符串比如“111”就可以转化为AAA、KA、AK。给定一个只有数字字符串组成的字符串str,返回有多少种转化结果。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int numbers(String str)&#123;</span><br><span class="line">	if(str &#x3D;&#x3D; null || str.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return process1(str.toCharArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;str[0..i-1]已经转化完了，固定了</span><br><span class="line">&#x2F;&#x2F;返回值：从i开始到结尾有多少种转化方法</span><br><span class="line">public int process1(char[] str, int i)&#123;</span><br><span class="line">	if(i &#x3D;&#x3D; str.length)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(str[i] &#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(str[i] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">		int res &#x3D; process(str, i+1);&#x2F;&#x2F;i位置上字符视为一个单独的转换数字</span><br><span class="line">		if(i+1&lt;str.length)&#123;</span><br><span class="line">			rest +&#x3D; process(str, i+2);&#x2F;&#x2F;(i,i+1)两个位置上的字符视为一个整体</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">	if(str[i] &#x3D;&#x3D; &#39;2&#39;)&#123;</span><br><span class="line">		int res &#x3D; process1(str, i+1);&#x2F;&#x2F;i位置上字符视为一个单独的转换数字</span><br><span class="line">		if(i+1&lt;str.length &amp;&amp; str[i] &lt;&#x3D; &#39;6&#39; &amp;&amp; str[i] &gt;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">			rest +&#x3D; process(str, i+2);&#x2F;&#x2F;(i,i+1)两个位置上的字符视为一个整体</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;str[i] &#x3D;&#x3D; &#39;3&#39;~&#39;9&#39;;</span><br><span class="line">	return process(str, i+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态规划</span><br><span class="line">public int dpWays(String s)&#123;</span><br><span class="line">	if(s &#x3D;&#x3D; null || s.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	char[] str &#x3D; s.toCharArray();</span><br><span class="line">	int N &#x3D; str.length;</span><br><span class="line">	int[] dp &#x3D; new int[N+1];</span><br><span class="line">	dp[N] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; N-1; i&gt;&#x3D;0; i--)&#123;</span><br><span class="line">		if(str[i] &#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">			dp[i] &#x3D; 0;</span><br><span class="line">		&#125;else if(str[i] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">			dp[i] &#x3D; dp[i+1];</span><br><span class="line">			if(i+1&lt;str.length)&#123;</span><br><span class="line">				dp[i] +&#x3D; dp[i+2]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(str[i] &#x3D;&#x3D; &#39;2&#39;)&#123;</span><br><span class="line">			dp[i] &#x3D; dp[i+1];</span><br><span class="line">			if(i+1&lt;str.length &amp;&amp; str[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;6&#39;)&#123;</span><br><span class="line">				dp[i] +&#x3D; dp[i+2];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			dp[i] &#x3D; dp[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>NQueens</title>
    <url>/2020/12/27/NQueens/</url>
    <content><![CDATA[<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><pre><code>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n，返回n种皇后的摆法有多少种。
n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int nums(int n)&#123;</span><br><span class="line">	if(n&lt;0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int[] record &#x3D; new int[n];&#x2F;&#x2F;record[i]-&gt;i行的皇后，放在了第几列</span><br><span class="line">	return process(0, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;潜台词：record[0...i-1]的皇后，任何两个皇后都不共行、不共列、不共斜线</span><br><span class="line">&#x2F;&#x2F;目前来到了第i行</span><br><span class="line">&#x2F;&#x2F;record[0..i-1]表示之前的行，放了皇后的列的序号</span><br><span class="line">&#x2F;&#x2F;返回值，接着把i...之后摆完，有多少种摆法</span><br><span class="line">public int process(int i, int[] record, int n)&#123;</span><br><span class="line">	if(i&#x3D;&#x3D;n)&#123;</span><br><span class="line">		return 1;&#x2F;&#x2F;i来到证明前面的摆法有效，返回1</span><br><span class="line">	&#125;</span><br><span class="line">	int res &#x3D; 0;</span><br><span class="line">	for(int j&#x3D;0;j&lt;n;j++)&#123;&#x2F;&#x2F;依次尝试i行的皇后摆放在什么位置</span><br><span class="line">		if(isValid(record, i, j))&#123;</span><br><span class="line">			record[i] &#x3D; j;</span><br><span class="line">			res +&#x3D; process(i+1, record, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isValid(int[] record, int i, int j)&#123;</span><br><span class="line">	for(int k&#x3D;0; k&lt;i; k++)&#123;</span><br><span class="line">		if(record[k] &#x3D;&#x3D;j || Math.abs(k-i) &#x3D;&#x3D; Math.abs(recod[k]-j))&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用位运算计算不超过32皇后的问题</span><br><span class="line">public int num2(int n)&#123;</span><br><span class="line">	if(n&lt;1 || n&lt;32)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果你是9皇后问题，limit最右9个是1，其他都是0</span><br><span class="line">	int limit &#x3D; n &#x3D;&#x3D; 32 ? -1 : (1&lt;&lt;n) -1;</span><br><span class="line">	return process2(limit, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;limit 划定了问题的规模，是固定的</span><br><span class="line">&#x2F;&#x2F;colLim 列的限制，1的位置不能放皇后，0的位置可以</span><br><span class="line">&#x2F;&#x2F;leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span><br><span class="line">&#x2F;&#x2F;rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span><br><span class="line">public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim)&#123;</span><br><span class="line">    if(colLim &#x3D;&#x3D; limit)&#123;&#x2F;&#x2F;base case</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;所有候选皇后的位置，都在pos上</span><br><span class="line">    &#x2F;&#x2F;colLim | leftDiaLim | rightDigLim -&gt; 总限制</span><br><span class="line">    &#x2F;&#x2F;~(colLim | leftDiaLim | rightDigLim) -&gt; 左侧的一坨0干扰，右侧每个1可尝试</span><br><span class="line">    &#x2F;&#x2F;所有可以放皇后都在pos上</span><br><span class="line">    int pos &#x3D; limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    int mostRightOne &#x3D; 0;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    while(pos !&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;提取中pos最右侧的1，剩下位置都是0</span><br><span class="line">        mostRightOne &#x3D; pos &amp; (~pos + 1);</span><br><span class="line">        pos &#x3D; pos - mostRightOne;</span><br><span class="line">        res +&#x3D; process2(limit, colLim | mostRightOne, (leftDiaLim|mostRightOne)&lt;&lt;1,</span><br><span class="line">                (rightDiaLim|mostRightOne)&gt;&gt;&gt;1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>printAllSubSquence</title>
    <url>/2020/12/27/PrintAllSubsquences/</url>
    <content><![CDATA[<h4 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h4><hr>
<pre><code>从左往右的尝试模型，从0位置出发，依次判断每个位置的字符是否选择，当index到达字符串末尾时，将所形成的字符path加入结果的集合中。</code></pre>
<hr>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;String&gt; subs(String s)&#123;</span><br><span class="line">	char[] str &#x3D; s.toCharArray();</span><br><span class="line">	String path &#x3D; &quot;&quot;;</span><br><span class="line">	List&lt;String&gt; ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">	process1(str, 0, ans, path);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;str固定参数</span><br><span class="line">&#x2F;&#x2F;index，此时进行判断的位置下标，要 or 不要</span><br><span class="line">&#x2F;&#x2F;如果index来到str的终止位置，就把沿途路径所形成的答案放在ans中</span><br><span class="line">&#x2F;&#x2F;之前做出的选择就是path</span><br><span class="line"></span><br><span class="line">public void process1(char[] str, int index, List&lt;String&gt; ans, String path)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; str.length)&#123;</span><br><span class="line">		ans.add(path);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	String no &#x3D; path;</span><br><span class="line">	process1(str, index + 1, ans, no);&#x2F;&#x2F;不要index位置的字符</span><br><span class="line">	String yes &#x3D; path + String.valueOf(str[index]);</span><br><span class="line">	process1(str, index + 1, ans, yes);&#x2F;&#x2F;要index位置的字符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印一个字符串的全部子序列，且要求不要重复出现的子序列</span><br><span class="line">public List&lt;String&gt; subsNoRepeate(String s)&#123;</span><br><span class="line">	char[] str &#x3D; s.toCharArray();</span><br><span class="line">	String path &#x3D; &quot;&quot;;</span><br><span class="line">	HashSet&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">	process2(str, 0, set, path);</span><br><span class="line">	return set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void process2(char[] str, int index, HashSet&lt;String&gt; set, String path)&#123;</span><br><span class="line">	if(index &#x3D;&#x3D; str.length)&#123;</span><br><span class="line">		set.add(path);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	String no &#x3D; path;</span><br><span class="line">	process1(str, index + 1, ans, no);&#x2F;&#x2F;不要index位置的字符</span><br><span class="line">	String yes &#x3D; path + String.valueOf(str[index]);</span><br><span class="line">	process1(str, index + 1, ans, yes);&#x2F;&#x2F;要index位置的字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] radixSort(int[] arr， int len)&#123;</span><br><span class="line">	int[] result &#x3D; new int[arr.length];</span><br><span class="line">	int[] count &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		int division &#x3D; (int)Math.pow(10,i);</span><br><span class="line">		for(int j&#x3D;0;j&lt;arr.length;j++)&#123;</span><br><span class="line">			int num &#x3D; arr[j]&#x2F;division%10;</span><br><span class="line">			count[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int m&#x3D;1; m&lt;count.length;m++)&#123;</span><br><span class="line">			count[m] &#x3D; count[m] + count[m-1];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int n&#x3D;arr.length-1;n&gt;&#x3D;0;n--)&#123;</span><br><span class="line">			int num &#x3D; arr[n] &#x2F; division % 10;</span><br><span class="line">			result[count[num]]&#x3D;arr[n];</span><br><span class="line">			count[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, 0, arr, 0, arr.length);</span><br><span class="line">		Arrays.fill(count,0);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PrintAllPermutations</title>
    <url>/2020/12/27/PrintAllPermutations/</url>
    <content><![CDATA[<h5 id="打印一个字符串的全部排列方式"><a href="#打印一个字符串的全部排列方式" class="headerlink" title="打印一个字符串的全部排列方式"></a>打印一个字符串的全部排列方式</h5><hr>
<pre><code>从左往右的尝试模型，排列组合的方式就是先固定0位置上的字符，即0~length-1上的字符都有可能来到0位置上，确定0位置上的字符以后，再确定1位置上的字符，即1~length-1上的字符都有可能来到1位置上...依次类推。

在要求无重复的排列中，可以通过哈希表的方式，来记录一个字符是否在某个位置上出现过，没有出现过才进行递归。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;str[0...i-1]都已经做好决定了</span><br><span class="line">&#x2F;&#x2F;str[i...]都有机会来到i位置</span><br><span class="line">&#x2F;&#x2F;i为终止位置，str当前的位置就是一种结果-&gt;res</span><br><span class="line">public void process(char[] str, int i, ArrayList&lt;String&gt; res)&#123;</span><br><span class="line">	if(i &#x3D;&#x3D; str.length)&#123;</span><br><span class="line">		res.add(String.valueOf(str));</span><br><span class="line">		return；</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果没有终止，那么i之后位置上的字符都可以来到i位置上</span><br><span class="line">	for(int j &#x3D; i; j &lt; str.length; j ++)&#123;</span><br><span class="line">		swap(str, i, j);</span><br><span class="line">		process(str, i+1, res);</span><br><span class="line">		swap(str, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(char[] str, int i, int j)&#123;</span><br><span class="line">	char[] temp &#x3D; str[i];</span><br><span class="line">	str[i] &#x3D; str[j];</span><br><span class="line">	str[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印字符串的所有排序方式，没有重复</span><br><span class="line">public void process2(char[] str, int i, ArratList&lt;String&gt; res)&#123;</span><br><span class="line">	if(i &#x3D;&#x3D; str.length)&#123;</span><br><span class="line">		res.add(String.valueOf(str));</span><br><span class="line">	&#125;</span><br><span class="line">	boolean[] visit &#x3D; new boolean[26];&#x2F;&#x2F;26个字母，当前位置，不与其他位置共享</span><br><span class="line">	for(int j &#x3D; i; j&lt;str.length; j++)&#123;</span><br><span class="line">		if(visit[str[j] - &#39;a&#39;] &#x3D;&#x3D; false)&#123;</span><br><span class="line">			visit[str[j] - &#39;a&#39;] &#x3D; true;</span><br><span class="line">			swap(str, i, j);</span><br><span class="line">			process2(str, i+1, res);</span><br><span class="line">			swap(str, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotMove</title>
    <url>/2020/12/27/RobotMove/</url>
    <content><![CDATA[<h4 id="机器人的移动问题"><a href="#机器人的移动问题" class="headerlink" title="机器人的移动问题"></a>机器人的移动问题</h4><pre><code>假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个）。如果机器人来打1位置上，那么下一步一定只能往右走来打2位置；如果机器人来到N位置，那么下一步只能往左来到N-1的位置；如果机器人来打中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种，给定四个参数N、M、K、P，返回方法数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int ways1(int N, int M, int K, int P)&#123;</span><br><span class="line">	&#x2F;&#x2F;参数无效直接返回0</span><br><span class="line">	if(N&lt;2 || K&lt;1 || M&lt;1 || M&gt;N || p&lt;1 || P&gt;N)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;总共N个位置，从M点出发，还剩K步，返回最终能到达P的方法数</span><br><span class="line">	return walk(N, M, K, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;N:位置1~N，固定参数</span><br><span class="line">&#x2F;&#x2F;cur:当前在cur位置，可变参数</span><br><span class="line">&#x2F;&#x2F;rest:剩余的步数，可变参数</span><br><span class="line">&#x2F;&#x2F;P：最终的目标位置</span><br><span class="line">&#x2F;&#x2F;该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法</span><br><span class="line">public int walk(int N, int cur, int rest, int P)&#123;</span><br><span class="line">	&#x2F;&#x2F;如果没有剩余步数了，当前的cur位置就是最后的位置</span><br><span class="line">    &#x2F;&#x2F;如果最后的位置停在P上，那么之前做的移动是有效的</span><br><span class="line">    &#x2F;&#x2F;如果最后的位置没在P上，那么之前做的移动式无效</span><br><span class="line">	if(rest&#x3D;&#x3D;0)&#123;</span><br><span class="line">		return cur&#x3D;&#x3D;P ? 1 : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span><br><span class="line">    &#x2F;&#x2F;后续的过程就是，来到2位置上，还剩rest-1步要走</span><br><span class="line">    if(cur&#x3D;&#x3D;1)&#123;</span><br><span class="line">    	return walk(N, 2, rest-1, P);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span><br><span class="line">	&#x2F;&#x2F;后续的过程就是，来到N-1位置上，还剩rest-1步要走</span><br><span class="line">    if(cur&#x3D;&#x3D;N)&#123;</span><br><span class="line">    	return walk(N, N-1, rest-1, P);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以想左也可以向右</span><br><span class="line">    &#x2F;&#x2F;走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span><br><span class="line">    &#x2F;&#x2F;走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span><br><span class="line">    return walk(N, cur+1, rest-1, P) + walk(N, cur-1, rest-1, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int waysCache(int N, int M, int K, int P)&#123;</span><br><span class="line">	&#x2F;&#x2F;参数无效直接返回0</span><br><span class="line">	if(N&lt;2 || K&lt;1 || M&lt;1 || M&gt;N || p&lt;1 || P&gt;N)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int[][] dp &#x3D; new int[N+1][K+1];</span><br><span class="line">	for(int row&#x3D;0; row&lt;&#x3D;N; row++)&#123;</span><br><span class="line">		for(int col&#x3D;0;col&lt;&#x3D;K;col++)&#123;</span><br><span class="line">			dp[row][col]&#x3D;-1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return walkCache(N, M, K, P, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表方法，把cur和rest所有方法加入到缓存中</span><br><span class="line">public int walkCache(int N, int cur, int rest, int P, int[][] dp)&#123;</span><br><span class="line">	if(dp[cur][rest]!&#x3D;-1)&#123;</span><br><span class="line">		return dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	int ways &#x3D; 0;</span><br><span class="line">	if(rest&#x3D;&#x3D;0)&#123;</span><br><span class="line">		dp[cur][rest] &#x3D; cur &#x3D;&#x3D; P ? 1 : 0;</span><br><span class="line">		return dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	if(cur&#x3D;&#x3D;1)&#123;</span><br><span class="line">		dp[cur][rest] &#x3D; walkCache(N, 2, rest-1, P, dp);</span><br><span class="line">		return dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	if(cur&#x3D;&#x3D;N)&#123;</span><br><span class="line">		dp[cur][rest] &#x3D; walkCache(N, N-1, rest-1, P, dp);</span><br><span class="line">		return dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[cur][rest] &#x3D; walkCache(N, cur+1, rest-1, P, dp) + walkCache(N, cur-1, rest-1, P, dp);</span><br><span class="line">	return dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int dpWays(int N, int M, int K, int P)&#123;</span><br><span class="line">	&#x2F;&#x2F;参数无效直接返回0</span><br><span class="line">	if(N&lt;2 || K&lt;1 || M&lt;1 || M&gt;N || p&lt;1 || P&gt;N)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int cur &#x3D; 0;</span><br><span class="line">	int rest &#x3D; 0;</span><br><span class="line">	int[][] dp &#x3D; new int[N+1][K+1];</span><br><span class="line">	dp[P][0] &#x3D; 1;</span><br><span class="line">	&#x2F;&#x2F;dp[!P][...]&#x3D;0</span><br><span class="line"></span><br><span class="line">	for(int rest &#x3D; 1; rest &lt;&#x3D; K; rest++)&#123;</span><br><span class="line">		for(int cur &#x3D; 1; cur &lt;&#x3D; N; cur++)&#123;</span><br><span class="line">			if(cur&#x3D;&#x3D;1)&#123;</span><br><span class="line">				dp[cur][rest] &#x3D; dp[2][rest-1];</span><br><span class="line">			&#125;else if(cur&#x3D;&#x3D;N)&#123;</span><br><span class="line">				dp[cur][rest] &#x3D; dp[N-1][rest-1];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				dp[cur][rest] &#x3D; dp[cur+1][rest-1]+dp[cur-1][rest-1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[M][P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShellSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;3,2,4,1,8,5,6&#125;;</span><br><span class="line"></span><br><span class="line">		int h &#x3D; 1;</span><br><span class="line">		while(h&lt;&#x3D;arr.length&#x2F;3)&#123;</span><br><span class="line">			h&#x3D;h*3+1;</span><br><span class="line">		&#125;&#x2F;&#x2F;初始化gap的方法</span><br><span class="line"></span><br><span class="line">		for(int gap&#x3D;h;gap&gt;0;gap&#x3D;(gap-1)&#x2F;3)&#123;</span><br><span class="line">			for(int i&#x3D;gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				for(int j&#x3D;i;j&gt;gap-1;j-&#x3D;gap)&#123;</span><br><span class="line">					if(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		arr[i] &#x3D; arr[j] + arr[i];</span><br><span class="line">		arr[j] &#x3D; arr[i] - arr[j];</span><br><span class="line">		arr[i] &#x3D; arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QucikSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;1,4,6,9,10,2,3,5,8,7&#125;;</span><br><span class="line">		sort(arr, 0, arr.length);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void sort(int[] arr, int left, int right)&#123;</span><br><span class="line">		if(left&gt;&#x3D;right)return;</span><br><span class="line"></span><br><span class="line">		int mid &#x3D; partition(arr, left, right);&#x2F;&#x2F;获取pivot的位置</span><br><span class="line">		sort(arr,left,mid-1);</span><br><span class="line">		sort(arr,mid+1,right);</span><br><span class="line">	&#125;</span><br><span class="line">	public static int partition(int[] arr, int start, int end)&#123;</span><br><span class="line">		int left &#x3D; start;</span><br><span class="line">		int right &#x3D; end - 1;</span><br><span class="line">		int pivot &#x3D; arr[end];</span><br><span class="line"></span><br><span class="line">		while(left&lt;&#x3D;right)&#123;</span><br><span class="line">			while(left&lt;&#x3D;right &amp;&amp; arr[left]&lt;&#x3D;pivot)left++;</span><br><span class="line">			while(left&lt;&#x3D;right &amp;&amp; arr[right]&gt;pivot)right--;</span><br><span class="line"></span><br><span class="line">			if(left&lt;right)swap(arr,left,right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		swap(arr, left, end);</span><br><span class="line"></span><br><span class="line">		return left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; arr[j];</span><br><span class="line">		arr[j] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void print(int[] arr)&#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean exist(int[] arr, int num)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0) return false;</span><br><span class="line">	int L &#x3D; 0;</span><br><span class="line">	int right &#x3D; arr.length - 1;</span><br><span class="line">	int mid &#x3D; 0;</span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">		&#x2F;&#x2F;防止溢出</span><br><span class="line">	  mid &#x3D; left + ((right-left)&gt;&gt;1);</span><br><span class="line">	  if(arr[mid]&#x3D;&#x3D;num)return true;</span><br><span class="line">	  else if(arr[mid]&gt;num) right &#x3D; mid - 1;</span><br><span class="line">	  else left &#x3D; left + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr[mid] &#x3D;&#x3D; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int nearestIndex(int[] arr, int value)&#123;</span><br><span class="line">	int left &#x3D; 0;</span><br><span class="line">	int right &#x3D; arr.length - 1;</span><br><span class="line">	int index &#x3D; -1;&#x2F;&#x2F;记录最左侧的下标</span><br><span class="line">	while(left &lt;&#x3D; right)&#123;</span><br><span class="line">		int mid &#x3D; left + ((right - left)&gt;&gt;1);</span><br><span class="line">		if(arr[mid]&gt;&#x3D;value)&#123;</span><br><span class="line">			index &#x3D; mid;</span><br><span class="line">			right &#x3D; mid - 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			left &#x3D; mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getLessIndex(int[] arr)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(arr.length &#x3D;&#x3D; 1 || arr[0] &lt; arr[1])&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(arr[arr.length - 2] &gt; arr[arr.length - 1])&#123;</span><br><span class="line">		return arr.length - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	int left &#x3D; 1;</span><br><span class="line">	int right &#x3D; arr.length - 2;</span><br><span class="line"></span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">		int mid &#x3D; left + ((right-left)&gt;&gt;1);</span><br><span class="line">		if(arr[mid] &gt; arr[mid - 1])&#123;</span><br><span class="line">			right &#x3D; mid - 1;</span><br><span class="line">		&#125;else if(arr[mid] &gt; arr[mid + 1])&#123;</span><br><span class="line">			left &#x3D; mid + 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PrintTreeTest &#123;</span><br><span class="line"></span><br><span class="line">    static class Node&#123;</span><br><span class="line">        int value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node(int v)&#123;</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printTree(Node head)&#123;</span><br><span class="line">        System.out.println(&quot;Binary Tree&quot;);</span><br><span class="line">        printInOrder(head, 0, &quot;H&quot;, 17);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printInOrder(Node head, int height, String to, int len)&#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        printInOrder(head.right, height+1, &quot;v&quot;, len);</span><br><span class="line">        String val &#x3D; to + head.value + to;</span><br><span class="line">        int lenM &#x3D; val.length();</span><br><span class="line">        int lenL &#x3D; (len - lenM) &#x2F; 2;</span><br><span class="line">        int lenR &#x3D; len - lenM - lenL;</span><br><span class="line">        val &#x3D; getSpace(lenL) + val +getSpace(lenR);</span><br><span class="line">        System.out.println(getSpace(height*len) + val);</span><br><span class="line">        printInOrder(head.left, height+1, &quot;^&quot;, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getSpace(int num)&#123;</span><br><span class="line">        String space &#x3D; &quot; &quot;;</span><br><span class="line">        StringBuffer buf &#x3D; new StringBuffer(&quot;&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;num;i++)&#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        return buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="返回二叉树中指定节点的后续节点"><a href="#返回二叉树中指定节点的后续节点" class="headerlink" title="返回二叉树中指定节点的后续节点"></a>返回二叉树中指定节点的后续节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	Node parent;</span><br><span class="line">	Node(int v)&#123;</span><br><span class="line">		value &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在中序遍历中的后继节点</span><br><span class="line">public static Node getSuccessorNode(Node node)&#123;</span><br><span class="line">	if(node &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node.right!&#x3D;null)&#123;</span><br><span class="line">		return getLeftMost(node.right);</span><br><span class="line">	&#125;else&#123;&#x2F;&#x2F;无右子树</span><br><span class="line">		Node parent &#x3D; node.parent;</span><br><span class="line">		while(parent !&#x3D; null &amp;&amp; parent.left !&#x3D; node)&#123;</span><br><span class="line">			node &#x3D; parent;</span><br><span class="line">			parent &#x3D; node.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node getLeftMost(Node node)&#123;</span><br><span class="line">	if(node &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return node;</span><br><span class="line">	&#125;</span><br><span class="line">	while(node.left!&#x3D;null)&#123;</span><br><span class="line">		node &#x3D; node.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="纸对折，依次输出折痕的方向"><a href="#纸对折，依次输出折痕的方向" class="headerlink" title="纸对折，依次输出折痕的方向"></a>纸对折，依次输出折痕的方向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void printAllFolds(int N)&#123;</span><br><span class="line">	printProcess(1, N, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归过程</span><br><span class="line">&#x2F;&#x2F;i是节点的层数，N一共的层数，down&#x3D;&#x3D;true凹 down&#x3D;&#x3D;false凸</span><br><span class="line">public static void printProcess(int i, int N, boolean)&#123;</span><br><span class="line">	if(i&gt;N)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	printProcess(i + 1, N, true);</span><br><span class="line">	System.out.println(down ? &quot;凹&quot; : &quot;凸&quot;);</span><br><span class="line">	printProcess(i + 1, N, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IsBalanced&#123;</span><br><span class="line">	public static class Node&#123;</span><br><span class="line">		int value;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		public Node(int val)&#123;</span><br><span class="line">			value &#x3D; val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static class Info&#123;</span><br><span class="line">		boolean isBalanced;</span><br><span class="line">		int height;</span><br><span class="line">		public Info(boolean b, int h)&#123;</span><br><span class="line">			isBalanced &#x3D; h;</span><br><span class="line">			height &#x3D; h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Info process(Node head)&#123;</span><br><span class="line">		if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return new Info(true, 0);</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo &#x3D; process(head.left);</span><br><span class="line">		Info rightInfo &#x3D; process(head.right);</span><br><span class="line"></span><br><span class="line">		int height &#x3D; Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">		boolean isBalanced &#x3D; false;</span><br><span class="line">		if(Math.abs(leftInfo.height - rightInfo.height &lt;2)	&amp;&amp; leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced)&#123;</span><br><span class="line">			isBalanced &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">		return new Info(isBalanced, height);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static boolean isBalanced(Node head)&#123;</span><br><span class="line">		return process(head).isBalanced;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"><a href="#给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）" class="headerlink" title="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"></a>给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	public Node(int data)&#123;</span><br><span class="line">		value &#x3D; data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMaxDistance(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return process(head).distacne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	int distance;</span><br><span class="line">	int height;</span><br><span class="line">	public Info(int d, int h)&#123;</span><br><span class="line">		distance &#x3D; d;</span><br><span class="line">		height &#x3D; h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意思考结果的可能性，常见的就是结果与当前节点有关和无关</span><br><span class="line">public Info process(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return new Info(0, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo &#x3D; process(head.left);</span><br><span class="line">	Info rightInfo &#x3D; process(head.right);</span><br><span class="line"></span><br><span class="line">	int heigth &#x3D; Math.max(leftInfo.height, rightInfo.height) + 1;</span><br><span class="line">	int distance &#x3D; Math.max(</span><br><span class="line">		Math.max(leftInfo.distance, rightInfo.distance), </span><br><span class="line">		leftInfo.height+rightInfo.height+2);</span><br><span class="line"></span><br><span class="line">	return new Info(distance, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	public Node(int data)&#123;</span><br><span class="line">		value &#x3D; data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Node getMaxSubBalancedTree(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null</span><br><span class="line">	&#125;</span><br><span class="line">	return process(head).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	boolean isAllBST;</span><br><span class="line">	int maxSubSize;</span><br><span class="line">	int min;</span><br><span class="line">	int max;</span><br><span class="line">	Node head;</span><br><span class="line">	public Info(boolean is, int size, int mi, int ma, Node h)&#123;</span><br><span class="line">		isAllBST &#x3D; is;</span><br><span class="line">		maxSubSize &#x3D; size;</span><br><span class="line">		min &#x3D; mi;</span><br><span class="line">		max &#x3D; ma;</span><br><span class="line">		head &#x3D; h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Info process(Node X)&#123;</span><br><span class="line">	if(X&#x3D;&#x3D;null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo &#x3D; process(X.left);</span><br><span class="line">	Info rightInfo &#x3D; process(X.right);</span><br><span class="line"></span><br><span class="line">	boolean isAllBST &#x3D; false;</span><br><span class="line">	int maxSubSize &#x3D; 0;</span><br><span class="line">	int min &#x3D; X.value;</span><br><span class="line">	int max &#x3D; X.value;</span><br><span class="line">	Node head &#x3D; null;</span><br><span class="line"></span><br><span class="line">	if(leftInfo!&#x3D;null)&#123;</span><br><span class="line">		min &#x3D; Math.min(min, leftInfo.min);</span><br><span class="line">		max &#x3D; Math.max(max, leftInfo.max);</span><br><span class="line">	&#125;</span><br><span class="line">	if(rightInfo!&#x3D;null)&#123;</span><br><span class="line">		min &#x3D; Math.min(min, rightInfo.min);</span><br><span class="line">		max &#x3D; Math.max(max, rightInfo.max);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;可能性1，与x节点无关</span><br><span class="line">	if(leftInfo!&#x3D;null)&#123;</span><br><span class="line">		maxSubSize &#x3D; leftInfo.maxSubSize;</span><br><span class="line">		head &#x3D; leftInfo.head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	if(rightInfo!&#x3D;null)&#123;</span><br><span class="line">		maxSubSize &#x3D; Math.max(maxSubSize, rightInfo.maxSubSize);</span><br><span class="line">		if(maxSubSize&lt;rightInfo.maxSubSize)&#123;</span><br><span class="line">			head &#x3D; rightInfo.head;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if((leftInfo &#x3D;&#x3D; null ? true : leftInfo.isAllBST) &amp;&amp; </span><br><span class="line">		(rightInfo &#x3D;&#x3D; null ? true : rightInfo.isAllBST) &amp;&amp;</span><br><span class="line">		(leftInfo &#x3D;&#x3D; null ? true : leftInfo.max &lt; X.value) &amp;&amp;</span><br><span class="line">		(right &#x3D;&#x3D; null ? true : rightInfo.min &gt; X.value))&#123;</span><br><span class="line"></span><br><span class="line">			maxSubSize &#x3D; (leftInfo &#x3D;&#x3D; null ? 0 : leftInfo.maxSubBSTSize) + (rightInfo &#x3D;&#x3D; null ? 0 : rightInfo.maxSubBSTSize) + 1;</span><br><span class="line">			isAllBST &#x3D; true;</span><br><span class="line">			head &#x3D; X;</span><br><span class="line">	&#125;</span><br><span class="line">	return new Info(isAllBST, maxSubSize, min, max, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="派对的快乐值"><a href="#派对的快乐值" class="headerlink" title="派对的快乐值"></a>派对的快乐值</h4><pre><code>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。数的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些不来，规则：
1.如果某员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Employee&#123;</span><br><span class="line">	public happy;</span><br><span class="line">	public List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">	public Employee(int h)&#123;</span><br><span class="line">		happy &#x3D; h;</span><br><span class="line">		nexts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int maxHappy(Employee boss)&#123;</span><br><span class="line">	if(boss &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Info all &#x3D; process(boss);</span><br><span class="line">	return Math.max(all.yes, all.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	int yes;&#x2F;&#x2F;x来情况下的最大happy</span><br><span class="line">	int no;&#x2F;&#x2F;x不来情况下的最大happy</span><br><span class="line"></span><br><span class="line">	public Info(int y, int n)&#123;</span><br><span class="line">		yes &#x3D; y;</span><br><span class="line">		no &#x3D; n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Info process(Employee x)&#123;</span><br><span class="line">	if(x.nexts.isEmpty)&#123;</span><br><span class="line">		return new Info(x.happy, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int yes &#x3D; x.happy;</span><br><span class="line">	int no &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	for(Employee next : x.nexts)&#123;</span><br><span class="line">		Info nextInfo &#x3D; process(next);</span><br><span class="line">		yes +&#x3D; nextInfo.no;</span><br><span class="line">		no +&#x3D; Math.max(nextInfo.yes,nextInfo.no);</span><br><span class="line">	&#125;</span><br><span class="line">	return new Info(yes, no);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组中，只有一种数出现了奇数次</span><br><span class="line">public void printOddTimesNum1(int[] arr)&#123;</span><br><span class="line">	int eor &#x3D; arr[0];</span><br><span class="line">	for(int i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^&#x3D;arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组中，有两种数出现了两次</span><br><span class="line">public void printOddTimesNum2(int[] arr)&#123;</span><br><span class="line">	int eor &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^&#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; eor &#x3D; a^b</span><br><span class="line">	&#x2F;&#x2F; eor !&#x3D; 0</span><br><span class="line">	&#x2F;&#x2F; eor必然有一个位置是1</span><br><span class="line">	int rightOne &#x3D; eor &amp; (~eor + 1);</span><br><span class="line">	int onlyOne &#x3D; 0;&#x2F;&#x2F;eor&#39;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">		if((arr[i] &amp; rightOne) !&#x3D; 0)&#123;</span><br><span class="line">			onlyOne ^&#x3D; arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node1&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(int value)&#123;</span><br><span class="line">		value &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先序</span><br><span class="line">public static void pre(Node1 head)&#123;</span><br><span class="line">	if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序</span><br><span class="line">public static void in(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	in(head.left);</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">	in(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后序</span><br><span class="line">public static void pos(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的先序遍历，非递归方法</span><br><span class="line">public static void pre1(Node1 head)&#123;</span><br><span class="line">	if(head !&#x3D; null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack &#x3D; new Satck&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		while(!stack.isEmpty())&#123;</span><br><span class="line">			head &#x3D; stack.pop();</span><br><span class="line">			System.out.print(head.value + &quot; &quot;);</span><br><span class="line">			if(head.right!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			if(head.left!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二叉树的后序遍历，非递归方法</span><br><span class="line">public static void pos1(Node1 head)&#123;</span><br><span class="line">	if(head!&#x3D;null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		s1.push(head);</span><br><span class="line">		while(!s1.isEmpty())&#123;</span><br><span class="line">			head &#x3D; s1.pop();</span><br><span class="line">			s2.push(head);</span><br><span class="line">			if(head.left!&#x3D;null)&#123;</span><br><span class="line">				s1.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			if(head.right!&#x3D;null)&#123;</span><br><span class="line">				s1.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.print(s2.pop().value+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用一个栈实现非递归的后序遍历</span><br><span class="line">public static void pos2(Node1 h)&#123;</span><br><span class="line">    if(h !&#x3D; null)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node1 c &#x3D; null;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            c &#x3D; stack.peek();</span><br><span class="line">            if(c.left !&#x3D; null &amp;&amp; h!&#x3D;c.left &amp;&amp; h !&#x3D; c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;else if(c.right !&#x3D; null &amp;&amp; h!&#x3D;c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(stack.pop()+&quot; &quot;);</span><br><span class="line">                h&#x3D;c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二叉树的中序遍历，非递归方法</span><br><span class="line">&#x2F;&#x2F;1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span><br><span class="line">public static void in1(Node1 head)&#123;</span><br><span class="line">	if(head!&#x3D;null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		while(!stack.siEmpty() || head!&#x3D;null)&#123;</span><br><span class="line">			if(head!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head);</span><br><span class="line">				head &#x3D; head.left;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				head &#x3D; stack.pop();</span><br><span class="line">				System.out.print(head.value+&quot; &quot;);</span><br><span class="line">				head &#x3D; head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现二叉树的按层遍历</span><br><span class="line"> * 1）其实就是宽度优先遍历，用队列</span><br><span class="line"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public static void level(Node1)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if(queue.right!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出具有最大层的节点数，使用哈希表</span><br><span class="line">public static int maxWithUseMap(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">	levelMap.put(head, 1);</span><br><span class="line">	int curLevel &#x3D; 1;&#x2F;&#x2F;当前正在统计哪一层的宽度</span><br><span class="line">	int curLevelNodes &#x3D; 0;&#x2F;&#x2F;当前层的宽度</span><br><span class="line">	int max &#x3D; 0;</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		int curNodeLevel &#x3D; levelMap.get(cur);</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			levelMap.put(cur.left, curNodeLevel+1);</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if(cur.right!&#x3D;null)&#123;</span><br><span class="line">			levelMap.put(cur.right, curLevel+1);</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span><br><span class="line">		if(curNodeLevel &#x3D;&#x3D; curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	max &#x3D; max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出具有最大层的节点数，不使用哈希表</span><br><span class="line">public static int maxWidthNoMap(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	Node1 curEnd &#x3D; head;&#x2F;&#x2F;当前层，最右节点</span><br><span class="line">	Node1 nextEnd &#x3D; head;&#x2F;&#x2F;下一层，最右节点</span><br><span class="line"></span><br><span class="line">	int max &#x3D; 0;</span><br><span class="line">	int curLevelNodes &#x3D; 0;&#x2F;&#x2F;当前层的节点数</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">			nextEnd &#x3D; cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		if(cur.right!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">			nextEnd &#x3D; cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		if(cur &#x3D;&#x3D; curEnd)&#123;</span><br><span class="line">			max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">			curLevelNodes &#x3D; 0;</span><br><span class="line">			curEnd &#x3D; nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先序遍历序列化与重构</span><br><span class="line">public static Queue&lt;String&gt; preSerial(Node head)&#123;</span><br><span class="line">	Queue&lt;String&gt; ans &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void pres(Node head, Queue&lt;String&gt; ans)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		ans.add(null);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		ans.add(String.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node buildByPreQueue(Queue&lt;String&gt; prelist)&#123;</span><br><span class="line">	if(prelist &#x3D;&#x3D; null || prelist.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	return preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node preb(Queue&lt;String&gt; prelist)&#123;</span><br><span class="line">	String value &#x3D; prelist.poll();</span><br><span class="line">	if(value &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head &#x3D; new Node(Integer.valueOf(value));</span><br><span class="line">	head.left &#x3D; preb(prelist);</span><br><span class="line">	head.right &#x3D; preb(prelist);</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按层序列化</span><br><span class="line">public static Queue&lt;String&gt; levelSerial(Node head)&#123;</span><br><span class="line">    Queue&lt;String&gt; ans &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">        ans.add(null);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        ans.add(String.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            head &#x3D; queue.poll();</span><br><span class="line">            if(head.left!&#x3D;null)&#123;</span><br><span class="line">                ans.add(String.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                ans.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">            if(head.right!&#x3D;null)&#123;</span><br><span class="line">                ans.add(String.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node buildByLevelQueue(Queue&lt;String&gt; levelList)&#123;</span><br><span class="line">    if(levelList &#x3D;&#x3D; null || levelList.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head &#x3D; generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;Node&gt;();</span><br><span class="line">    if(head !&#x3D; null)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; null;</span><br><span class="line">    while(!queue.isEmpty())&#123;</span><br><span class="line">        node &#x3D; queue.poll();</span><br><span class="line">        node.left &#x3D; generateNode(levelList.poll());</span><br><span class="line">        node.right &#x3D; generateNode(levelList.poll());</span><br><span class="line">        if(node.left !&#x3D; null)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right !&#x3D; null)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Node generateNode(String val) &#123;</span><br><span class="line">    if(val &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;1,4,7,8,3,6,9&#125;;</span><br><span class="line">		sort(arr, 0, arr.length-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(int[] arr, int start, int end)&#123;</span><br><span class="line">		if(start&#x3D;&#x3D;end)return;</span><br><span class="line">		&#x2F;&#x2F;分成两块</span><br><span class="line">		int mid &#x3D; start + (end - start)&#x2F;2;</span><br><span class="line">		&#x2F;&#x2F;左边排序</span><br><span class="line">		sort(arr, start, mid);</span><br><span class="line">		&#x2F;&#x2F;右边排序</span><br><span class="line">		sort(arr, mide + 1, end);</span><br><span class="line"></span><br><span class="line">		merge(arr, start, mid + 1, end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void merge(int[] arr, int left, int mid, int right)&#123;</span><br><span class="line">		int i &#x3D; left;</span><br><span class="line">		int j &#x3D; mid + 1;</span><br><span class="line">		int k &#x3D; 0;</span><br><span class="line">		int[] temp &#x3D; new int[right - left + 1];</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">			if(arr[j] &lt;&#x3D; arr[j])temp[k++] &#x3D; arr[i++];</span><br><span class="line">			else temp[k++] &#x3D; arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid) temp[k++] &#x3D; arr[i++];</span><br><span class="line">		while(j&lt;&#x3D;right) temp[k++] &#x3D; arr[j++];</span><br><span class="line"></span><br><span class="line">		for(int m&#x3D;0; m&lt;temp.length; m++)&#123;</span><br><span class="line">			arr[left+m] &#x3D; temp[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; arr[j];</span><br><span class="line">		arr[j] &#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BubbleSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">				if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j+1];</span><br><span class="line">					arr[j+1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InsertSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;i;j&gt;0;j--)&#123;</span><br><span class="line">				if(arr[j]&lt;arr[j-1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j-1];</span><br><span class="line">					arr[j-1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	public int value;</span><br><span class="line">	public Node next;</span><br><span class="line"></span><br><span class="line">	public Node(int v)&#123;</span><br><span class="line">		value &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有3个或以上的点</span><br><span class="line">	Node slow &#x3D; head.next;</span><br><span class="line">	Node fast &#x3D; head.next.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head.next;</span><br><span class="line">	Node fast &#x3D; head.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head;</span><br><span class="line">	Node fast &#x3D; head.next.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head;</span><br><span class="line">	Node fast &#x3D; head.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();</span><br><span class="line">	Node cur &#x3D; head;</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		if(head.value !&#x3D; stack.pop().value)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		head &#x3D; head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;need o(1) extra space</span><br><span class="line">public boolean isPalindrome2(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 &#x3D; head;</span><br><span class="line">	NOde n2 &#x3D; head;</span><br><span class="line">	while(n2.next!&#x3D; null &amp;&amp; n2.next.next!&#x3D;null)&#123;</span><br><span class="line">		n1 &#x3D; n1.next;&#x2F;&#x2F;n1-&gt;mid</span><br><span class="line">		n2 &#x3D; n2.next.next;&#x2F;&#x2F;n2-&gt;end</span><br><span class="line">	&#125;</span><br><span class="line">	n2 &#x3D; n1.next;&#x2F;&#x2F;n2-&gt;right part first node</span><br><span class="line">	n1.next &#x3D; null;&#x2F;&#x2F;mid.next-&gt;null</span><br><span class="line">	Node n3 &#x3D; null;</span><br><span class="line">	while(n2!&#x3D;null)&#123;&#x2F;&#x2F;right part convert</span><br><span class="line">		n3 &#x3D; n2.next;&#x2F;&#x2F;n3-&gt;save the node</span><br><span class="line">		n2.next &#x3D; n1;&#x2F;&#x2F;next of right node convert</span><br><span class="line">		n1 &#x3D; n2;&#x2F;&#x2F;n1 move</span><br><span class="line">		n2 &#x3D; n3;&#x2F;&#x2F;n2 move</span><br><span class="line">	&#125;</span><br><span class="line">	n3 &#x3D; n1; &#x2F;&#x2F; n3 -&gt; save last node</span><br><span class="line">	n2 &#x3D; head; &#x2F;&#x2F; n2 -&gt; left first node</span><br><span class="line">	boolean res &#x3D; true;</span><br><span class="line">	while(n1 !&#x3D; null &amp;&amp; n2!&#x3D; null)&#123; &#x2F;&#x2F; check palindrome</span><br><span class="line">		if(n1.value !&#x3D; n2.value)&#123;</span><br><span class="line">			res &#x3D; false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 &#x3D; n1.next; &#x2F;&#x2F; left to mid</span><br><span class="line">		n2 &#x3D; n2.next; &#x2F;&#x2F; right to mid</span><br><span class="line">	&#125;</span><br><span class="line">	n1 &#x3D; n3.next;</span><br><span class="line">	n3.next &#x3D; null;</span><br><span class="line">	while(n1 !&#x3D; null)&#123;</span><br><span class="line">		n2 &#x3D; n1.next;</span><br><span class="line">		n1.next &#x3D; n3;</span><br><span class="line">		n3 &#x3D; n1;</span><br><span class="line">		n1 &#x3D; n2;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Node listPartition1(Node head, int piovt)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur &#x3D; head;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	while(cur!&#x3D;null)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr &#x3D; new Node[i];</span><br><span class="line">	i &#x3D; 0;</span><br><span class="line">	cur &#x3D; head;</span><br><span class="line">	for(i &#x3D; 0; i!&#x3D;nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] &#x3D; cur;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	for(i &#x3D; 1; i !&#x3D; nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i-1].next &#x3D; nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i-1].next &#x3D; null;</span><br><span class="line">	return nodeArr[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void arrPartition(Node[] nodeArr, int pivot)&#123;</span><br><span class="line">	int samll &#x3D; -1;</span><br><span class="line">	int big &#x3D; nodeArr.length;</span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	while(index!&#x3D;big)&#123;</span><br><span class="line">		if(nodeArr[index].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,index++);</span><br><span class="line">		&#125;else if(nodeArr[index].value&#x3D;&#x3D;piovt)&#123;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			swap(nodeArr, --big, index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;面试方法</span><br><span class="line">public Node listPartition2(Node head, int pivot)&#123;</span><br><span class="line">	Node sH &#x3D; null;&#x2F;&#x2F;small head</span><br><span class="line">	Node sT &#x3D; null;&#x2F;&#x2F;samll tail</span><br><span class="line">	Node eH &#x3D; null;&#x2F;&#x2F;equal head</span><br><span class="line">	Node eT &#x3D; null;&#x2F;&#x2F;equal tail</span><br><span class="line">	Node mH &#x3D; null;&#x2F;&#x2F;big head</span><br><span class="line">	Node MT &#x3D; null;&#x2F;&#x2F;big tail</span><br><span class="line">	Node next &#x3D; null;&#x2F;&#x2F;save the node</span><br><span class="line">	&#x2F;&#x2F;every node distributed to three lists</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		next &#x3D; head.next;</span><br><span class="line">		head.next &#x3D; null;</span><br><span class="line">		if(head.value &lt; pivot)&#123;</span><br><span class="line">			if(sH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				sH &#x3D; head;</span><br><span class="line">				sT &#x3D; head;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				sT.next &#x3D; head;</span><br><span class="line">				sT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(head.value &#x3D;&#x3D; pivot)&#123;</span><br><span class="line">			if(eH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				eH &#x3D; head;</span><br><span class="line">				eT &#x3D; head;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eT.next &#x3D; head;</span><br><span class="line">				eT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(mH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				mH &#x3D; head;</span><br><span class="line">				mT &#x3D; head;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				mT.next &#x3D; head;</span><br><span class="line">				mT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head &#x3D; next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;小于区域的尾巴，连等于区域的头，等于区域的尾巴</span><br><span class="line">	if(sT!&#x3D;null)&#123;&#x2F;&#x2F;如果有小于区域</span><br><span class="line">		sT.next &#x3D; eH;</span><br><span class="line">		eT &#x3D; eT &#x3D;&#x3D; null ? sT : eT;&#x2F;&#x2F;下一步，谁去连大于区域的头</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;上面的if，不管跑了没有，et</span><br><span class="line">	&#x2F;&#x2F;all reconnect</span><br><span class="line">	if(et!&#x3D;null)&#123;</span><br><span class="line">		eT.next &#x3D; mH;</span><br><span class="line">	&#125;</span><br><span class="line">	return sH !&#x3D; null ? sH : (eH !&#x3D; null ? eH : mH);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 一种特殊的单链表节点描述一下</span><br><span class="line">	class Node&#123;</span><br><span class="line">		int value;</span><br><span class="line">		Node next;</span><br><span class="line">		Node rand;</span><br><span class="line">		Node(int val)&#123;</span><br><span class="line">			value &#x3D; val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//笔试方法，使用HashMap<br>public Node copyListWithRand1(Node head){<br>    HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();<br>    Node cur = head;<br>    while(cur != null){<br>        map.put(cur, new Node(cur.value));<br>        cur = cur.next;<br>    }<br>    cur = head;<br>    while(cur!=null){<br>        //cur 老节点<br>        //map.get(cur)新节点<br>        map.get(cur).next = map.get(cur.next);<br>        map.get(cur).rand = map.get(cut.rand);<br>        cur = cur.next;<br>    }<br>    return mp.get(head);<br>}</p>
<p>//面试用的方法<br>public Node copyListWithRand2(Node head){<br>    if(head == null){<br>        return null;<br>    }<br>    Node cur = head;<br>    Node next = null;<br>    //copy node and link to every node<br>    //1-&gt;2<br>    //1-&gt;1’-&gt;2<br>    while(cur!=null){<br>        next = cur.next;<br>        cur.next = new Node(cur.value);<br>        cur.next.next = next;<br>        cur = next;<br>    }<br>    cur = head;<br>    Node curCopy = null;<br>    //set copy node rand<br>    //1-&gt;1’-&gt;2-&gt;2’<br>    while(cur!=null){<br>        //cur 老<br>        //cur.next 新 copy<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        curCopy.rand = cur.rand != null ? cur.rand.next : null;<br>        cur = next;<br>    }<br>    Node res = head.next;<br>    cur = head;<br>    // split<br>    while(cur!=null){<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        cur.next = next;<br>        curCopy.next = next != null ? next.next : null;<br>        cur = next;<br>    }<br>    return res;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 两个可能有环链表的交点</span><br></pre></td></tr></table></figure>
<p>class Node{<br>    int value;<br>    Node next;<br>    Node(int v){<br>        value = v;<br>    }<br>}</p>
<p>public class LinkedTest {</p>
<pre><code>public static void main(String[] args) &#123;
    Node head = new Node(1);
    Node node2 = new Node(2);
    Node node3 = new Node(3);
    Node node4 = new Node(4);
    Node node5 = new Node(5);
    Node node6 = new Node(6);
    Node node7 = new Node(7);
    Node node8 = new Node(8);
    Node node9 = new Node(9);
    Node node10 = new Node(10);

    head.next = node2;
    node2.next = node3;
    node3.next = node4;
    node4.next = node5;
    node5.next = node6;
    node6.next = node7;
    node7.next = node8;
    node8.next = node9;
    node9.next = node10;
    node10.next = node5;

    Node crossNode = getLoopNode(head);
    System.out.println(crossNode.value);
&#125;

public static Node getIntersection(Node head1, Node head2)&#123;
    if(head1 == null || head2==null)&#123;
        return null;
    &#125;
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if(loop1==null &amp;&amp; loop2==null)&#123;
        return noLoop(head1, head2);
    &#125;
    if(loop1!=null &amp;&amp; loop2!=null)&#123;
        return  bothLoop(head1, loop1, head2, loop2);
    &#125;
    return null;
&#125;

//返回一个链表第一个入环的节点
public static Node getLoopNode(Node head)&#123;
    if(head ==null || head.next ==null || head.next.next == null)&#123;
        return null;
    &#125;
    // n1 慢 n2 快
    Node n1 = head.next; //n1-&gt;slow
    Node n2 = head.next.next; //n2-&gt;fast
    while(n1 != n2)&#123;
        if(n2.next == null || n2.next.next == null)&#123;
            return null;
        &#125;
        n2 = n2.next.next;
        n1 = n1.next;
    &#125;
    n2 = head;  //n2-&gt;walk again from head
    while(n1!=n2)&#123;
        n1 = n1.next;
        n2 = n2.next;
    &#125;
    return n1;
&#125;


//如果两个无环链表相交返回第一个相交的节点，如果不相交返回空
public static Node noLoop(Node head1, Node head2)&#123;
    if(head1 == null || head2 == null)&#123;
        return null;
    &#125;
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    while(cur1.next != null)&#123;
        n++;
        cur1 = cur1.next;
    &#125;
    while(cur1.next != null)&#123;
        n--;
        cur2 = cur2.next;
    &#125;
    if(cur1 != cur2)&#123;
        return null;
    &#125;
    //n : 链表1的长度减去链表2的长度
    cur1 = n &gt; 0 ? head1 : head2; //长的变为cur1
    cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2
    n = Math.abs(n);
    while(n!=0)&#123;
        n--;
        cur1 = cur1.next;
    &#125;
    while(cur1 != cur2)&#123;
        cur1 = cur1.next;
        cur2 = cur2.next;
    &#125;
    return cur1;
&#125;

//两个链表都有环，返回第一个相交的节点，不相交则返回空
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2)&#123;
    Node cur1 = null;
    Node cur2 = null;
    if(loop1 == loop2)&#123;
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while(cur1!=loop1)&#123;
            n++;
            cur1 = cur1.next;
        &#125;
        while(cur2!=loop2)&#123;
            n--;
            cur2 = cur2.next;
        &#125;
        cur1 = n &gt; 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 :head1;
        n = Math.abs(n);
        while(n!=0)&#123;
            n--;
            cur1 = cur1.next;
        &#125;
        while(cur1!=cur2)&#123;
            cur1= cur1.next;
            cur2 = cur2.next;
        &#125;
        return cur1;
    &#125;else&#123;
        cur1 = loop1.next;
        while(cur1!=loop1)&#123;
            if(cur1 == loop2)&#123;
                return loop1;
            &#125;
            cur1 = cur1.next;
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<p>}<br>```</p>
]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SelectionSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int arr[] &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for(int i &#x3D; 0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">			int minPos &#x3D; i;</span><br><span class="line"></span><br><span class="line">			for(int j&#x3D;i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos &#x3D; arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; temp;</span><br><span class="line">			arr[minPos] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
