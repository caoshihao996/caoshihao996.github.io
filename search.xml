<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CoinsWay</title>
    <url>/2020/12/28/CoinWays/</url>
    <content><![CDATA[<h4 id="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"><a href="#使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张" class="headerlink" title="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"></a>使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张</h4><pre><code>从左到右的模型，依次判断index位置上的纸币用几张，当index到达length时，如果rest==0，则该方法有效
返回1，否则返回0.在由暴力递归改成动态规划时，要考虑枚举问题。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ways1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：0~index-1位置上的货币使用已经确定，从index之后的货币使用方法数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选用index位置上的货币</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">1</span>; zhang*arr[<span class="keyword">index</span>] &lt;= rest; zhang++)&#123;</span><br><span class="line">		p2 += process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest - zhang*arr[<span class="keyword">index</span>]);<span class="comment">//选用index位置上的货币，至少一张</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法，每个格子有枚举行为，细粒度划分</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			<span class="built_in">int</span> ways = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">0</span>; zhang*arr[<span class="keyword">index</span>]&lt;=rest; zhang++)&#123;</span><br><span class="line">				ways += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-zhang*arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划方法，省去枚举行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];<span class="comment">//没有使用cur位置上的</span></span><br><span class="line">			<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>][rest-arr[<span class="keyword">index</span>]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CardInLine</title>
    <url>/2020/12/27/CardInLine/</url>
    <content><![CDATA[<h4 id="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"><a href="#玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值" class="headerlink" title="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"></a>玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值</h4><pre><code>给定一个整形数组arr，代表数值不同的纸牌拍成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后
拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都决定聪明。请问最后获胜者的分数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( L==R )&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(arr[L] + s(arr, L+<span class="number">1</span>, R), arr[R] + s(arr, L, R<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;			<span class="comment">//先手函数选了arr[L]</span></span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">min</span>(f(arr, L+<span class="number">1</span>, R), f(arr, L, R<span class="number">-1</span>));<span class="comment">//对手会让你选择最小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>), s(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpWay</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr ==null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">	<span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; i++)&#123;</span><br><span class="line">		f[i][i] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//s[i][i]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = i;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;N &amp;&amp; R&lt;N)&#123;</span><br><span class="line">			f[L][R] = Math.<span class="built_in">max</span>(arr[L]+s[L+<span class="number">1</span>][R], arr[R]+s[L][R<span class="number">-1</span>]);</span><br><span class="line">			s[L][R] = Math.<span class="built_in">min</span>(arr[L]+f[L+<span class="number">1</span>][R], arr[R]+f[L][R<span class="number">-1</span>]);</span><br><span class="line">			L++;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f[<span class="number">0</span>][N<span class="number">-1</span>], s[<span class="number">0</span>][N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2021/03/19/BinaryTreeLayer/</url>
    <content><![CDATA[<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;<span class="type">Integer</span>&gt; PrintFromTopToBottom(TreeNode root)&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;<span class="type">Integer</span>&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			ret.<span class="keyword">add</span>(t.val);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.left);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h4 id="二叉树的多行遍历"><a href="#二叉树的多行遍历" class="headerlink" title="二叉树的多行遍历"></a>二叉树的多行遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			list.<span class="keyword">add</span>(t.val);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.lef);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">			ret.<span class="keyword">add</span>(list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt; &gt; ret = <span class="built_in">new</span> ArrayList;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.<span class="keyword">add</span>(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">reverse</span> = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    	ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> cnt = queue.size();</span><br><span class="line">    	<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">    		TreeNode t = queue.poll();</span><br><span class="line">    		<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		list.<span class="keyword">add</span>(t.val);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.left);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">reverse</span>)</span><br><span class="line">    		Colllections.reverse(list);</span><br><span class="line">    	<span class="keyword">reverse</span>=!<span class="keyword">reverse</span>;</span><br><span class="line">    	<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">    		ret.<span class="keyword">add</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>广度优先遍历</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">	<span class="comment">//找出数组中最大值和最小值</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">max</span> = Integer.MIN_VALUE;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化计数数组count[]</span></span><br><span class="line">	<span class="comment">//长度为最大值减去最小值加1，再加1</span></span><br><span class="line">	<span class="type">int</span>[] <span class="built_in">count</span> = new <span class="type">int</span>[<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数，并确保count[0]永远为0</span></span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">count</span>[num-<span class="built_in">min</span>+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计数数组变形，新元素是的值是前面元素的累加之和的值</span></span><br><span class="line">	for(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">count</span>.length;i++)&#123;</span><br><span class="line">		<span class="built_in">count</span>[i] += <span class="built_in">count</span>[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建结果数组</span></span><br><span class="line">	<span class="type">int</span>[] result = new <span class="type">int</span>[arr.length];</span><br><span class="line">	<span class="comment">//遍历arr中的元素，填充到结果数组中去，从前往后遍历</span></span><br><span class="line">	for(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]] = arr[j];</span><br><span class="line">		<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ConvertToLetters</title>
    <url>/2020/12/27/ConvertToLetters/</url>
    <content><![CDATA[<h4 id="将数字转化为字母有多少种方法，从左往右的尝试模型"><a href="#将数字转化为字母有多少种方法，从左往右的尝试模型" class="headerlink" title="将数字转化为字母有多少种方法，从左往右的尝试模型"></a>将数字转化为字母有多少种方法，从左往右的尝试模型</h4><pre><code>规定1和A对应、2和B对应、3和C对应...的规则。那么一个数字字符串比如“111”就可以转化为AAA、KA、AK。给定一个只
有数字字符串组成的字符串str,返回有多少种转化结果。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> numbers(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span> == <span class="keyword">null</span> || <span class="built_in">str</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(<span class="built_in">str</span>.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str[0..i-1]已经转化完了，固定了</span></span><br><span class="line"><span class="comment">//返回值：从i开始到结尾有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process1(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str[i] == &#x27;3&#x27;~&#x27;9&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> process(<span class="built_in">str</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="built_in">int</span> N = <span class="built_in">str</span>.length;</span><br><span class="line">	<span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>];</span><br><span class="line">	dp[N] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>NQueens</title>
    <url>/2020/12/27/NQueens/</url>
    <content><![CDATA[<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><pre><code>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n
返回n种皇后的摆法有多少种。
n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//record[i]-&gt;i行的皇后，放在了第几列</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//潜台词：record[0...i-1]的皇后，任何两个皇后都不共行、不共列、不共斜线</span></span><br><span class="line"><span class="comment">//目前来到了第i行</span></span><br><span class="line"><span class="comment">//record[0..i-1]表示之前的行，放了皇后的列的序号</span></span><br><span class="line"><span class="comment">//返回值，接着把i...之后摆完，有多少种摆法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//i来到证明前面的摆法有效，返回1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//依次尝试i行的皇后摆放在什么位置</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isValid</span>(record, i, j))&#123;</span><br><span class="line">			record[i] = j;</span><br><span class="line">			res += <span class="built_in">process</span>(i+<span class="number">1</span>, record, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(record[k] ==j || Math.<span class="built_in">abs</span>(k-i) == Math.<span class="built_in">abs</span>(recod[k]-j))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用位运算计算不超过32皇后的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&lt;<span class="number">32</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果你是9皇后问题，limit最右9个是1，其他都是0</span></span><br><span class="line">	<span class="keyword">int</span> limit = n == <span class="number">32</span> ? <span class="number">-1</span> : (<span class="number">1</span>&lt;&lt;n) <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit 划定了问题的规模，是固定的</span></span><br><span class="line"><span class="comment">//colLim 列的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDiaLim, <span class="keyword">int</span> rightDiaLim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colLim == limit)&#123;<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有候选皇后的位置，都在pos上</span></span><br><span class="line">    <span class="comment">//colLim | leftDiaLim | rightDigLim -&gt; 总限制</span></span><br><span class="line">    <span class="comment">//~(colLim | leftDiaLim | rightDigLim) -&gt; 左侧的一坨0干扰，右侧每个1可尝试</span></span><br><span class="line">    <span class="comment">//所有可以放皇后都在pos上</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//提取中pos最右侧的1，剩下位置都是0</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(limit, colLim | mostRightOne, (leftDiaLim|mostRightOne)&lt;&lt;<span class="number">1</span>,</span><br><span class="line">                (rightDiaLim|mostRightOne)&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2020/12/27/Knapsack/</url>
    <content><![CDATA[<h4 id="背包问题，从左往右的尝试模型"><a href="#背包问题，从左往右的尝试模型" class="headerlink" title="背包问题，从左往右的尝试模型"></a>背包问题，从左往右的尝试模型</h4><pre><code>给定两个长度都为N的数组weights和values，weight[i]和values[i]分别代表物品的重量和价值。给定一个正数bag
表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不变：w[] v[] bag</span></span><br><span class="line"><span class="comment">//index... 最大价值</span></span><br><span class="line"><span class="comment">//0...index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span></span><br><span class="line"><span class="comment">//如果返回-1则认为没有方法，如果不返回-1，则认为返回的值是真实值</span></span><br><span class="line"><span class="comment">//函数返回值为index之后的最大价值</span></span><br><span class="line">public <span class="type">int</span> process(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> alreadyW, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="keyword">if</span>(alreadyW&gt;bag)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//index到达length时，剩余货物的最大价值为0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW, bag);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW+w[<span class="keyword">index</span>], bag);<span class="comment">//yes</span></span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="type">int</span> process1(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest-w[<span class="keyword">index</span>]);</span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">public <span class="type">int</span> dpWay(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="type">int</span> N = w.<span class="built_in">length</span>;</span><br><span class="line">	<span class="type">int</span>[][] dp = new <span class="type">int</span>[N+<span class="number">1</span>][bag+<span class="number">1</span>];<span class="comment">//dp[N][...]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">index</span>=N<span class="number">-1</span>;<span class="keyword">index</span>&gt;=<span class="number">0</span>;<span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//dp[index][rest]=?</span></span><br><span class="line">			<span class="type">int</span> p1 = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rest - w[<span class="keyword">index</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				p2 = v[<span class="keyword">index</span>] + dp[<span class="keyword">index</span>+<span class="number">1</span>][rest - w[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PrintAllPermutations</title>
    <url>/2020/12/27/PrintAllPermutations/</url>
    <content><![CDATA[<h5 id="打印一个字符串的全部排列方式"><a href="#打印一个字符串的全部排列方式" class="headerlink" title="打印一个字符串的全部排列方式"></a>打印一个字符串的全部排列方式</h5><hr>
<pre><code>从左往右的尝试模型，排列组合的方式就是先固定0位置上的字符，即0~length-1上的字符都有可能来到0位置上，确
定0位置上的字符以后，再确定1位置上的字符，即1~length-1上的字符都有可能来到1位置上...依次类推。

在要求无重复的排列中，可以通过哈希表的方式，来记录一个字符是否在某个位置上出现过，没有出现过才进行递归。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str[0...i-1]都已经做好决定了</span></span><br><span class="line"><span class="comment">//str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">//i为终止位置，str当前的位置就是一种结果-&gt;res</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArrayList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有终止，那么i之后位置上的字符都可以来到i位置上</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; <span class="built_in">str</span>.length; j ++)&#123;</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		process(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> swap(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] temp = <span class="built_in">str</span>[i];</span><br><span class="line">	<span class="built_in">str</span>[i] = <span class="built_in">str</span>[j];</span><br><span class="line">	<span class="built_in">str</span>[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串的所有排序方式，没有重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArratList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">boolean</span>[] visit = <span class="keyword">new</span> <span class="built_in">boolean</span>[<span class="number">26</span>];<span class="comment">//26个字母，当前位置，不与其他位置共享</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;<span class="built_in">str</span>.length; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">false</span>)&#123;</span><br><span class="line">			visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">			process2(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span>[] radixSort(<span class="built_in">int</span>[] arr， <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">	<span class="built_in">int</span>[] <span class="built_in">count</span> = new <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">len</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> division = (<span class="built_in">int</span>)Math.pow(<span class="number">10</span>,i);</span><br><span class="line">		for(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[j]/division%<span class="number">10</span>;</span><br><span class="line">			<span class="built_in">count</span>[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> m=<span class="number">1</span>; m&lt;count.length;m++)&#123;</span><br><span class="line">			<span class="built_in">count</span>[m] = <span class="built_in">count</span>[m] + <span class="built_in">count</span>[m-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> <span class="built_in">n</span>=arr.length-<span class="number">1</span>;<span class="built_in">n</span>&gt;=<span class="number">0</span>;<span class="built_in">n</span>--)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[<span class="built_in">n</span>] / division % <span class="number">10</span>;</span><br><span class="line">			result[<span class="built_in">count</span>[num]]=arr[<span class="built_in">n</span>];</span><br><span class="line">			<span class="built_in">count</span>[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		Arrays.fill(<span class="built_in">count</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>printAllSubSquence</title>
    <url>/2020/12/27/PrintAllSubsquences/</url>
    <content><![CDATA[<h4 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h4><hr>
<pre><code>从左往右的尝试模型，从0位置出发，依次判断每个位置的字符是否选择，当index到达字符串末尾时，将所形成的字符
path加入结果的集合中。</code></pre>
<hr>
<a id="more"></a>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subs(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	List&lt;<span class="keyword">String</span>&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	process1(<span class="built_in">str</span>, <span class="number">0</span>, ans, path);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str固定参数</span></span><br><span class="line"><span class="comment">//index，此时进行判断的位置下标，要 or 不要</span></span><br><span class="line"><span class="comment">//如果index来到str的终止位置，就把沿途路径所形成的答案放在ans中</span></span><br><span class="line"><span class="comment">//之前做出的选择就是path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, List&lt;<span class="keyword">String</span>&gt; ans, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		ans.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一个字符串的全部子序列，且要求不要重复出现的子序列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subsNoRepeate(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	process2(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">set</span>, path);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span>, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="built_in">set</span>.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotMove</title>
    <url>/2020/12/27/RobotMove/</url>
    <content><![CDATA[<h4 id="机器人的移动问题"><a href="#机器人的移动问题" class="headerlink" title="机器人的移动问题"></a>机器人的移动问题</h4><pre><code>假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个）。
如果机器人来打1位置上，那么下一步一定只能往右走来打2位置；如果机器人来到N位置，那么下一步只能往左来到N-1
的位置；如果机器人来打中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也
是1~N中的一个）的方法有多少种，给定四个参数N、M、K、P，返回方法数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//总共N个位置，从M点出发，还剩K步，返回最终能到达P的方法数</span></span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, M, K, P)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N:位置1~N，固定参数</span></span><br><span class="line"><span class="comment">//cur:当前在cur位置，可变参数</span></span><br><span class="line"><span class="comment">//rest:剩余的步数，可变参数</span></span><br><span class="line"><span class="comment">//P：最终的目标位置</span></span><br><span class="line"><span class="comment">//该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果没有剩余步数了，当前的cur位置就是最后的位置</span></span><br><span class="line">    <span class="comment">//如果最后的位置停在P上，那么之前做的移动是有效的</span></span><br><span class="line">    <span class="comment">//如果最后的位置没在P上，那么之前做的移动式无效</span></span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> cur==P ? <span class="number">1</span> : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span></span><br><span class="line">    <span class="comment">//后续的过程就是，来到2位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, <span class="number">2</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span></span><br><span class="line">	<span class="comment">//后续的过程就是，来到N-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以想左也可以向右</span></span><br><span class="line">    <span class="comment">//走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">//走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P) + walk(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">waysCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;=N; row++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;=K;col++)&#123;</span><br><span class="line">			dp[row][col]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walkCache</span><span class="params">(N, M, K, P, dp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表方法，把cur和rest所有方法加入到缓存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walkCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[cur][rest]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		dp[cur][rest] = cur == P ? <span class="number">1</span> : 0;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, <span class="number">2</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[cur][rest] = walkCache(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P, dp) + walkCache(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">	<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">dpWays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	dp[P][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//dp[!P][...]=0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= K; rest++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">1</span>; cur &lt;= N; cur++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">				dp[cur][rest] = dp[<span class="number">2</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(cur==N)</span></span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[N<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[cur+<span class="number">1</span>][rest<span class="number">-1</span>]+dp[cur<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[M][P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2021/03/25/mysql/</url>
    <content><![CDATA[<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5之前）。虽然性能极佳，而且提供大量的特性，包括全文索引、压缩、空间函数等，单MyISAM不支持事务和行级锁，最大的缺陷就是崩溃后无法安全回复。不过，5.5版本之后，MySQL引入了InnoDB（事务性性数据库引擎），MySQL5.5版本后默认的引擎为InnoDB。</p>
<a id="more"></a>
<p>大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用MyISAM也是合适的比如读密集的情况下。（如果不介意崩溃恢复的问题）。</p>
<p><strong>两者的对比</strong></p>
<ol>
<li><strong>是否支持行级锁</strong>：MyISAM只有表级锁（table-level locking）,而InnoDB支持行级锁（row-level locking）和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持，外部键等高级数据库功能。具有事务（commit）、回滚（rollback）和崩溃修复能力和事务安全型表。</li>
<li><strong>是否支持外键</strong>：MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong>：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在READ COMMITTED和REPEATABLE READ 两个隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现；各数据库中MVCC实现并不统一。</li>
</ol>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong>和<strong>哈希索引</strong>。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议使用BTree索引。</p>
<p>MySQL的BTree索引使用的是B+Tree，但是对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM</strong>：B+Tree叶节点的data域存放的数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB</strong>：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务时逻辑上的一组操作，要么执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说的例子就是转账。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的月增加1000元。万一这两个操作之间突然出现错误比如银行系统崩溃，导致小明的余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都失败。</p>
<h4 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h4><ul>
<li><strong>原子性（Atomicity）</strong>：事务时最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）</strong>：执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务干扰，个并发事务之间的数据库是独立的；</li>
<li><strong>持久性（Durability）</strong>：一个事务被提交之后。它对数据库中数据的改变是永久的，即使数据库发生故障也不应对其有任何影响。</li>
</ul>
<h4 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个任务对同一数据操作）。并发虽然是必须的，单可能会导致以下问题。</p>
<ul>
<li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到这个数据是“脏数据”，一句脏数据所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）</strong>：指在一个事务内多次读取数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内修改结果就被丢失，因此称丢失修改。</li>
<li><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问了该数据。那么第一个事务两次读取的数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据可能不一样的情况，依次称为不可重读。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本根本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="事务隔离级别有哪些？MySQL的默认隔离级别是？"><a href="#事务隔离级别有哪些？MySQL的默认隔离级别是？" class="headerlink" title="事务隔离级别有哪些？MySQL的默认隔离级别是？"></a>事务隔离级别有哪些？MySQL的默认隔离级别是？</h4><p><strong>SQL标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，</strong>可能会导致脏读、幻读或不可重复读。**</li>
<li><strong>READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，</strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。**</li>
<li><strong>REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，</strong>可以阻止脏读和不可重复读，但是幻读仍有可能发生。**</li>
<li><strong>SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说该级别</strong>可以防止脏读、不可重复读以及幻读。**</li>
</ul>
<p><strong>InnoDB引擎默认支持的隔离级别是REPEATABLE-READ（可重复读</strong>）。与SQL标准不同的地方在于，InnoDB在可重读事务隔离级别下使用的是<strong>Next-key Lock</strong>锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以锁InnoDB存储引擎的默认支持隔离级别已经完全可以保证事务的隔离性要求，即达到了SQL标准的<strong>SERIALIZABLE</strong>隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取已提交)**，但是需要知道的是InnoDB存储引擎默认使用</strong>REPEATABLE-READ（可重复读**）不会有任何性能损失。</p>
<p><strong>InnoDB引擎</strong>在分布式事务的情况下会用到<strong>SERIALIZABLE</strong>（可串行化）隔离级别。</p>
<h4 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h4><p><strong>MyISAM与InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁；</li>
<li>InnoDB采用行级锁和表级锁，默认使用行级锁。</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁</strong>：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和MySQL都是支持表级锁。</li>
<li><strong>行级锁</strong>：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种</strong>：</p>
<ul>
<li>Record　lock：单个行记录上的锁；</li>
<li>Gap　lock：间隙锁，锁定一个范围，不包括记录本省</li>
<li>Next-Key　lock：record＋Gap　锁定一个范围，包含巨鹿本身。</li>
</ul>
<p><strong>相关知识点</strong>：</p>
<ol>
<li>InnoDB对于行的查询使用了next-key lock</li>
<li>next-key lock为了解决幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显示关闭gap锁：A.将事务隔离级别设置为RC B.将参数innodb_lock_unsafe_for_binlog设置为1</li>
</ol>
<h4 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<p>1.<strong>限定数据范围</strong></p>
<p>务必禁止不带任何限制数据范围条件的查询语句。</p>
<p>2.<strong>读/写分离</strong></p>
<p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<p>3.<strong>垂直分区</strong></p>
<p>简单来说垂直分区是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><strong>垂直拆分的优点</strong>：可以使得列数据变小，在查询时减少读取的Block数，减少I/o次数。此外，垂直分区可以简化表结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起join操作，可以通过应用层进行Join来解决。此外，垂直分区会让事务变得更复杂。</p>
<p>4.<strong>水平分区</strong></p>
<p>保持表的结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对</p>
<p>于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。</p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。<strong>尽量不要对数据分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong>，一般数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少和中间件的网络I/O。</p>
<p><strong>下面补充一下数据库分片的两种常见方案</strong>：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常见的实现。</strong></li>
<li><strong>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的MyCat、260的Atlas、网易的DDB等等都是这种架构。</strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/12/28/SnackWays/</url>
    <content><![CDATA[<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><pre><code>背包容量为w，一共有n袋零食，第i袋零食体积为v[i], 总体积不超过背包容量的
情况下，一共有多少种零食方法？（总体积为0也算一种方法）</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> nums(<span class="built_in">int</span>[] v, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == <span class="literal">null</span> || v.length==<span class="number">0</span> || w &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(v, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//rest&gt;=0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的零食</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>]=&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		p2 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest-arr[<span class="keyword">index</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span> || w&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][w+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest&lt;=w; rest++)&#123;</span><br><span class="line">		dp[N][rest] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N<span class="number">-1</span>; <span class="keyword">index</span> &lt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest &lt;= w; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line">			<span class="keyword">if</span>(rest-arr[<span class="keyword">index</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QucikSort</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">		int[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		<span class="built_in">sort</span>(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		<span class="built_in">print</span>(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">sort</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		int mid = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);<span class="comment">//获取pivot的位置</span></span><br><span class="line">		<span class="built_in">sort</span>(arr,<span class="keyword">left</span>,mid-<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,<span class="keyword">right</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int start, int end)&#123;</span><br><span class="line">		int <span class="keyword">left</span> = start;</span><br><span class="line">		int <span class="keyword">right</span> = end - <span class="number">1</span>;</span><br><span class="line">		int pivot = arr[end];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">left</span>]&lt;=pivot)<span class="keyword">left</span>++;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">right</span>]&gt;pivot)<span class="keyword">right</span>--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)<span class="built_in">swap</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(arr, <span class="keyword">left</span>, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">print</span>(int[] arr)&#123;</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="type">System</span>.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">			h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">//初始化gap的方法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap=h;gap&gt;<span class="number">0</span>;gap=(gap<span class="number">-1</span>)/<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;gap<span class="number">-1</span>;j-=gap)&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		arr[i] = arr[j] + arr[i];</span><br><span class="line">		arr[j] = arr[i] - arr[j];</span><br><span class="line">		arr[i] = arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> boolean exist(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">num</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="comment">//防止溢出</span></span><br><span class="line">	  mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">if</span>(arr[mid]==<span class="built_in">num</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;<span class="built_in">num</span>) right = mid - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">else</span> left = left + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid] == <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static <span class="built_in">int</span> nearestIndex(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">value</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">index</span> = -<span class="number">1</span>;//记录最左侧的下标</span><br><span class="line">	while(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span> - <span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;=<span class="built_in">value</span>)&#123;</span><br><span class="line">			<span class="built_in">index</span> = <span class="built_in">mid</span>;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">index</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> getLessIndex(<span class="built_in">int</span>[] arr)&#123;</span><br><span class="line">	<span class="built_in">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>])&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr[arr.length - <span class="number">2</span>] &gt; arr[arr.length - <span class="number">1</span>])&#123;</span><br><span class="line">		return arr.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	while(<span class="built_in">left</span>&lt;<span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span>-<span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else <span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> + <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4><a id="more"></a>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PrintTreeTest &#123;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">class</span> Node&#123;</span><br><span class="line">        <span class="built_in">int</span> value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="constructor">Node(<span class="params">int</span> <span class="params">v</span>)</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">Tree(Node <span class="params">head</span>)</span>&#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Binary Tree&quot;</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>, 0, <span class="string">&quot;H&quot;</span>, 17)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">InOrder(Node <span class="params">head</span>, <span class="params">int</span> <span class="params">height</span>, String <span class="params">to</span>, <span class="params">int</span> <span class="params">len</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head<span class="operator"> == </span>null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">right</span>, <span class="params">height</span>+1, <span class="string">&quot;v&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        String <span class="keyword">val</span> = <span class="keyword">to</span> + head.value + <span class="keyword">to</span>;</span><br><span class="line">        <span class="built_in">int</span> lenM = <span class="keyword">val</span>.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> lenL = (len - lenM)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        <span class="keyword">val</span> = get<span class="constructor">Space(<span class="params">lenL</span>)</span> + <span class="keyword">val</span> +get<span class="constructor">Space(<span class="params">lenR</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(get<span class="constructor">Space(<span class="params">height</span><span class="operator">*</span><span class="params">len</span>)</span> + <span class="keyword">val</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">left</span>, <span class="params">height</span>+1, <span class="string">&quot;^&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String get<span class="constructor">Space(<span class="params">int</span> <span class="params">num</span>)</span>&#123;</span><br><span class="line">        String space = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        return buf.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="返回二叉树中指定节点的后续节点"><a href="#返回二叉树中指定节点的后续节点" class="headerlink" title="返回二叉树中指定节点的后续节点"></a>返回二叉树中指定节点的后续节点</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">	int</span> value;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">left</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">right</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">parent</span>;</span><br><span class="line">	<span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在中序遍历中的后继节点</span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getSuccessorNode</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node.right!=null)&#123;</span><br><span class="line">		return getLeftMost(node.right);</span><br><span class="line">	&#125;else&#123;//无右子树</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">parent</span> = node.parent;</span><br><span class="line">		while(parent != null &amp;&amp; parent.left != <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">			node</span> = parent;</span><br><span class="line">			parent = node.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getLeftMost</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	&#125;</span></span><br><span class="line"><span class="title">	while</span>(node.left!=null)&#123;</span><br><span class="line">		<span class="keyword">node</span> <span class="title">= node</span>.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="纸对折，依次输出折痕的方向"><a href="#纸对折，依次输出折痕的方向" class="headerlink" title="纸对折，依次输出折痕的方向"></a>纸对折，依次输出折痕的方向</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归过程</span></span><br><span class="line"><span class="comment">//i是节点的层数，N一共的层数，down==true凹 down==false凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(down ? <span class="string">&quot;凹&quot;</span> : <span class="string">&quot;凸&quot;</span>);</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanced</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">			value = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">		<span class="keyword">boolean</span> isBalanced;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">			isBalanced = h;</span><br><span class="line">			<span class="built_in">height</span> = h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">		Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span> = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isBalanced = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Math.<span class="built_in">abs</span>(leftInfo.<span class="built_in">height</span> - rightInfo.<span class="built_in">height</span> &lt;<span class="number">2</span>)	&amp;&amp; leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced)&#123;</span><br><span class="line">			isBalanced = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, <span class="built_in">height</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">process</span>(head).isBalanced;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"><a href="#给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）" class="headerlink" title="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"></a>给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(head).distacne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">		distance = d;</span><br><span class="line">		<span class="built_in">height</span> = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意思考结果的可能性，常见的就是结果与当前节点有关和无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">	Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> heigth = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> distance = Math.<span class="built_in">max</span>(</span><br><span class="line">		Math.<span class="built_in">max</span>(leftInfo.distance, rightInfo.distance), </span><br><span class="line">		leftInfo.<span class="built_in">height</span>+rightInfo.<span class="built_in">height</span>+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(distance, <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点</h4><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> data)&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node getMaxSubBalancedTree(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process(head).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	<span class="built_in">boolean</span> isAllBST;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span>;</span><br><span class="line">	Node head;</span><br><span class="line">	<span class="keyword">public</span> Info(<span class="built_in">boolean</span> is, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span> mi, <span class="built_in">int</span> ma, Node h)&#123;</span><br><span class="line">		isAllBST = is;</span><br><span class="line">		maxSubSize = <span class="built_in">size</span>;</span><br><span class="line">		<span class="built_in">min</span> = mi;</span><br><span class="line">		<span class="built_in">max</span> = ma;</span><br><span class="line">		head = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Info process(Node X)&#123;</span><br><span class="line">	<span class="keyword">if</span>(X==<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = process(X.left);</span><br><span class="line">	Info rightInfo = process(X.right);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span> = X.value;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span> = X.value;</span><br><span class="line">	Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, leftInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, leftInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, rightInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, rightInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可能性1，与x节点无关</span></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = leftInfo.maxSubSize;</span><br><span class="line">		head = leftInfo.head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = Math.<span class="built_in">max</span>(maxSubSize, rightInfo.maxSubSize);</span><br><span class="line">		<span class="keyword">if</span>(maxSubSize&lt;rightInfo.maxSubSize)&#123;</span><br><span class="line">			head = rightInfo.head;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST) &amp;&amp; </span><br><span class="line">		(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST) &amp;&amp;</span><br><span class="line">		(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.<span class="built_in">max</span> &lt; X.value) &amp;&amp;</span><br><span class="line">		(right == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.<span class="built_in">min</span> &gt; X.value))&#123;</span><br><span class="line"></span><br><span class="line">			maxSubSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize) + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">			isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			head = X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubSize, <span class="built_in">min</span>, <span class="built_in">max</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="派对的快乐值"><a href="#派对的快乐值" class="headerlink" title="派对的快乐值"></a>派对的快乐值</h4><pre><code>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。数的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些不来，规则：
1.如果某员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</code></pre>
<hr>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee&#123;</span><br><span class="line">	<span class="built_in">public</span> happy;</span><br><span class="line">	<span class="built_in">public</span> List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> Employee(<span class="type">int</span> h)&#123;</span><br><span class="line">		happy = h;</span><br><span class="line">		nexts = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> maxHappy(Employee boss)&#123;</span><br><span class="line">	<span class="keyword">if</span>(boss == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">Info</span> <span class="keyword">all</span> = process(boss);</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="keyword">all</span>.yes, <span class="keyword">all</span>.<span class="keyword">no</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Info</span>&#123;</span><br><span class="line">	<span class="type">int</span> yes;//x来情况下的最大happy</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span>;//x不来情况下的最大happy</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Info</span>(<span class="type">int</span> y, <span class="type">int</span> n)&#123;</span><br><span class="line">		yes = y;</span><br><span class="line">		<span class="keyword">no</span> = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">Info</span> process(Employee x)&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.nexts.isEmpty)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(x.happy, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> yes = x.happy;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(Employee next : x.nexts)&#123;</span><br><span class="line">		<span class="keyword">Info</span> nextInfo = process(next);</span><br><span class="line">		yes += nextInfo.<span class="keyword">no</span>;</span><br><span class="line">		<span class="keyword">no</span> += Math.max(nextInfo.yes,nextInfo.<span class="keyword">no</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(yes, <span class="keyword">no</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Node1</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(<span class="built_in">int</span> value)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">in</span>(head.left);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">in</span>(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Satck&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			head = stack.pop();</span><br><span class="line">			System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		s1.push(head);</span><br><span class="line">		<span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">			head = s1.pop();</span><br><span class="line">			s2.push(head);</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">				s1.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.print(s2.pop().value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用一个栈实现非递归的后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos2</span>(<span class="params">Node1 h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h != <span class="literal">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node1 c = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(c.left != <span class="literal">null</span> &amp;&amp; h!=c.left &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.right != <span class="literal">null</span> &amp;&amp; h!=c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(stack.pop()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                h=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历，非递归方法</span></span><br><span class="line"><span class="comment">//1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in1</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty() || head!=<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">				stack.push(head);</span><br><span class="line">				head = head.left;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				head = stack.pop();</span><br><span class="line">				System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">				head = head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现二叉树的按层遍历</span></span><br><span class="line"><span class="comment"> * 1）其实就是宽度优先遍历，用队列</span></span><br><span class="line"><span class="comment"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWithUseMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	levelMap.<span class="built_in">put</span>(head, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> curLevel = <span class="number">1</span>;<span class="comment">//当前正在统计哪一层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">int</span> curNodeLevel = levelMap.<span class="built_in">get</span>(cur);</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.left, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.right, curLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span></span><br><span class="line">		<span class="keyword">if</span>(curNodeLevel == curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">max</span> = <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，不使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	Node1 curEnd = head;<span class="comment">//当前层，最右节点</span></span><br><span class="line">	Node1 nextEnd = head;<span class="comment">//下一层，最右节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的节点数</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">			nextEnd = cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">			nextEnd = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		<span class="keyword">if</span>(cur == curEnd)&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevelNodes = <span class="number">0</span>;</span><br><span class="line">			curEnd = nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历序列化与重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">preSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">	Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pres</span>(<span class="params">Node head, Queue&lt;<span class="built_in">String</span>&gt; ans</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		ans.add(<span class="literal">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByPreQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prelist == <span class="literal">null</span> || prelist.size()==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">preb</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">String</span> value = prelist.poll();</span><br><span class="line">	<span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">	head.left = preb(prelist);</span><br><span class="line">	head.right = preb(prelist);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">levelSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">    Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        ans.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByLevelQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; levelList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(levelList == <span class="literal">null</span> || levelList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNode(levelList.poll());</span><br><span class="line">        node.right = generateNode(levelList.poll());</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="function"><span class="title">generateNode</span>(<span class="params"><span class="built_in">String</span> val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MergeSort&#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args)&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		sort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> sort(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(start==<span class="keyword">end</span>)<span class="keyword">return</span>;</span><br><span class="line">		//分成两块</span><br><span class="line">		<span class="type">int</span> mid = <span class="keyword">start</span> + (<span class="keyword">end</span> - <span class="keyword">start</span>)/<span class="number">2</span>;</span><br><span class="line">		//左边排序</span><br><span class="line">		sort(arr, <span class="keyword">start</span>, mid);</span><br><span class="line">		//右边排序</span><br><span class="line">		sort(arr, mide + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">		merge(arr, <span class="keyword">start</span>, mid + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)&#123;</span><br><span class="line">		<span class="type">int</span> i = left;</span><br><span class="line">		<span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt;= arr[j])<span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="keyword">temp</span>.length; m++)&#123;</span><br><span class="line">			arr[left+m] = <span class="keyword">temp</span>[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，只有一种数出现了奇数次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> eor = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.<span class="keyword">out</span>.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，有两种数出现了两次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// eor = a^b</span></span><br><span class="line">	<span class="comment">// eor != 0</span></span><br><span class="line">	<span class="comment">// eor必然有一个位置是1</span></span><br><span class="line">	<span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>)&#123;</span><br><span class="line">			onlyOne ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="built_in">println</span>(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有3个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		stack.<span class="keyword">push</span>(cur);</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.value != stack.<span class="keyword">pop</span>().value)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head = head.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//need o(1) extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome2(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 = head;</span><br><span class="line">	NOde n2 = head;</span><br><span class="line">	<span class="keyword">while</span>(n2.<span class="keyword">next</span>!= <span class="keyword">null</span> &amp;&amp; n2.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>;<span class="comment">//n1-&gt;mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>.<span class="keyword">next</span>;<span class="comment">//n2-&gt;end</span></span><br><span class="line">	&#125;</span><br><span class="line">	n2 = n1.<span class="keyword">next</span>;<span class="comment">//n2-&gt;right part first node</span></span><br><span class="line">	n1.<span class="keyword">next</span> = <span class="keyword">null</span>;<span class="comment">//mid.next-&gt;null</span></span><br><span class="line">	Node n3 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n2!=<span class="keyword">null</span>)&#123;<span class="comment">//right part convert</span></span><br><span class="line">		n3 = n2.<span class="keyword">next</span>;<span class="comment">//n3-&gt;save the node</span></span><br><span class="line">		n2.<span class="keyword">next</span> = n1;<span class="comment">//next of right node convert</span></span><br><span class="line">		n1 = n2;<span class="comment">//n1 move</span></span><br><span class="line">		n2 = n3;<span class="comment">//n2 move</span></span><br><span class="line">	&#125;</span><br><span class="line">	n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">	n2 = head; <span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">	<span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2!= <span class="keyword">null</span>)&#123; <span class="comment">// check palindrome</span></span><br><span class="line">		<span class="keyword">if</span>(n1.value != n2.value)&#123;</span><br><span class="line">			res = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>; <span class="comment">// left to mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>; <span class="comment">// right to mid</span></span><br><span class="line">	&#125;</span><br><span class="line">	n1 = n3.<span class="keyword">next</span>;</span><br><span class="line">	n3.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">		n2 = n1.<span class="keyword">next</span>;</span><br><span class="line">		n1.<span class="keyword">next</span> = n3;</span><br><span class="line">		n3 = n1;</span><br><span class="line">		n1 = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node listPartition1(Node head, <span class="built_in">int</span> piovt)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i!=nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] = cur;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i != nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> arrPartition(Node[] nodeArr, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	<span class="built_in">int</span> samll = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">int</span> big = nodeArr.length;</span><br><span class="line">	<span class="built_in">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">index</span>!=big)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,<span class="keyword">index</span>++);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value==piovt)&#123;</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(nodeArr, --big, <span class="keyword">index</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试方法</span></span><br><span class="line"><span class="keyword">public</span> Node listPartition2(Node head, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	Node sH = <span class="literal">null</span>;<span class="comment">//small head</span></span><br><span class="line">	Node sT = <span class="literal">null</span>;<span class="comment">//samll tail</span></span><br><span class="line">	Node eH = <span class="literal">null</span>;<span class="comment">//equal head</span></span><br><span class="line">	Node eT = <span class="literal">null</span>;<span class="comment">//equal tail</span></span><br><span class="line">	Node mH = <span class="literal">null</span>;<span class="comment">//big head</span></span><br><span class="line">	Node MT = <span class="literal">null</span>;<span class="comment">//big tail</span></span><br><span class="line">	Node <span class="keyword">next</span> = <span class="literal">null</span>;<span class="comment">//save the node</span></span><br><span class="line">	<span class="comment">//every node distributed to three lists</span></span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(head.value &lt; pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sH == <span class="literal">null</span>)&#123;</span><br><span class="line">				sH = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				sT.<span class="keyword">next</span> = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(eH == <span class="literal">null</span>)&#123;</span><br><span class="line">				eH = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				eT.<span class="keyword">next</span> = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mH == <span class="literal">null</span>)&#123;</span><br><span class="line">				mH = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				mT.<span class="keyword">next</span> = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head = <span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//小于区域的尾巴，连等于区域的头，等于区域的尾巴</span></span><br><span class="line">	<span class="keyword">if</span>(sT!=<span class="literal">null</span>)&#123;<span class="comment">//如果有小于区域</span></span><br><span class="line">		sT.<span class="keyword">next</span> = eH;</span><br><span class="line">		eT = eT == <span class="literal">null</span> ? sT : eT;<span class="comment">//下一步，谁去连大于区域的头</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的if，不管跑了没有，et</span></span><br><span class="line">	<span class="comment">//all reconnect</span></span><br><span class="line">	<span class="keyword">if</span>(et!=<span class="literal">null</span>)&#123;</span><br><span class="line">		eT.<span class="keyword">next</span> = mH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="一种特殊的单链表节点描述一下"><a href="#一种特殊的单链表节点描述一下" class="headerlink" title="一种特殊的单链表节点描述一下"></a>一种特殊的单链表节点描述一下</h4><pre><code>class Node&#123;
    int value;
    Node next;
    Node rand;
    Node(int val)&#123;
        value = val;
    &#125;
&#125;
rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</code></pre>
<hr>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">//笔试方法，使用HashMap</span></span><br><span class="line">public Node copyListWithRand1(Node head)&#123;</span><br><span class="line">	HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="built_in">null</span>)&#123;</span><br><span class="line">		map.put(cur, new Node(cur.<span class="built_in">value</span>));</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老节点</span></span><br><span class="line">		<span class="comment">//map.get(cur)新节点</span></span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">next</span> = map.<span class="built_in">get</span>(cur.<span class="built_in">next</span>);</span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">rand</span> = map.<span class="built_in">get</span>(<span class="built_in">cut</span>.<span class="built_in">rand</span>);</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp.<span class="built_in">get</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试用的方法</span></span><br><span class="line">public Node copyListWithRand2(Node head)&#123;</span><br><span class="line">	if(head == <span class="built_in">null</span>)&#123;</span><br><span class="line">		return <span class="built_in">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	Node <span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//copy node and link to every node</span></span><br><span class="line">	<span class="comment">//1-&gt;2</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = new Node(cur.<span class="built_in">value</span>);</span><br><span class="line">		cur.<span class="built_in">next</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	Node curCopy = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//set copy node rand</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2-&gt;2&#x27;</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老</span></span><br><span class="line">		<span class="comment">//cur.next 新 copy</span></span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">rand</span> = cur.<span class="built_in">rand</span> != <span class="built_in">null</span> ? cur.<span class="built_in">rand</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node res = head.<span class="built_in">next</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="comment">// split</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">next</span> = <span class="built_in">next</span> != <span class="built_in">null</span> ? <span class="built_in">next</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两个可能有环链表的交点"><a href="#两个可能有环链表的交点" class="headerlink" title="两个可能有环链表的交点"></a>两个可能有环链表的交点</h4><hr>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">head</span> = new <span class="keyword">Node</span><span class="title">(1</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node2</span> = new <span class="keyword">Node</span><span class="title">(2</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node3</span> = new <span class="keyword">Node</span><span class="title">(3</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node4</span> = new <span class="keyword">Node</span><span class="title">(4</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node5</span> = new <span class="keyword">Node</span><span class="title">(5</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node6</span> = new <span class="keyword">Node</span><span class="title">(6</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node7</span> = new <span class="keyword">Node</span><span class="title">(7</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node8</span> = new <span class="keyword">Node</span><span class="title">(8</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node9</span> = new <span class="keyword">Node</span><span class="title">(9</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node10</span> = new <span class="keyword">Node</span><span class="title">(10</span>);</span><br><span class="line"></span><br><span class="line">        head.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        node7.next = node8;</span><br><span class="line">        node8.next = node9;</span><br><span class="line">        node9.next = node10;</span><br><span class="line">        node10.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span> <span class="title">crossNode</span> = getLoopNode(head);</span><br><span class="line">        System.out.println(crossNode.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getIntersection</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || <span class="attr">head2=</span>=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop1</span> = getLoopNode(head1);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop2</span> = getLoopNode(head2);</span><br><span class="line">        if(<span class="attr">loop1=</span>=null &amp;&amp; <span class="attr">loop2=</span>=null)&#123;</span><br><span class="line">            return noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(loop1!=null &amp;&amp; loop2!=null)&#123;</span><br><span class="line">            return  bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一个链表第一个入环的节点</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getLoopNode</span>(<span class="keyword">Node</span> <span class="title">head</span>)&#123;</span><br><span class="line">        if(head ==null || head.next ==null || head.next.next == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // n1 慢 n2 快</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n1</span> = head.next; //n1-&gt;slow</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n2</span> = head.next.next; //n2-&gt;fast</span><br><span class="line">        while(n1 != n2)&#123;</span><br><span class="line">            if(n2.next == null || n2.next.next == null)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head;  //n2-&gt;walk again from head</span><br><span class="line">        while(n1!=n2)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果两个无环链表相交返回第一个相交的节点，如果不相交返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">noLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || head2 == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = head1;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = head2;</span><br><span class="line">        int n = <span class="number">0</span>;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur1 != cur2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //n : 链表<span class="number">1</span>的长度减去链表<span class="number">2</span>的长度</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; //长的变为cur1</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //两个链表都有环，返回第一个相交的节点，不相交则返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">bothLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">loop1</span>, <span class="keyword">Node</span> <span class="title">head2</span>, <span class="keyword">Node</span> <span class="title">loop2</span>)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = null;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = null;</span><br><span class="line">        if(loop1 == loop2)&#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            int n = <span class="number">0</span>;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur2!=loop2)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 :head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur1!=cur2)&#123;</span><br><span class="line">                <span class="attr">cur1=</span> cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                if(cur1 == loop2)&#123;</span><br><span class="line">                    return loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">					arr[j<span class="number">-1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> minPos = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = temp;</span><br><span class="line">			arr[minPos] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的扩容机制和底层源码</title>
    <url>/2021/03/27/HashMap/</url>
    <content><![CDATA[<h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p>
<p>JDK1.8之前HashMap由<strong>数组+链表（1.7）</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</p>
<p>JDK1.8之后HashMap的组成多了红黑树，在满足下面两个条件后，会执行链表转换为红黑树操作，依次来加快搜索速度。</p>
<ul>
<li>链表长度大于阈值（默认为8）</li>
<li>HashMap数组长度超过64</li>
</ul>
<h4 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h4><h5 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a><strong>JDK1.8之前</strong></h5><p>JDK1.8之前HashMap底层是<strong>数组+链表</strong>结合在一起使用也就是<strong>链表散列</strong>。</p>
<p>HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过**(n-1) &amp; hash**判断当前元素存放的位置（n为数组长度），如果当前位置存在元素的话，就判断该元素与要存入元素的hash值以及key是否相同，如果相同，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK1.8 HashMap的hash方法源码：</strong></p>
<p>JDK1.8的hash方法 相比于JDK１.７方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// key.hashCode():返回散列值也就是hashCode</span></span><br><span class="line">    <span class="comment">// ^:按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key==<span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下JDK１.７的HashMap的hash方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于JDK１.８的hash方法，JDK1.7的hash方法的性能稍微会差一点，因为毕竟扰动了4次。</p>
<p>所谓“拉链法”就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一个就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="D:\blog\imge\jdk1.8之前的内部结构.png"></p>
<h5 id="JDK１-８之后"><a href="#JDK１-８之后" class="headerlink" title="JDK１.８之后"></a>JDK１.８之后</h5><p>相比于之前的版本，JDK１.８以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为８）时，会首先调用　treeifyBIn() 的方法。这个方法会根据HashMap数组来决定是否转换为红黑树。只有当数组长度大于或者等于64的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行resize() 方法对数组扩容。</p>
<p><img src="D:\blog\imge\up-bba283228693dae74e78da1ef7a9a04c684.png"></p>
<p><strong>类的属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loadFactor 加载因子</strong></li>
</ul>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据（entry）也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<ul>
<li><strong>threshold</strong></li>
</ul>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
<p><strong>Node节点源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树节点类源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><p>HashMap中有四个构造方法，它们分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a><strong>putMapEntries方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h5><p>HashMap只是提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对putVal方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素，就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不同，就判断p是否为一个树节点，如果是就调用 <code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加进入。如果不是就遍历链表插入（插入的是链表尾部）。</li>
</ol>
<p><img src="D:\blog\imge\put方法.png"></p>
<p>说明：上图有两个小问题：</p>
<ul>
<li>直接覆盖之后就会return，不会有后续操作。</li>
<li>当链表长度大于阈值（默认为8）并且HashMap数组长度超过64的时候才会执行链表转化为红黑树的操作，否则就只是对数组的扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来对比一下JDK1.7 put代码方法的代码</strong></p>
<p><strong>对比put方法的分析如下：</strong></p>
<ul>
<li>如果定位的数组位置没有元素就直接插入</li>
<li>如果定位的数组位置有元素，遍历这个元素为头节点的链表，依次和插入的key比较，如果相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123;</span><br><span class="line">    	inflateTable(threshold);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>进行扩容，会伴随着一次重新分配hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编程中，要尽量避免resize.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
