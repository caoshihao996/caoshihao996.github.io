<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2021/03/19/BinaryTreeLayer/</url>
    <content><![CDATA[<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;<span class="type">Integer</span>&gt; PrintFromTopToBottom(TreeNode root)&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;<span class="type">Integer</span>&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			ret.<span class="keyword">add</span>(t.val);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.left);</span><br><span class="line">			ret.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h4 id="二叉树的多行遍历"><a href="#二叉树的多行遍历" class="headerlink" title="二叉树的多行遍历"></a>二叉树的多行遍历</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; ret = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	queue.<span class="keyword">add</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> cnt = queue.size();</span><br><span class="line">		<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">			TreeNode t = queue.poll();</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			list.<span class="keyword">add</span>(t.val);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.lef);</span><br><span class="line">			queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">			ret.<span class="keyword">add</span>(list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt;&gt; Print(TreeNode root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	ArrayList&lt;ArrayList&lt;<span class="type">Integer</span>&gt; &gt; ret = <span class="built_in">new</span> ArrayList;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.<span class="keyword">add</span>(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="keyword">reverse</span> = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    	ArrayList&lt;<span class="type">Integer</span>&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> cnt = queue.size();</span><br><span class="line">    	<span class="keyword">while</span>(cnt<span class="comment">--&gt;0)&#123;</span></span><br><span class="line">    		TreeNode t = queue.poll();</span><br><span class="line">    		<span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		list.<span class="keyword">add</span>(t.val);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.left);</span><br><span class="line">    		queue.<span class="keyword">add</span>(t.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="keyword">reverse</span>)</span><br><span class="line">    		Colllections.reverse(list);</span><br><span class="line">    	<span class="keyword">reverse</span>=!<span class="keyword">reverse</span>;</span><br><span class="line">    	<span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line">    		ret.<span class="keyword">add</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>广度优先遍历</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>CardInLine</title>
    <url>/2020/12/27/CardInLine/</url>
    <content><![CDATA[<h4 id="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"><a href="#玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值" class="headerlink" title="玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值"></a>玩家轮流拿两端的纸牌，问最后获胜者拿到派的最大值</h4><pre><code>给定一个整形数组arr，代表数值不同的纸牌拍成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后
拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都决定聪明。请问最后获胜者的分数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( L==R )&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(arr[L] + s(arr, L+<span class="number">1</span>, R), arr[R] + s(arr, L, R<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后手函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[L];</span><br><span class="line">	&#125;			<span class="comment">//先手函数选了arr[L]</span></span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">min</span>(f(arr, L+<span class="number">1</span>, R), f(arr, L, R<span class="number">-1</span>));<span class="comment">//对手会让你选择最小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>), s(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpWay</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr ==null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">	<span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; i++)&#123;</span><br><span class="line">		f[i][i] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//s[i][i]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = i;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;N &amp;&amp; R&lt;N)&#123;</span><br><span class="line">			f[L][R] = Math.<span class="built_in">max</span>(arr[L]+s[L+<span class="number">1</span>][R], arr[R]+s[L][R<span class="number">-1</span>]);</span><br><span class="line">			s[L][R] = Math.<span class="built_in">min</span>(arr[L]+f[L+<span class="number">1</span>][R], arr[R]+f[L][R<span class="number">-1</span>]);</span><br><span class="line">			L++;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(f[<span class="number">0</span>][N<span class="number">-1</span>], s[<span class="number">0</span>][N<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>ConvertToLetters</title>
    <url>/2020/12/27/ConvertToLetters/</url>
    <content><![CDATA[<h4 id="将数字转化为字母有多少种方法，从左往右的尝试模型"><a href="#将数字转化为字母有多少种方法，从左往右的尝试模型" class="headerlink" title="将数字转化为字母有多少种方法，从左往右的尝试模型"></a>将数字转化为字母有多少种方法，从左往右的尝试模型</h4><pre><code>规定1和A对应、2和B对应、3和C对应...的规则。那么一个数字字符串比如“111”就可以转化为AAA、KA、AK。给定一个只
有数字字符串组成的字符串str,返回有多少种转化结果。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> numbers(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span> == <span class="keyword">null</span> || <span class="built_in">str</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(<span class="built_in">str</span>.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str[0..i-1]已经转化完了，固定了</span></span><br><span class="line"><span class="comment">//返回值：从i开始到结尾有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> res = process1(<span class="built_in">str</span>, i+<span class="number">1</span>);<span class="comment">//i位置上字符视为一个单独的转换数字</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			rest += process(<span class="built_in">str</span>, i+<span class="number">2</span>);<span class="comment">//(i,i+1)两个位置上的字符视为一个整体</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str[i] == &#x27;3&#x27;~&#x27;9&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> process(<span class="built_in">str</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="built_in">int</span> N = <span class="built_in">str</span>.length;</span><br><span class="line">	<span class="built_in">int</span>[] dp = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>];</span><br><span class="line">	dp[N] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;<span class="built_in">str</span>.length &amp;&amp; <span class="built_in">str</span>[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">str</span>[i] &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">				dp[i] += dp[i+<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">public <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">	<span class="comment">//找出数组中最大值和最小值</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">max</span> = Integer.MIN_VALUE;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化计数数组count[]</span></span><br><span class="line">	<span class="comment">//长度为最大值减去最小值加1，再加1</span></span><br><span class="line">	<span class="type">int</span>[] <span class="built_in">count</span> = new <span class="type">int</span>[<span class="built_in">max</span>-<span class="built_in">min</span>+<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数，并确保count[0]永远为0</span></span><br><span class="line">	for(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">		<span class="built_in">count</span>[num-<span class="built_in">min</span>+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计数数组变形，新元素是的值是前面元素的累加之和的值</span></span><br><span class="line">	for(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">count</span>.length;i++)&#123;</span><br><span class="line">		<span class="built_in">count</span>[i] += <span class="built_in">count</span>[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建结果数组</span></span><br><span class="line">	<span class="type">int</span>[] result = new <span class="type">int</span>[arr.length];</span><br><span class="line">	<span class="comment">//遍历arr中的元素，填充到结果数组中去，从前往后遍历</span></span><br><span class="line">	for(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]] = arr[j];</span><br><span class="line">		<span class="built_in">count</span>[arr[j]-<span class="built_in">min</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack</title>
    <url>/2020/12/27/Knapsack/</url>
    <content><![CDATA[<h4 id="背包问题，从左往右的尝试模型"><a href="#背包问题，从左往右的尝试模型" class="headerlink" title="背包问题，从左往右的尝试模型"></a>背包问题，从左往右的尝试模型</h4><pre><code>给定两个长度都为N的数组weights和values，weight[i]和values[i]分别代表物品的重量和价值。给定一个正数bag
表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不变：w[] v[] bag</span></span><br><span class="line"><span class="comment">//index... 最大价值</span></span><br><span class="line"><span class="comment">//0...index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span></span><br><span class="line"><span class="comment">//如果返回-1则认为没有方法，如果不返回-1，则认为返回的值是真实值</span></span><br><span class="line"><span class="comment">//函数返回值为index之后的最大价值</span></span><br><span class="line">public <span class="type">int</span> process(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> alreadyW, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="keyword">if</span>(alreadyW&gt;bag)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//index到达length时，剩余货物的最大价值为0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW, bag);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, alreadyW+w[<span class="keyword">index</span>], bag);<span class="comment">//yes</span></span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="type">int</span> process1(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == w.<span class="built_in">length</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p1 = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的货物</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p2Next = process(w, v, <span class="keyword">index</span>+<span class="number">1</span>, rest-w[<span class="keyword">index</span>]);</span><br><span class="line">	<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p2Next != <span class="number">-1</span>)&#123;</span><br><span class="line">		p2 = v[<span class="keyword">index</span>] + p2Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">public <span class="type">int</span> dpWay(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)&#123;</span><br><span class="line">	<span class="type">int</span> N = w.<span class="built_in">length</span>;</span><br><span class="line">	<span class="type">int</span>[][] dp = new <span class="type">int</span>[N+<span class="number">1</span>][bag+<span class="number">1</span>];<span class="comment">//dp[N][...]=0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="keyword">index</span>=N<span class="number">-1</span>;<span class="keyword">index</span>&gt;=<span class="number">0</span>;<span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//dp[index][rest]=?</span></span><br><span class="line">			<span class="type">int</span> p1 = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> p2 = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rest - w[<span class="keyword">index</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				p2 = v[<span class="keyword">index</span>] + dp[<span class="keyword">index</span>+<span class="number">1</span>][rest - w[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = Math.<span class="built_in">max</span>(p1, p2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>PrintAllPermutations</title>
    <url>/2020/12/27/PrintAllPermutations/</url>
    <content><![CDATA[<h5 id="打印一个字符串的全部排列方式"><a href="#打印一个字符串的全部排列方式" class="headerlink" title="打印一个字符串的全部排列方式"></a>打印一个字符串的全部排列方式</h5><hr>
<pre><code>从左往右的尝试模型，排列组合的方式就是先固定0位置上的字符，即0~length-1上的字符都有可能来到0位置上，确
定0位置上的字符以后，再确定1位置上的字符，即1~length-1上的字符都有可能来到1位置上...依次类推。

在要求无重复的排列中，可以通过哈希表的方式，来记录一个字符是否在某个位置上出现过，没有出现过才进行递归。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str[0...i-1]都已经做好决定了</span></span><br><span class="line"><span class="comment">//str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">//i为终止位置，str当前的位置就是一种结果-&gt;res</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArrayList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有终止，那么i之后位置上的字符都可以来到i位置上</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; <span class="built_in">str</span>.length; j ++)&#123;</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		process(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">		swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> swap(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] temp = <span class="built_in">str</span>[i];</span><br><span class="line">	<span class="built_in">str</span>[i] = <span class="built_in">str</span>[j];</span><br><span class="line">	<span class="built_in">str</span>[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串的所有排序方式，没有重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> i, ArratList&lt;<span class="keyword">String</span>&gt; res)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		res.<span class="built_in">add</span>(<span class="keyword">String</span>.valueOf(<span class="built_in">str</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">boolean</span>[] visit = <span class="keyword">new</span> <span class="built_in">boolean</span>[<span class="number">26</span>];<span class="comment">//26个字母，当前位置，不与其他位置共享</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j&lt;<span class="built_in">str</span>.length; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">false</span>)&#123;</span><br><span class="line">			visit[<span class="built_in">str</span>[j] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">			process2(<span class="built_in">str</span>, i+<span class="number">1</span>, res);</span><br><span class="line">			swap(<span class="built_in">str</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CoinsWay</title>
    <url>/2020/12/28/CoinWays/</url>
    <content><![CDATA[<h4 id="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"><a href="#使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张" class="headerlink" title="使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张"></a>使用不同面值的纸币来组成目标值，每一张面值都可以使用任意张</h4><pre><code>从左到右的模型，依次判断index位置上的纸币用几张，当index到达length时，如果rest==0，则该方法有效
返回1，否则返回0.在由暴力递归改成动态规划时，要考虑枚举问题。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ways1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：0~index-1位置上的货币使用已经确定，从index之后的货币使用方法数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选用index位置上的货币</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">1</span>; zhang*arr[<span class="keyword">index</span>] &lt;= rest; zhang++)&#123;</span><br><span class="line">		p2 += process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest - zhang*arr[<span class="keyword">index</span>]);<span class="comment">//选用index位置上的货币，至少一张</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法，每个格子有枚举行为，细粒度划分</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			<span class="built_in">int</span> ways = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> zhang=<span class="number">0</span>; zhang*arr[<span class="keyword">index</span>]&lt;=rest; zhang++)&#123;</span><br><span class="line">				ways += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-zhang*arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = ways;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划方法，省去枚举行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> aim)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">	dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//d[N][...] = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N - <span class="number">1</span>; <span class="keyword">index</span>&gt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest=<span class="number">0</span>; rest&lt;=aim; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];<span class="comment">//没有使用cur位置上的</span></span><br><span class="line">			<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>][rest-arr[<span class="keyword">index</span>]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span>[] radixSort(<span class="built_in">int</span>[] arr， <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[arr.length];</span><br><span class="line">	<span class="built_in">int</span>[] <span class="built_in">count</span> = new <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">len</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">int</span> division = (<span class="built_in">int</span>)Math.pow(<span class="number">10</span>,i);</span><br><span class="line">		for(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[j]/division%<span class="number">10</span>;</span><br><span class="line">			<span class="built_in">count</span>[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> m=<span class="number">1</span>; m&lt;count.length;m++)&#123;</span><br><span class="line">			<span class="built_in">count</span>[m] = <span class="built_in">count</span>[m] + <span class="built_in">count</span>[m-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(<span class="built_in">int</span> <span class="built_in">n</span>=arr.length-<span class="number">1</span>;<span class="built_in">n</span>&gt;=<span class="number">0</span>;<span class="built_in">n</span>--)&#123;</span><br><span class="line">			<span class="built_in">int</span> num = arr[<span class="built_in">n</span>] / division % <span class="number">10</span>;</span><br><span class="line">			result[<span class="built_in">count</span>[num]]=arr[<span class="built_in">n</span>];</span><br><span class="line">			<span class="built_in">count</span>[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		Arrays.fill(<span class="built_in">count</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>NQueens</title>
    <url>/2020/12/27/NQueens/</url>
    <content><![CDATA[<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><pre><code>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n
返回n种皇后的摆法有多少种。
n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//record[i]-&gt;i行的皇后，放在了第几列</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//潜台词：record[0...i-1]的皇后，任何两个皇后都不共行、不共列、不共斜线</span></span><br><span class="line"><span class="comment">//目前来到了第i行</span></span><br><span class="line"><span class="comment">//record[0..i-1]表示之前的行，放了皇后的列的序号</span></span><br><span class="line"><span class="comment">//返回值，接着把i...之后摆完，有多少种摆法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//i来到证明前面的摆法有效，返回1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//依次尝试i行的皇后摆放在什么位置</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isValid</span>(record, i, j))&#123;</span><br><span class="line">			record[i] = j;</span><br><span class="line">			res += <span class="built_in">process</span>(i+<span class="number">1</span>, record, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(record[k] ==j || Math.<span class="built_in">abs</span>(k-i) == Math.<span class="built_in">abs</span>(recod[k]-j))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用位运算计算不超过32皇后的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">1</span> || n&lt;<span class="number">32</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果你是9皇后问题，limit最右9个是1，其他都是0</span></span><br><span class="line">	<span class="keyword">int</span> limit = n == <span class="number">32</span> ? <span class="number">-1</span> : (<span class="number">1</span>&lt;&lt;n) <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit 划定了问题的规模，是固定的</span></span><br><span class="line"><span class="comment">//colLim 列的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">//rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDiaLim, <span class="keyword">int</span> rightDiaLim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colLim == limit)&#123;<span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有候选皇后的位置，都在pos上</span></span><br><span class="line">    <span class="comment">//colLim | leftDiaLim | rightDigLim -&gt; 总限制</span></span><br><span class="line">    <span class="comment">//~(colLim | leftDiaLim | rightDigLim) -&gt; 左侧的一坨0干扰，右侧每个1可尝试</span></span><br><span class="line">    <span class="comment">//所有可以放皇后都在pos上</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//提取中pos最右侧的1，剩下位置都是0</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process2(limit, colLim | mostRightOne, (leftDiaLim|mostRightOne)&lt;&lt;<span class="number">1</span>,</span><br><span class="line">                (rightDiaLim|mostRightOne)&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>printAllSubSquence</title>
    <url>/2020/12/27/PrintAllSubsquences/</url>
    <content><![CDATA[<h4 id="打印一个字符串的所有子序列"><a href="#打印一个字符串的所有子序列" class="headerlink" title="打印一个字符串的所有子序列"></a>打印一个字符串的所有子序列</h4><hr>
<pre><code>从左往右的尝试模型，从0位置出发，依次判断每个位置的字符是否选择，当index到达字符串末尾时，将所形成的字符
path加入结果的集合中。</code></pre>
<hr>
<a id="more"></a>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subs(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	List&lt;<span class="keyword">String</span>&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	process1(<span class="built_in">str</span>, <span class="number">0</span>, ans, path);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str固定参数</span></span><br><span class="line"><span class="comment">//index，此时进行判断的位置下标，要 or 不要</span></span><br><span class="line"><span class="comment">//如果index来到str的终止位置，就把沿途路径所形成的答案放在ans中</span></span><br><span class="line"><span class="comment">//之前做出的选择就是path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process1(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, List&lt;<span class="keyword">String</span>&gt; ans, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		ans.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一个字符串的全部子序列，且要求不要重复出现的子序列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; subsNoRepeate(<span class="keyword">String</span> s)&#123;</span><br><span class="line">	<span class="built_in">char</span>[] <span class="built_in">str</span> = s.toCharArray();</span><br><span class="line">	<span class="keyword">String</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	process2(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">set</span>, path);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> process2(<span class="built_in">char</span>[] <span class="built_in">str</span>, <span class="built_in">int</span> index, HashSet&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span>, <span class="keyword">String</span> path)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="built_in">str</span>.length)&#123;</span><br><span class="line">		<span class="built_in">set</span>.<span class="built_in">add</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">String</span> no = path;</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, no);<span class="comment">//不要index位置的字符</span></span><br><span class="line">	<span class="keyword">String</span> yes = path + <span class="keyword">String</span>.valueOf(<span class="built_in">str</span>[index]);</span><br><span class="line">	process1(<span class="built_in">str</span>, index + <span class="number">1</span>, ans, yes);<span class="comment">//要index位置的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>RobotMove</title>
    <url>/2020/12/27/RobotMove/</url>
    <content><![CDATA[<h4 id="机器人的移动问题"><a href="#机器人的移动问题" class="headerlink" title="机器人的移动问题"></a>机器人的移动问题</h4><pre><code>假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个）。
如果机器人来打1位置上，那么下一步一定只能往右走来打2位置；如果机器人来到N位置，那么下一步只能往左来到N-1
的位置；如果机器人来打中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也
是1~N中的一个）的方法有多少种，给定四个参数N、M、K、P，返回方法数。</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//总共N个位置，从M点出发，还剩K步，返回最终能到达P的方法数</span></span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, M, K, P)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N:位置1~N，固定参数</span></span><br><span class="line"><span class="comment">//cur:当前在cur位置，可变参数</span></span><br><span class="line"><span class="comment">//rest:剩余的步数，可变参数</span></span><br><span class="line"><span class="comment">//P：最终的目标位置</span></span><br><span class="line"><span class="comment">//该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果没有剩余步数了，当前的cur位置就是最后的位置</span></span><br><span class="line">    <span class="comment">//如果最后的位置停在P上，那么之前做的移动是有效的</span></span><br><span class="line">    <span class="comment">//如果最后的位置没在P上，那么之前做的移动式无效</span></span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> cur==P ? <span class="number">1</span> : 0; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span></span><br><span class="line">    <span class="comment">//后续的过程就是，来到2位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, <span class="number">2</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span></span><br><span class="line">	<span class="comment">//后续的过程就是，来到N-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">return</span> <span class="title">walk</span><span class="params">(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以想左也可以向右</span></span><br><span class="line">    <span class="comment">//走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">//走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P) + walk(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">waysCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;=N; row++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;=K;col++)&#123;</span><br><span class="line">			dp[row][col]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">walkCache</span><span class="params">(N, M, K, P, dp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表方法，把cur和rest所有方法加入到缓存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">walkCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[cur][rest]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">		dp[cur][rest] = cur == P ? <span class="number">1</span> : 0;</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, <span class="number">2</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cur==N)&#123;</span><br><span class="line">		dp[cur][rest] = walkCache(N, N<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">		<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[cur][rest] = walkCache(N, cur+<span class="number">1</span>, rest<span class="number">-1</span>, P, dp) + walkCache(N, cur<span class="number">-1</span>, rest<span class="number">-1</span>, P, dp);</span><br><span class="line">	<span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">dpWays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//参数无效直接返回0</span></span><br><span class="line">	<span class="keyword">if</span>(N&lt;<span class="number">2</span> || K&lt;<span class="number">1</span> || M&lt;<span class="number">1</span> || M&gt;N || p&lt;<span class="number">1</span> || P&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">	dp[P][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//dp[!P][...]=0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= K; rest++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">1</span>; cur &lt;= N; cur++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur==<span class="number">1</span>)&#123;</span><br><span class="line">				dp[cur][rest] = dp[<span class="number">2</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(cur==N)</span></span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[N<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[cur][rest] = dp[cur+<span class="number">1</span>][rest<span class="number">-1</span>]+dp[cur<span class="number">-1</span>][rest<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[M][P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/12/28/SnackWays/</url>
    <content><![CDATA[<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><pre><code>背包容量为w，一共有n袋零食，第i袋零食体积为v[i], 总体积不超过背包容量的
情况下，一共有多少种零食方法？（总体积为0也算一种方法）</code></pre>
<hr>
<a id="more"></a>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> nums(<span class="built_in">int</span>[] v, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == <span class="literal">null</span> || v.length==<span class="number">0</span> || w &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process1(v, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> process1(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="keyword">index</span>, <span class="built_in">int</span> rest)&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//rest&gt;=0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">index</span> == arr.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> p1 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest);<span class="comment">//不选择index位置上的零食</span></span><br><span class="line">	<span class="built_in">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(rest - arr[<span class="keyword">index</span>]=&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		p2 = process1(arr, <span class="keyword">index</span>+<span class="number">1</span>, rest-arr[<span class="keyword">index</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> dpWays(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> w)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span> || w&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> N = arr.length;</span><br><span class="line">	<span class="built_in">int</span> dp[][] = <span class="keyword">new</span> <span class="built_in">int</span>[N+<span class="number">1</span>][w+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest&lt;=w; rest++)&#123;</span><br><span class="line">		dp[N][rest] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> <span class="keyword">index</span> = N<span class="number">-1</span>; <span class="keyword">index</span> &lt;=<span class="number">0</span>; <span class="keyword">index</span>--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> rest = <span class="number">0</span>; rest &lt;= w; rest++)&#123;</span><br><span class="line">			dp[<span class="keyword">index</span>][rest] = dp[<span class="keyword">index</span>+<span class="number">1</span>][rest];</span><br><span class="line">			<span class="keyword">if</span>(rest-arr[<span class="keyword">index</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="keyword">index</span>][rest] += dp[<span class="keyword">index</span>+<span class="number">1</span>][rest-arr[<span class="keyword">index</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QucikSort</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">		int[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		<span class="built_in">sort</span>(arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		<span class="built_in">print</span>(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">sort</span>(int[] arr, int <span class="keyword">left</span>, int <span class="keyword">right</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		int mid = <span class="built_in">partition</span>(arr, <span class="keyword">left</span>, <span class="keyword">right</span>);<span class="comment">//获取pivot的位置</span></span><br><span class="line">		<span class="built_in">sort</span>(arr,<span class="keyword">left</span>,mid-<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,<span class="keyword">right</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> int <span class="built_in">partition</span>(int[] arr, int start, int end)&#123;</span><br><span class="line">		int <span class="keyword">left</span> = start;</span><br><span class="line">		int <span class="keyword">right</span> = end - <span class="number">1</span>;</span><br><span class="line">		int pivot = arr[end];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">left</span>]&lt;=pivot)<span class="keyword">left</span>++;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">left</span>&lt;=<span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">right</span>]&gt;pivot)<span class="keyword">right</span>--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)<span class="built_in">swap</span>(arr,<span class="keyword">left</span>,<span class="keyword">right</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(arr, <span class="keyword">left</span>, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">swap</span>(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> void <span class="built_in">print</span>(int[] arr)&#123;</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="type">System</span>.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(h&lt;=arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">			h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">//初始化gap的方法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap=h;gap&gt;<span class="number">0</span>;gap=(gap<span class="number">-1</span>)/<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;gap<span class="number">-1</span>;j-=gap)&#123;</span><br><span class="line">					<span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		arr[i] = arr[j] + arr[i];</span><br><span class="line">		arr[j] = arr[i] - arr[j];</span><br><span class="line">		arr[i] = arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> boolean exist(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">num</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="comment">//防止溢出</span></span><br><span class="line">	  mid = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">if</span>(arr[mid]==<span class="built_in">num</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;<span class="built_in">num</span>) right = mid - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">else</span> left = left + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid] == <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static <span class="built_in">int</span> nearestIndex(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> <span class="built_in">value</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">index</span> = -<span class="number">1</span>;//记录最左侧的下标</span><br><span class="line">	while(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span> - <span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>]&gt;=<span class="built_in">value</span>)&#123;</span><br><span class="line">			<span class="built_in">index</span> = <span class="built_in">mid</span>;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">index</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> getLessIndex(<span class="built_in">int</span>[] arr)&#123;</span><br><span class="line">	<span class="built_in">if</span>(arr == null || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>])&#123;</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">if</span>(arr[arr.length - <span class="number">2</span>] &gt; arr[arr.length - <span class="number">1</span>])&#123;</span><br><span class="line">		return arr.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">right</span> = arr.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	while(<span class="built_in">left</span>&lt;<span class="built_in">right</span>)&#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + ((<span class="built_in">right</span>-<span class="built_in">left</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">		&#125;else <span class="built_in">if</span>(arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> + <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return <span class="built_in">mid</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="built_in">left</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4><a id="more"></a>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> PrintTreeTest &#123;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">class</span> Node&#123;</span><br><span class="line">        <span class="built_in">int</span> value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="constructor">Node(<span class="params">int</span> <span class="params">v</span>)</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">Tree(Node <span class="params">head</span>)</span>&#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Binary Tree&quot;</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>, 0, <span class="string">&quot;H&quot;</span>, 17)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print<span class="constructor">InOrder(Node <span class="params">head</span>, <span class="params">int</span> <span class="params">height</span>, String <span class="params">to</span>, <span class="params">int</span> <span class="params">len</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head<span class="operator"> == </span>null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">right</span>, <span class="params">height</span>+1, <span class="string">&quot;v&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        String <span class="keyword">val</span> = <span class="keyword">to</span> + head.value + <span class="keyword">to</span>;</span><br><span class="line">        <span class="built_in">int</span> lenM = <span class="keyword">val</span>.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> lenL = (len - lenM)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        <span class="keyword">val</span> = get<span class="constructor">Space(<span class="params">lenL</span>)</span> + <span class="keyword">val</span> +get<span class="constructor">Space(<span class="params">lenR</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(get<span class="constructor">Space(<span class="params">height</span><span class="operator">*</span><span class="params">len</span>)</span> + <span class="keyword">val</span>);</span><br><span class="line">        print<span class="constructor">InOrder(<span class="params">head</span>.<span class="params">left</span>, <span class="params">height</span>+1, <span class="string">&quot;^&quot;</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String get<span class="constructor">Space(<span class="params">int</span> <span class="params">num</span>)</span>&#123;</span><br><span class="line">        String space = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        return buf.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="返回二叉树中指定节点的后续节点"><a href="#返回二叉树中指定节点的后续节点" class="headerlink" title="返回二叉树中指定节点的后续节点"></a>返回二叉树中指定节点的后续节点</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">static class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">	int</span> value;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">left</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">right</span>;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">parent</span>;</span><br><span class="line">	<span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在中序遍历中的后继节点</span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getSuccessorNode</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node.right!=null)&#123;</span><br><span class="line">		return getLeftMost(node.right);</span><br><span class="line">	&#125;else&#123;//无右子树</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">parent</span> = node.parent;</span><br><span class="line">		while(parent != null &amp;&amp; parent.left != <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">			node</span> = parent;</span><br><span class="line">			parent = node.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">getLeftMost</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	if(<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">		return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	&#125;</span></span><br><span class="line"><span class="title">	while</span>(node.left!=null)&#123;</span><br><span class="line">		<span class="keyword">node</span> <span class="title">= node</span>.left;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="纸对折，依次输出折痕的方向"><a href="#纸对折，依次输出折痕的方向" class="headerlink" title="纸对折，依次输出折痕的方向"></a>纸对折，依次输出折痕的方向</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归过程</span></span><br><span class="line"><span class="comment">//i是节点的层数，N一共的层数，down==true凹 down==false凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;N)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">	System.out.<span class="built_in">println</span>(down ? <span class="string">&quot;凹&quot;</span> : <span class="string">&quot;凸&quot;</span>);</span><br><span class="line">	printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"><a href="#给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树" class="headerlink" title="给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树"></a>给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalanced</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node left;</span><br><span class="line">		Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">			value = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">		<span class="keyword">boolean</span> isBalanced;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">			isBalanced = h;</span><br><span class="line">			<span class="built_in">height</span> = h;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">		Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">height</span> = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isBalanced = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Math.<span class="built_in">abs</span>(leftInfo.<span class="built_in">height</span> - rightInfo.<span class="built_in">height</span> &lt;<span class="number">2</span>)	&amp;&amp; leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced)&#123;</span><br><span class="line">			isBalanced = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, <span class="built_in">height</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">process</span>(head).isBalanced;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"><a href="#给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）" class="headerlink" title="给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）"></a>给定一棵二叉树的头节点，返回这棵数中两个节点间的最大距离（将节点间的边视为距离）</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDistance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">process</span>(head).distacne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">		distance = d;</span><br><span class="line">		<span class="built_in">height</span> = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意思考结果的可能性，常见的就是结果与当前节点有关和无关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = <span class="built_in">process</span>(head.left);</span><br><span class="line">	Info rightInfo = <span class="built_in">process</span>(head.right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> heigth = Math.<span class="built_in">max</span>(leftInfo.<span class="built_in">height</span>, rightInfo.<span class="built_in">height</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> distance = Math.<span class="built_in">max</span>(</span><br><span class="line">		Math.<span class="built_in">max</span>(leftInfo.distance, rightInfo.distance), </span><br><span class="line">		leftInfo.<span class="built_in">height</span>+rightInfo.<span class="built_in">height</span>+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(distance, <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"><a href="#给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点" class="headerlink" title="给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点"></a>给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点</h4><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> data)&#123;</span><br><span class="line">		value = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node getMaxSubBalancedTree(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> process(head).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info&#123;</span><br><span class="line">	<span class="built_in">boolean</span> isAllBST;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span>;</span><br><span class="line">	Node head;</span><br><span class="line">	<span class="keyword">public</span> Info(<span class="built_in">boolean</span> is, <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span> mi, <span class="built_in">int</span> ma, Node h)&#123;</span><br><span class="line">		isAllBST = is;</span><br><span class="line">		maxSubSize = <span class="built_in">size</span>;</span><br><span class="line">		<span class="built_in">min</span> = mi;</span><br><span class="line">		<span class="built_in">max</span> = ma;</span><br><span class="line">		head = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Info process(Node X)&#123;</span><br><span class="line">	<span class="keyword">if</span>(X==<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info leftInfo = process(X.left);</span><br><span class="line">	Info rightInfo = process(X.right);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">	<span class="built_in">int</span> maxSubSize = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">min</span> = X.value;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">max</span> = X.value;</span><br><span class="line">	Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, leftInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, leftInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, rightInfo.<span class="built_in">min</span>);</span><br><span class="line">		<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, rightInfo.<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可能性1，与x节点无关</span></span><br><span class="line">	<span class="keyword">if</span>(leftInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = leftInfo.maxSubSize;</span><br><span class="line">		head = leftInfo.head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		maxSubSize = Math.<span class="built_in">max</span>(maxSubSize, rightInfo.maxSubSize);</span><br><span class="line">		<span class="keyword">if</span>(maxSubSize&lt;rightInfo.maxSubSize)&#123;</span><br><span class="line">			head = rightInfo.head;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST) &amp;&amp; </span><br><span class="line">		(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST) &amp;&amp;</span><br><span class="line">		(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.<span class="built_in">max</span> &lt; X.value) &amp;&amp;</span><br><span class="line">		(right == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.<span class="built_in">min</span> &gt; X.value))&#123;</span><br><span class="line"></span><br><span class="line">			maxSubSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize) + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">			isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			head = X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubSize, <span class="built_in">min</span>, <span class="built_in">max</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="派对的快乐值"><a href="#派对的快乐值" class="headerlink" title="派对的快乐值"></a>派对的快乐值</h4><pre><code>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。数的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工（subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些不来，规则：
1.如果某员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</code></pre>
<hr>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee&#123;</span><br><span class="line">	<span class="built_in">public</span> happy;</span><br><span class="line">	<span class="built_in">public</span> List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> Employee(<span class="type">int</span> h)&#123;</span><br><span class="line">		happy = h;</span><br><span class="line">		nexts = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> maxHappy(Employee boss)&#123;</span><br><span class="line">	<span class="keyword">if</span>(boss == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">Info</span> <span class="keyword">all</span> = process(boss);</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="keyword">all</span>.yes, <span class="keyword">all</span>.<span class="keyword">no</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="keyword">Info</span>&#123;</span><br><span class="line">	<span class="type">int</span> yes;//x来情况下的最大happy</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span>;//x不来情况下的最大happy</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Info</span>(<span class="type">int</span> y, <span class="type">int</span> n)&#123;</span><br><span class="line">		yes = y;</span><br><span class="line">		<span class="keyword">no</span> = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">Info</span> process(Employee x)&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.nexts.isEmpty)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(x.happy, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> yes = x.happy;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">no</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(Employee next : x.nexts)&#123;</span><br><span class="line">		<span class="keyword">Info</span> nextInfo = process(next);</span><br><span class="line">		yes += nextInfo.<span class="keyword">no</span>;</span><br><span class="line">		<span class="keyword">no</span> += Math.max(nextInfo.yes,nextInfo.<span class="keyword">no</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span> <span class="keyword">Info</span>(yes, <span class="keyword">no</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Node1</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(<span class="built_in">int</span> value)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pre</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">in</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">in</span>(head.left);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="keyword">in</span>(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pos</span>(<span class="params">Node1 head</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的先序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> pre1(Node1 head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Satck&lt;Node1&gt;();</span><br><span class="line">		stack.<span class="keyword">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			head = stack.<span class="keyword">pop</span>();</span><br><span class="line">			System.out.<span class="keyword">print</span>(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				stack.<span class="keyword">push</span>(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				stack.<span class="keyword">push</span>(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="keyword">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的后序遍历，非递归方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> pos1(Node1 head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		s1.<span class="keyword">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">			head = s1.<span class="keyword">pop</span>();</span><br><span class="line">			s2.<span class="keyword">push</span>(head);</span><br><span class="line">			<span class="keyword">if</span>(head.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				s1.<span class="keyword">push</span>(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				s1.<span class="keyword">push</span>(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.<span class="keyword">print</span>(s2.<span class="keyword">pop</span>().value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用一个栈实现非递归的后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> pos2(Node1 h)&#123;</span><br><span class="line">    <span class="keyword">if</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">        stack.<span class="keyword">push</span>(h);</span><br><span class="line">        Node1 c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(c.left != <span class="keyword">null</span> &amp;&amp; h!=c.left &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.<span class="keyword">push</span>(c.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.right != <span class="keyword">null</span> &amp;&amp; h!=c.right)&#123;</span><br><span class="line">                stack.<span class="keyword">push</span>(c.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(stack.<span class="keyword">pop</span>()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                h=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的中序遍历，非递归方法</span></span><br><span class="line"><span class="comment">//1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> in1(Node1 head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack = <span class="keyword">new</span> Stack&lt;Node1&gt;();</span><br><span class="line">		stack.<span class="keyword">push</span>(head);</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty() || head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				stack.<span class="keyword">push</span>(head);</span><br><span class="line">				head = head.left;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				head = stack.<span class="keyword">pop</span>();</span><br><span class="line">				System.out.<span class="keyword">print</span>(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">				head = head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="keyword">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现二叉树的按层遍历</span></span><br><span class="line"><span class="comment"> * 1）其实就是宽度优先遍历，用队列</span></span><br><span class="line"><span class="comment"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">            ret.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=null)</span><br><span class="line">                <span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWithUseMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	levelMap.<span class="built_in">put</span>(head, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> curLevel = <span class="number">1</span>;<span class="comment">//当前正在统计哪一层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的宽度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">int</span> curNodeLevel = levelMap.<span class="built_in">get</span>(cur);</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.left, curNodeLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			levelMap.<span class="built_in">put</span>(cur.right, curLevel+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span></span><br><span class="line">		<span class="keyword">if</span>(curNodeLevel == curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">max</span> = <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出具有最大层的节点数，不使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node1 head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.add(head);</span><br><span class="line">	Node1 curEnd = head;<span class="comment">//当前层，最右节点</span></span><br><span class="line">	Node1 nextEnd = head;<span class="comment">//下一层，最右节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curLevelNodes = <span class="number">0</span>;<span class="comment">//当前层的节点数</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		Node1 cur = <span class="built_in">queue</span>.poll();</span><br><span class="line">		<span class="keyword">if</span>(cur.left!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.left);</span><br><span class="line">			nextEnd = cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur.right!=null)&#123;</span><br><span class="line">			<span class="built_in">queue</span>.add(cur.right);</span><br><span class="line">			nextEnd = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		<span class="keyword">if</span>(cur == curEnd)&#123;</span><br><span class="line">			<span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, curLevelNodes);</span><br><span class="line">			curLevelNodes = <span class="number">0</span>;</span><br><span class="line">			curEnd = nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历序列化与重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">preSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">	Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">pres</span>(<span class="params">Node head, Queue&lt;<span class="built_in">String</span>&gt; ans</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		ans.add(<span class="literal">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByPreQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prelist == <span class="literal">null</span> || prelist.size()==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">preb</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; prelist</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">String</span> value = prelist.poll();</span><br><span class="line">	<span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">	head.left = preb(prelist);</span><br><span class="line">	head.right = preb(prelist);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">levelSerial</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">    Queue&lt;<span class="built_in">String</span>&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        ans.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans.add(<span class="built_in">String</span>.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(head.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(<span class="built_in">String</span>.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="function"><span class="title">buildByLevelQueue</span>(<span class="params">Queue&lt;<span class="built_in">String</span>&gt; levelList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(levelList == <span class="literal">null</span> || levelList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNode(levelList.poll());</span><br><span class="line">        node.right = generateNode(levelList.poll());</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="function"><span class="title">generateNode</span>(<span class="params"><span class="built_in">String</span> val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> MergeSort&#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args)&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		sort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> sort(<span class="type">int</span>[] arr, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(start==<span class="keyword">end</span>)<span class="keyword">return</span>;</span><br><span class="line">		//分成两块</span><br><span class="line">		<span class="type">int</span> mid = <span class="keyword">start</span> + (<span class="keyword">end</span> - <span class="keyword">start</span>)/<span class="number">2</span>;</span><br><span class="line">		//左边排序</span><br><span class="line">		sort(arr, <span class="keyword">start</span>, mid);</span><br><span class="line">		//右边排序</span><br><span class="line">		sort(arr, mide + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">		merge(arr, <span class="keyword">start</span>, mid + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)&#123;</span><br><span class="line">		<span class="type">int</span> i = left;</span><br><span class="line">		<span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt;= arr[j])<span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="keyword">temp</span>.length; m++)&#123;</span><br><span class="line">			arr[left+m] = <span class="keyword">temp</span>[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static <span class="type">void</span> swap(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，只有一种数出现了奇数次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> eor = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.<span class="keyword">out</span>.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中，有两种数出现了两次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// eor = a^b</span></span><br><span class="line">	<span class="comment">// eor != 0</span></span><br><span class="line">	<span class="comment">// eor必然有一个位置是1</span></span><br><span class="line">	<span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((arr[i] &amp; rightOne) != <span class="number">0</span>)&#123;</span><br><span class="line">			onlyOne ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.<span class="built_in">println</span>(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">					arr[j<span class="number">-1</span>]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node(<span class="built_in">int</span> v)&#123;</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有3个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head.<span class="keyword">next</span>;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span> || head.<span class="keyword">next</span>.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表有2个或以上的点</span></span><br><span class="line">	Node slow = head;</span><br><span class="line">	Node fast = head.<span class="keyword">next</span>;</span><br><span class="line">	<span class="keyword">while</span>(fast.<span class="keyword">next</span>!=<span class="literal">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">		slow = slow.<span class="keyword">next</span>;</span><br><span class="line">		fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		stack.<span class="keyword">push</span>(cur);</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.value != stack.<span class="keyword">pop</span>().value)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head = head.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//need o(1) extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isPalindrome2(Node head)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 = head;</span><br><span class="line">	NOde n2 = head;</span><br><span class="line">	<span class="keyword">while</span>(n2.<span class="keyword">next</span>!= <span class="keyword">null</span> &amp;&amp; n2.<span class="keyword">next</span>.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>;<span class="comment">//n1-&gt;mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>.<span class="keyword">next</span>;<span class="comment">//n2-&gt;end</span></span><br><span class="line">	&#125;</span><br><span class="line">	n2 = n1.<span class="keyword">next</span>;<span class="comment">//n2-&gt;right part first node</span></span><br><span class="line">	n1.<span class="keyword">next</span> = <span class="keyword">null</span>;<span class="comment">//mid.next-&gt;null</span></span><br><span class="line">	Node n3 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n2!=<span class="keyword">null</span>)&#123;<span class="comment">//right part convert</span></span><br><span class="line">		n3 = n2.<span class="keyword">next</span>;<span class="comment">//n3-&gt;save the node</span></span><br><span class="line">		n2.<span class="keyword">next</span> = n1;<span class="comment">//next of right node convert</span></span><br><span class="line">		n1 = n2;<span class="comment">//n1 move</span></span><br><span class="line">		n2 = n3;<span class="comment">//n2 move</span></span><br><span class="line">	&#125;</span><br><span class="line">	n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">	n2 = head; <span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">	<span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2!= <span class="keyword">null</span>)&#123; <span class="comment">// check palindrome</span></span><br><span class="line">		<span class="keyword">if</span>(n1.value != n2.value)&#123;</span><br><span class="line">			res = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 = n1.<span class="keyword">next</span>; <span class="comment">// left to mid</span></span><br><span class="line">		n2 = n2.<span class="keyword">next</span>; <span class="comment">// right to mid</span></span><br><span class="line">	&#125;</span><br><span class="line">	n1 = n3.<span class="keyword">next</span>;</span><br><span class="line">	n3.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">		n2 = n1.<span class="keyword">next</span>;</span><br><span class="line">		n1.<span class="keyword">next</span> = n3;</span><br><span class="line">		n3 = n1;</span><br><span class="line">		n1 = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node listPartition1(Node head, <span class="built_in">int</span> piovt)&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i!=nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] = cur;</span><br><span class="line">		cur = cur.<span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i != nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i<span class="number">-1</span>].<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> arrPartition(Node[] nodeArr, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	<span class="built_in">int</span> samll = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">int</span> big = nodeArr.length;</span><br><span class="line">	<span class="built_in">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">index</span>!=big)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,<span class="keyword">index</span>++);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[<span class="keyword">index</span>].value==piovt)&#123;</span><br><span class="line">			<span class="keyword">index</span>++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(nodeArr, --big, <span class="keyword">index</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试方法</span></span><br><span class="line"><span class="keyword">public</span> Node listPartition2(Node head, <span class="built_in">int</span> pivot)&#123;</span><br><span class="line">	Node sH = <span class="literal">null</span>;<span class="comment">//small head</span></span><br><span class="line">	Node sT = <span class="literal">null</span>;<span class="comment">//samll tail</span></span><br><span class="line">	Node eH = <span class="literal">null</span>;<span class="comment">//equal head</span></span><br><span class="line">	Node eT = <span class="literal">null</span>;<span class="comment">//equal tail</span></span><br><span class="line">	Node mH = <span class="literal">null</span>;<span class="comment">//big head</span></span><br><span class="line">	Node MT = <span class="literal">null</span>;<span class="comment">//big tail</span></span><br><span class="line">	Node <span class="keyword">next</span> = <span class="literal">null</span>;<span class="comment">//save the node</span></span><br><span class="line">	<span class="comment">//every node distributed to three lists</span></span><br><span class="line">	<span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">		head.<span class="keyword">next</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(head.value &lt; pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sH == <span class="literal">null</span>)&#123;</span><br><span class="line">				sH = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				sT.<span class="keyword">next</span> = head;</span><br><span class="line">				sT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(eH == <span class="literal">null</span>)&#123;</span><br><span class="line">				eH = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				eT.<span class="keyword">next</span> = head;</span><br><span class="line">				eT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(mH == <span class="literal">null</span>)&#123;</span><br><span class="line">				mH = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				mT.<span class="keyword">next</span> = head;</span><br><span class="line">				mT = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head = <span class="keyword">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//小于区域的尾巴，连等于区域的头，等于区域的尾巴</span></span><br><span class="line">	<span class="keyword">if</span>(sT!=<span class="literal">null</span>)&#123;<span class="comment">//如果有小于区域</span></span><br><span class="line">		sT.<span class="keyword">next</span> = eH;</span><br><span class="line">		eT = eT == <span class="literal">null</span> ? sT : eT;<span class="comment">//下一步，谁去连大于区域的头</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的if，不管跑了没有，et</span></span><br><span class="line">	<span class="comment">//all reconnect</span></span><br><span class="line">	<span class="keyword">if</span>(et!=<span class="literal">null</span>)&#123;</span><br><span class="line">		eT.<span class="keyword">next</span> = mH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="一种特殊的单链表节点描述一下"><a href="#一种特殊的单链表节点描述一下" class="headerlink" title="一种特殊的单链表节点描述一下"></a>一种特殊的单链表节点描述一下</h4><pre><code>class Node&#123;
    int value;
    Node next;
    Node rand;
    Node(int val)&#123;
        value = val;
    &#125;
&#125;
rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</code></pre>
<hr>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"><span class="comment">//笔试方法，使用HashMap</span></span><br><span class="line">public Node copyListWithRand1(Node head)&#123;</span><br><span class="line">	HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();</span><br><span class="line">	Node cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="built_in">null</span>)&#123;</span><br><span class="line">		map.put(cur, new Node(cur.<span class="built_in">value</span>));</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老节点</span></span><br><span class="line">		<span class="comment">//map.get(cur)新节点</span></span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">next</span> = map.<span class="built_in">get</span>(cur.<span class="built_in">next</span>);</span><br><span class="line">		map.<span class="built_in">get</span>(cur).<span class="built_in">rand</span> = map.<span class="built_in">get</span>(<span class="built_in">cut</span>.<span class="built_in">rand</span>);</span><br><span class="line">		cur = cur.<span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp.<span class="built_in">get</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试用的方法</span></span><br><span class="line">public Node copyListWithRand2(Node head)&#123;</span><br><span class="line">	if(head == <span class="built_in">null</span>)&#123;</span><br><span class="line">		return <span class="built_in">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur = head;</span><br><span class="line">	Node <span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//copy node and link to every node</span></span><br><span class="line">	<span class="comment">//1-&gt;2</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = new Node(cur.<span class="built_in">value</span>);</span><br><span class="line">		cur.<span class="built_in">next</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = head;</span><br><span class="line">	Node curCopy = <span class="built_in">null</span>;</span><br><span class="line">	<span class="comment">//set copy node rand</span></span><br><span class="line">	<span class="comment">//1-&gt;1&#x27;-&gt;2-&gt;2&#x27;</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="comment">//cur 老</span></span><br><span class="line">		<span class="comment">//cur.next 新 copy</span></span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">rand</span> = cur.<span class="built_in">rand</span> != <span class="built_in">null</span> ? cur.<span class="built_in">rand</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node res = head.<span class="built_in">next</span>;</span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="comment">// split</span></span><br><span class="line">	<span class="keyword">while</span>(cur!=<span class="built_in">null</span>)&#123;</span><br><span class="line">		<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>;</span><br><span class="line">		curCopy = cur.<span class="built_in">next</span>;</span><br><span class="line">		cur.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">		curCopy.<span class="built_in">next</span> = <span class="built_in">next</span> != <span class="built_in">null</span> ? <span class="built_in">next</span>.<span class="built_in">next</span> : <span class="built_in">null</span>;</span><br><span class="line">		cur = <span class="built_in">next</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="两个可能有环链表的交点"><a href="#两个可能有环链表的交点" class="headerlink" title="两个可能有环链表的交点"></a>两个可能有环链表的交点</h4><hr>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class <span class="keyword">Node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">(int</span> v)&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">head</span> = new <span class="keyword">Node</span><span class="title">(1</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node2</span> = new <span class="keyword">Node</span><span class="title">(2</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node3</span> = new <span class="keyword">Node</span><span class="title">(3</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node4</span> = new <span class="keyword">Node</span><span class="title">(4</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node5</span> = new <span class="keyword">Node</span><span class="title">(5</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node6</span> = new <span class="keyword">Node</span><span class="title">(6</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node7</span> = new <span class="keyword">Node</span><span class="title">(7</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node8</span> = new <span class="keyword">Node</span><span class="title">(8</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node9</span> = new <span class="keyword">Node</span><span class="title">(9</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node10</span> = new <span class="keyword">Node</span><span class="title">(10</span>);</span><br><span class="line"></span><br><span class="line">        head.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        node5.next = node6;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        node7.next = node8;</span><br><span class="line">        node8.next = node9;</span><br><span class="line">        node9.next = node10;</span><br><span class="line">        node10.next = node5;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span> <span class="title">crossNode</span> = getLoopNode(head);</span><br><span class="line">        System.out.println(crossNode.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getIntersection</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || <span class="attr">head2=</span>=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop1</span> = getLoopNode(head1);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">loop2</span> = getLoopNode(head2);</span><br><span class="line">        if(<span class="attr">loop1=</span>=null &amp;&amp; <span class="attr">loop2=</span>=null)&#123;</span><br><span class="line">            return noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(loop1!=null &amp;&amp; loop2!=null)&#123;</span><br><span class="line">            return  bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一个链表第一个入环的节点</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">getLoopNode</span>(<span class="keyword">Node</span> <span class="title">head</span>)&#123;</span><br><span class="line">        if(head ==null || head.next ==null || head.next.next == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // n1 慢 n2 快</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n1</span> = head.next; //n1-&gt;slow</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">n2</span> = head.next.next; //n2-&gt;fast</span><br><span class="line">        while(n1 != n2)&#123;</span><br><span class="line">            if(n2.next == null || n2.next.next == null)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head;  //n2-&gt;walk again from head</span><br><span class="line">        while(n1!=n2)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果两个无环链表相交返回第一个相交的节点，如果不相交返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">noLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">head2</span>)&#123;</span><br><span class="line">        if(head1 == null || head2 == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = head1;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = head2;</span><br><span class="line">        int n = <span class="number">0</span>;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1.next != null)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur1 != cur2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //n : 链表<span class="number">1</span>的长度减去链表<span class="number">2</span>的长度</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; //长的变为cur1</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //两个链表都有环，返回第一个相交的节点，不相交则返回空</span><br><span class="line">    public static <span class="keyword">Node</span> <span class="title">bothLoop</span>(<span class="keyword">Node</span> <span class="title">head1</span>, <span class="keyword">Node</span> <span class="title">loop1</span>, <span class="keyword">Node</span> <span class="title">head2</span>, <span class="keyword">Node</span> <span class="title">loop2</span>)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur1</span> = null;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">cur2</span> = null;</span><br><span class="line">        if(loop1 == loop2)&#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            int n = <span class="number">0</span>;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur2!=loop2)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 :head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            while(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cur1!=cur2)&#123;</span><br><span class="line">                <span class="attr">cur1=</span> cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return cur1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            while(cur1!=loop1)&#123;</span><br><span class="line">                if(cur1 == loop2)&#123;</span><br><span class="line">                    return loop1;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> minPos = i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = temp;</span><br><span class="line">			arr[minPos] = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
