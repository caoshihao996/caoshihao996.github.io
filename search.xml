<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基数排序（radix sort）</title>
    <url>/2020/12/13/RadixSort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>基数排序是一种非比较整数排序算法，其原理是将整数按位切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</code></pre>
<a id="more"></a>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] radixSort(int[] arr， int len)&#123;</span><br><span class="line">	int[] result &#x3D; new int[arr.length];</span><br><span class="line">	int[] count &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		int division &#x3D; (int)Math.pow(10,i);</span><br><span class="line">		for(int j&#x3D;0;j&lt;arr.length;j++)&#123;</span><br><span class="line">			int num &#x3D; arr[j]&#x2F;division%10;</span><br><span class="line">			count[num]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int m&#x3D;1; m&lt;count.length;m++)&#123;</span><br><span class="line">			count[m] &#x3D; count[m] + count[m-1];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int n&#x3D;arr.length-1;n&gt;&#x3D;0;n--)&#123;</span><br><span class="line">			int num &#x3D; arr[n] &#x2F; division % 10;</span><br><span class="line">			result[count[num]]&#x3D;arr[n];</span><br><span class="line">			count[num]--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.arraycopy(result, 0, arr, 0, arr.length);</span><br><span class="line">		Arrays.fill(count,0);</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/12/13/quicksort/</url>
    <content><![CDATA[<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>选取数组中的一个元素作为基准（pivot），对数组继续宁排序，使得比pivot大的元素都在右边，比pivot小的元素都在左边，然后对以pivot为分界点的左右子串递归进行快排。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QucikSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;1,4,6,9,10,2,3,5,8,7&#125;;</span><br><span class="line">		sort(arr, 0, arr.length);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void sort(int[] arr, int left, int right)&#123;</span><br><span class="line">		if(left&gt;&#x3D;right)return;</span><br><span class="line"></span><br><span class="line">		int mid &#x3D; partition(arr, left, right);&#x2F;&#x2F;获取pivot的位置</span><br><span class="line">		sort(arr,left,mid-1);</span><br><span class="line">		sort(arr,mid+1,right);</span><br><span class="line">	&#125;</span><br><span class="line">	public static int partition(int[] arr, int start, int end)&#123;</span><br><span class="line">		int left &#x3D; start;</span><br><span class="line">		int right &#x3D; end - 1;</span><br><span class="line">		int pivot &#x3D; arr[end];</span><br><span class="line"></span><br><span class="line">		while(left&lt;&#x3D;right)&#123;</span><br><span class="line">			while(left&lt;&#x3D;right &amp;&amp; arr[left]&lt;&#x3D;pivot)left++;</span><br><span class="line">			while(left&lt;&#x3D;right &amp;&amp; arr[right]&gt;pivot)right--;</span><br><span class="line"></span><br><span class="line">			if(left&lt;right)swap(arr,left,right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		swap(arr, left, end);</span><br><span class="line"></span><br><span class="line">		return left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; arr[j];</span><br><span class="line">		arr[j] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void print(int[] arr)&#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/12/13/CountSort/</url>
    <content><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><pre><code>计数排序是利用哈希原理，记录元素出现的次数。在统计结束之后可以直接遍历哈希表，将数据天会空间。由于是空间换时间，所以适合对数据范围集中的数据使用。而且由于用数组下标表示，只适合只有正整数，0的数组。</code></pre>
<a id="more"></a>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] countSort(int[] arr)&#123;</span><br><span class="line">	&#x2F;&#x2F;找出数组中最大值和最小值</span><br><span class="line">	int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">	int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">	for(int num:arr)&#123;</span><br><span class="line">		max &#x3D; Math.max(max, num);</span><br><span class="line">		min &#x3D; Math.min(min, num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化计数数组count[]</span><br><span class="line">	&#x2F;&#x2F;长度为最大值减去最小值加1，再加1</span><br><span class="line">	int[] count &#x3D; new int[max-min+1+1];</span><br><span class="line">	&#x2F;&#x2F;计数，并确保count[0]永远为0</span><br><span class="line">	for(int num:arr)&#123;</span><br><span class="line">		count[num-min+1]++;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;计数数组变形，新元素是的值是前面元素的累加之和的值</span><br><span class="line">	for(int i&#x3D;1;i&lt;count.length;i++)&#123;</span><br><span class="line">		count[i] +&#x3D; count[i-1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建结果数组</span><br><span class="line">	int[] result &#x3D; new int[arr.length];</span><br><span class="line">	&#x2F;&#x2F;遍历arr中的元素，填充到结果数组中去，从前往后遍历</span><br><span class="line">	for(int j&#x3D;0;j&lt;arr.length;j++)&#123;</span><br><span class="line">		result[count[arr[j]-min]] &#x3D; arr[j];</span><br><span class="line">		count[arr[j]-min]++;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/12/15/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><pre><code>在一个有序数组中，查找目标值。每次与中间位置的值进行比较，若中间值比目标值大，则对左侧区域进行查找，right = mid - 1。否则对右侧区域进行查找，left = mid + 1。</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean exist(int[] arr, int num)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0) return false;</span><br><span class="line">	int L &#x3D; 0;</span><br><span class="line">	int right &#x3D; arr.length - 1;</span><br><span class="line">	int mid &#x3D; 0;</span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">		&#x2F;&#x2F;防止溢出</span><br><span class="line">	  mid &#x3D; left + ((right-left)&gt;&gt;1);</span><br><span class="line">	  if(arr[mid]&#x3D;&#x3D;num)return true;</span><br><span class="line">	  else if(arr[mid]&gt;num) right &#x3D; mid - 1;</span><br><span class="line">	  else left &#x3D; left + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr[mid] &#x3D;&#x3D; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="在数组上，找满足-gt-value的最左侧的值"><a href="#在数组上，找满足-gt-value的最左侧的值" class="headerlink" title="在数组上，找满足&gt;=value的最左侧的值"></a>在数组上，找满足&gt;=value的最左侧的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int nearestIndex(int[] arr, int value)&#123;</span><br><span class="line">	int left &#x3D; 0;</span><br><span class="line">	int right &#x3D; arr.length - 1;</span><br><span class="line">	int index &#x3D; -1;&#x2F;&#x2F;记录最左侧的下标</span><br><span class="line">	while(left &lt;&#x3D; right)&#123;</span><br><span class="line">		int mid &#x3D; left + ((right - left)&gt;&gt;1);</span><br><span class="line">		if(arr[mid]&gt;&#x3D;value)&#123;</span><br><span class="line">			index &#x3D; mid;</span><br><span class="line">			right &#x3D; mid - 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			left &#x3D; mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="寻找局部最小值"><a href="#寻找局部最小值" class="headerlink" title="寻找局部最小值"></a>寻找局部最小值</h4><pre><code>给定一个无序数组，相邻两个不相等，只要求找到一个局部最小。</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getLessIndex(int[] arr)&#123;</span><br><span class="line">	if(arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(arr.length &#x3D;&#x3D; 1 || arr[0] &lt; arr[1])&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(arr[arr.length - 2] &gt; arr[arr.length - 1])&#123;</span><br><span class="line">		return arr.length - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	int left &#x3D; 1;</span><br><span class="line">	int right &#x3D; arr.length - 2;</span><br><span class="line"></span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">		int mid &#x3D; left + ((right-left)&gt;&gt;1);</span><br><span class="line">		if(arr[mid] &gt; arr[mid - 1])&#123;</span><br><span class="line">			right &#x3D; mid - 1;</span><br><span class="line">		&#125;else if(arr[mid] &gt; arr[mid + 1])&#123;</span><br><span class="line">			left &#x3D; mid + 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>基础算法</tag>
        <tag>查找</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/12/11/shellsort/</url>
    <content><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>插入排序的升级版，每隔固定增量（gap）数量数组元素为不同组，对各组进行插入排序。然后，减小gap的值，再次分别对各组进行插入排序，直到gap==1，则排序完成。
由于开始时，gap的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期gap取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</code></pre>
<a id="more"></a>
<pre><code>第一趟取gap的方法是：n/3向下取整+1=3（关于gap的取法之后会有介绍）。将整个数据列划分为间隔为3的3个子序列，然后对每一个子序列执行直接插入排序，相当于对整个序列执行了部分排序调整。</code></pre>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><pre><code>int[] arr = &#123;3,2,4,1,8,5,6&#125;

初始化gap
h = 1
h = h*3+1

h&lt;=arr.length/3</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShellSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;3,2,4,1,8,5,6&#125;;</span><br><span class="line"></span><br><span class="line">		int h &#x3D; 1;</span><br><span class="line">		while(h&lt;&#x3D;arr.length&#x2F;3)&#123;</span><br><span class="line">			h&#x3D;h*3+1;</span><br><span class="line">		&#125;&#x2F;&#x2F;初始化gap的方法</span><br><span class="line"></span><br><span class="line">		for(int gap&#x3D;h;gap&gt;0;gap&#x3D;(gap-1)&#x2F;3)&#123;</span><br><span class="line">			for(int i&#x3D;gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">				for(int j&#x3D;i;j&gt;gap-1;j-&#x3D;gap)&#123;</span><br><span class="line">					if(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">						swap(arr,j,j-gap);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		arr[i] &#x3D; arr[j] + arr[i];</span><br><span class="line">		arr[j] &#x3D; arr[i] - arr[j];</span><br><span class="line">		arr[i] &#x3D; arr[i] - arr[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node1&#123;</span><br><span class="line">	int value;</span><br><span class="line">	Node1 left;</span><br><span class="line">	Node1 right;</span><br><span class="line">	Node1(int value)&#123;</span><br><span class="line">		value &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="二叉树的遍历，递归方式"><a href="#二叉树的遍历，递归方式" class="headerlink" title="二叉树的遍历，递归方式"></a>二叉树的遍历，递归方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先序</span><br><span class="line">public static void pre(Node1 head)&#123;</span><br><span class="line">	if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">	pre(head.left);</span><br><span class="line">	pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中序</span><br><span class="line">public static void in(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	in(head.left);</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">	in(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后序</span><br><span class="line">public static void pos(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	pos(head.left);</span><br><span class="line">	pos(head.right);</span><br><span class="line">	System.out.print(head.value+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的遍历，非递归方法"><a href="#二叉树的遍历，非递归方法" class="headerlink" title="二叉树的遍历，非递归方法"></a>二叉树的遍历，非递归方法</h4><h6 id="任何递归函数都可以改成非递归"><a href="#任何递归函数都可以改成非递归" class="headerlink" title="任何递归函数都可以改成非递归"></a>任何递归函数都可以改成非递归</h6><h6 id="可以通过设计栈来实现"><a href="#可以通过设计栈来实现" class="headerlink" title="可以通过设计栈来实现"></a>可以通过设计栈来实现</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的先序遍历，非递归方法</span><br><span class="line">public static void pre1(Node1 head)&#123;</span><br><span class="line">	if(head !&#x3D; null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack &#x3D; new Satck&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		while(!stack.isEmpty())&#123;</span><br><span class="line">			head &#x3D; stack.pop();</span><br><span class="line">			System.out.print(head.value + &quot; &quot;);</span><br><span class="line">			if(head.right!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">			if(head.left!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二叉树的后序遍历，非递归方法</span><br><span class="line">public static void pos1(Node1 head)&#123;</span><br><span class="line">	if(head!&#x3D;null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; s1 &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		Stack&lt;Node1&gt; s2 &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		s1.push(head);</span><br><span class="line">		while(!s1.isEmpty())&#123;</span><br><span class="line">			head &#x3D; s1.pop();</span><br><span class="line">			s2.push(head);</span><br><span class="line">			if(head.left!&#x3D;null)&#123;</span><br><span class="line">				s1.push(head.left);</span><br><span class="line">			&#125;</span><br><span class="line">			if(head.right!&#x3D;null)&#123;</span><br><span class="line">				s1.push(head.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!s2.isEmpty())&#123;</span><br><span class="line">		System.out.print(s2.pop().value+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用一个栈实现非递归的后序遍历</span><br><span class="line">public static void pos2(Node1 h)&#123;</span><br><span class="line">    if(h !&#x3D; null)&#123;</span><br><span class="line">        Stack&lt;Node1&gt; stack &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node1 c &#x3D; null;</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            c &#x3D; stack.peek();</span><br><span class="line">            if(c.left !&#x3D; null &amp;&amp; h!&#x3D;c.left &amp;&amp; h !&#x3D; c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;else if(c.right !&#x3D; null &amp;&amp; h!&#x3D;c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(stack.pop()+&quot; &quot;);</span><br><span class="line">                h&#x3D;c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二叉树的中序遍历，非递归方法</span><br><span class="line">&#x2F;&#x2F;1）整条左边界依次入栈 2）若1）无法继续，弹出打印，右树进行1）</span><br><span class="line">public static void in1(Node1 head)&#123;</span><br><span class="line">	if(head!&#x3D;null)&#123;</span><br><span class="line">		Stack&lt;Node1&gt; stack &#x3D; new Stack&lt;Node1&gt;();</span><br><span class="line">		stack.push(head);</span><br><span class="line">		while(!stack.siEmpty() || head!&#x3D;null)&#123;</span><br><span class="line">			if(head!&#x3D;null)&#123;</span><br><span class="line">				stack.push(head);</span><br><span class="line">				head &#x3D; head.left;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				head &#x3D; stack.pop();</span><br><span class="line">				System.out.print(head.value+&quot; &quot;);</span><br><span class="line">				head &#x3D; head.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现二叉树的按层遍历</span><br><span class="line"> * 1）其实就是宽度优先遍历，用队列</span><br><span class="line"> * 2）可以通过设置flag变量的方式，来发现某一层的结束</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public static void level(Node1)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if(queue.right!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出具有最大层的节点数，使用哈希表</span><br><span class="line">public static int maxWithUseMap(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	HashMap&lt;Node1, Integer&gt; levelMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">	levelMap.put(head, 1);</span><br><span class="line">	int curLevel &#x3D; 1;&#x2F;&#x2F;当前正在统计哪一层的宽度</span><br><span class="line">	int curLevelNodes &#x3D; 0;&#x2F;&#x2F;当前层的宽度</span><br><span class="line">	int max &#x3D; 0;</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		int curNodeLevel &#x3D; levelMap.get(cur);</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			levelMap.put(cur.left, curNodeLevel+1);</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if(cur.right!&#x3D;null)&#123;</span><br><span class="line">			levelMap.put(cur.right, curLevel+1);</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果当前节点所在的层与curLevel相同，则curLevelNodes+1,否则对上一层进行结算</span><br><span class="line">		if(curNodeLevel &#x3D;&#x3D; curLevel)&#123;</span><br><span class="line">			curLevelNodes++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">			curLevel++;</span><br><span class="line">			curLevelNodes &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	max &#x3D; max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出具有最大层的节点数，不使用哈希表</span><br><span class="line">public static int maxWidthNoMap(Node1 head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue&lt;Node1&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	queue.add(head);</span><br><span class="line">	Node1 curEnd &#x3D; head;&#x2F;&#x2F;当前层，最右节点</span><br><span class="line">	Node1 nextEnd &#x3D; head;&#x2F;&#x2F;下一层，最右节点</span><br><span class="line"></span><br><span class="line">	int max &#x3D; 0;</span><br><span class="line">	int curLevelNodes &#x3D; 0;&#x2F;&#x2F;当前层的节点数</span><br><span class="line">	while(!queue.isEmpty())&#123;</span><br><span class="line">		Node1 cur &#x3D; queue.poll();</span><br><span class="line">		if(cur.left!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.left);</span><br><span class="line">			nextEnd &#x3D; cur.left;</span><br><span class="line">		&#125;</span><br><span class="line">		if(cur.right!&#x3D;null)&#123;</span><br><span class="line">			queue.add(cur.right);</span><br><span class="line">			nextEnd &#x3D; cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		curLevelNodes++;</span><br><span class="line">		if(cur &#x3D;&#x3D; curEnd)&#123;</span><br><span class="line">			max &#x3D; Math.max(max, curLevelNodes);</span><br><span class="line">			curLevelNodes &#x3D; 0;</span><br><span class="line">			curEnd &#x3D; nextEnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二叉树的序列化与构建"><a href="#二叉树的序列化与构建" class="headerlink" title="二叉树的序列化与构建"></a>二叉树的序列化与构建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先序遍历序列化与重构</span><br><span class="line">public static Queue&lt;String&gt; preSerial(Node head)&#123;</span><br><span class="line">	Queue&lt;String&gt; ans &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">	pres(head, ans);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void pres(Node head, Queue&lt;String&gt; ans)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		ans.add(null);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		ans.add(String.valueOf(head.value));</span><br><span class="line">		pres(head.left, ans);</span><br><span class="line">		pres(head.right, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node buildByPreQueue(Queue&lt;String&gt; prelist)&#123;</span><br><span class="line">	if(prelist &#x3D;&#x3D; null || prelist.size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	return preb(prelist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node preb(Queue&lt;String&gt; prelist)&#123;</span><br><span class="line">	String value &#x3D; prelist.poll();</span><br><span class="line">	if(value &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head &#x3D; new Node(Integer.valueOf(value));</span><br><span class="line">	head.left &#x3D; preb(prelist);</span><br><span class="line">	head.right &#x3D; preb(prelist);</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按层序列化</span><br><span class="line">public static Queue&lt;String&gt; levelSerial(Node head)&#123;</span><br><span class="line">    Queue&lt;String&gt; ans &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">        ans.add(null);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        ans.add(String.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            head &#x3D; queue.poll();</span><br><span class="line">            if(head.left!&#x3D;null)&#123;</span><br><span class="line">                ans.add(String.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                ans.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">            if(head.right!&#x3D;null)&#123;</span><br><span class="line">                ans.add(String.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans.add(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node buildByLevelQueue(Queue&lt;String&gt; levelList)&#123;</span><br><span class="line">    if(levelList &#x3D;&#x3D; null || levelList.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head &#x3D; generateNode(levelList.poll());</span><br><span class="line">    Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;Node&gt;();</span><br><span class="line">    if(head !&#x3D; null)&#123;</span><br><span class="line">        queue.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; null;</span><br><span class="line">    while(!queue.isEmpty())&#123;</span><br><span class="line">        node &#x3D; queue.poll();</span><br><span class="line">        node.left &#x3D; generateNode(levelList.poll());</span><br><span class="line">        node.right &#x3D; generateNode(levelList.poll());</span><br><span class="line">        if(node.left !&#x3D; null)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right !&#x3D; null)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Node generateNode(String val) &#123;</span><br><span class="line">    if(val &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/12/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>比较两个相邻的元素，将值大的元素交换至右端。</code></pre>
<a id="more"></a>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一躺：首先比较第1个数和第2数，将小数放在前，大数放在后。然后比较第2数和第3数，将小数放在前，大数放在后，如此继续。直到比较最后两个数，将小数放在前，大数放在后。重复第一趟步骤，直到排序完成。

第一躺比较完成后，最后一个数一定是数组中最大的，所以第二趟时最后一个数不参与比较。
同理，第二趟完成后，倒数第二个一定是数组中第二大的，所以第三趟时，倒数两个数不参与比较。依次类推。。。

5,3,6,8,7,9,4,2

第一躺：
    第一次：5与3比较，5大于3，交换位置：3，5，6，8，7，9，4，2
    第二次：5与6比较，5小于6，不交换位置：3，5，6，8，7，9，4，2
    第三次：6与8比较，6小于8，不交换位置：3，5，6，8，7，9，4，2
    第四次：8与7比较，8大于7，交换位置：3，5，6，7，8，9，4，2
    第五次：8与9比较，8小于9，不交换位置：3，5，6，7，8，9，4，2
    第六次：9与4比较，9大于4，交换位置：3，5，6，7，8，4，9，2
    第七次：9与2比较，9大于2，交换位置：3，5，6，7，8，4，2，9

第二趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，8，4，2，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，8，4，2，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，8，4，2，9
    第四次：7与8比较，7小于8，不交换位置：3，5，6，7，8，4，2，9
    第五次：8与4比较，8大于4，交换位置：3，5，6，7，4，8，2，9
    第六次：8与2比较，8大于2，交换位置：3，5，6，7，4，2，8，9

第三趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，7，4，2，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，7，4，2，8，9
    第三次：6与7比较，6小于7，不交换位置：3，5，6，7，4，2，8，9
    第四次：7与4比较，7大于4，交换位置：3，5，6，4，7，2，8，9
    第五次：7与2比较，7大于2，交换位置：3，5，6，4，2，7，8，9

第四趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，6，4，2，7，8，9
    第二次：5与6比较，5小于6，不交换位置：3，5，6，4，2，7，8，9
    第三次：6与4比较，6大于4，交换位置：3，5，4，6，2，7，8，9
    第四次：6与2比较，6大于2，交换位置：3，5，4，2，6，7，8，9

第五趟：
    第一次：3与5比较，3小于5，不交换位置：3，5，4，2，6，7，8，9
    第二次：5与4比较，5大于4，交换位置：3，4，5，2，6，7，8，9
    第三次：5与2比较，5大于2，交换位置：3，4，2，5，6，7，8，9

第六趟：
    第一次：3与4比较，3小于4，不交换位置：3，4，2，5，6，7，8，9
    第二次：4与2比较，4大于2，交换位置：3，2，4，5，6，7，8，9

第七躺：
    第一次：3与2比较，3大于2，交换位置：2，3，4，5，6，7，8，9</code></pre>
<hr>
<pre><code>最终结果&#123;2，3，4，5，6，7，8，9&#125;</code></pre>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n^2)</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BubbleSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">				if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j+1];</span><br><span class="line">					arr[j+1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归套路</title>
    <url>/2020/12/19/%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
    <content><![CDATA[<h4 id="设计一个打印整棵树的打印函数"><a href="#设计一个打印整棵树的打印函数" class="headerlink" title="设计一个打印整棵树的打印函数"></a>设计一个打印整棵树的打印函数</h4>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2020/12/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><pre><code>^  相同为0，不同为1 ， 异或运算可以记成无相位相加（忽略仅为）6^7=1</code></pre>
<h5 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h5><pre><code>相同为1， 不同为0</code></pre>
<hr>
<a id="more"></a>
<h5 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h5><pre><code>1）0^N == N   N^N == 0
2) 异或运算满足交换律和结合律</code></pre>
<hr>
<h4 id="题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同"><a href="#题目一-如何不用额外变量交换两个数-保证，两个数的内存地址不同" class="headerlink" title="题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)"></a>题目一 如何不用额外变量交换两个数(保证，两个数的内存地址不同)</h4><pre><code>a = m, b = n
a = a^b  a = m^n, b = n
b = a^b  a = m^n, b = m^n^n = m^0 = m
a = a^b  a = m^n^m = n, b = m</code></pre>
<hr>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><pre><code>一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
全部异或，最终的结果即为出现了奇数次的数。</code></pre>
<hr>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><pre><code>怎么把一个int类型的数，提取出最右侧的1来。
int N
N = 0011 0101 0000
~N= 1100 1010 1111
~N+1 = 1100 1011 0000
ANS = N &amp; (~N + 1) = 0000 0001 0000</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组中，只有一种数出现了奇数次</span><br><span class="line">public void printOddTimesNum1(int[] arr)&#123;</span><br><span class="line">	int eor &#x3D; arr[0];</span><br><span class="line">	for(int i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor^&#x3D;arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.ptintln(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><pre><code>一个数组中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
eor = a ^ b != 0</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数组中，有两种数出现了两次</span><br><span class="line">public void printOddTimesNum2(int[] arr)&#123;</span><br><span class="line">	int eor &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">		eor ^&#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; eor &#x3D; a^b</span><br><span class="line">	&#x2F;&#x2F; eor !&#x3D; 0</span><br><span class="line">	&#x2F;&#x2F; eor必然有一个位置是1</span><br><span class="line">	int rightOne &#x3D; eor &amp; (~eor + 1);</span><br><span class="line">	int onlyOne &#x3D; 0;&#x2F;&#x2F;eor&#39;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">		if((arr[i] &amp; rightOne) !&#x3D; 0)&#123;</span><br><span class="line">			onlyOne ^&#x3D; arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>异或运算</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/12/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，将问题分为一些小问题然后递归求解，而治的阶段将分的阶段得到的各答案修补在一起。</code></pre>
<a id="more"></a>
<pre><code>归并排序的递归在sort函数，通过调用自身不断的将问题划分为子问题再合并。</code></pre>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MergeSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;1,4,7,8,3,6,9&#125;;</span><br><span class="line">		sort(arr, 0, arr.length-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void sort(int[] arr, int start, int end)&#123;</span><br><span class="line">		if(start&#x3D;&#x3D;end)return;</span><br><span class="line">		&#x2F;&#x2F;分成两块</span><br><span class="line">		int mid &#x3D; start + (end - start)&#x2F;2;</span><br><span class="line">		&#x2F;&#x2F;左边排序</span><br><span class="line">		sort(arr, start, mid);</span><br><span class="line">		&#x2F;&#x2F;右边排序</span><br><span class="line">		sort(arr, mide + 1, end);</span><br><span class="line"></span><br><span class="line">		merge(arr, start, mid + 1, end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void merge(int[] arr, int left, int mid, int right)&#123;</span><br><span class="line">		int i &#x3D; left;</span><br><span class="line">		int j &#x3D; mid + 1;</span><br><span class="line">		int k &#x3D; 0;</span><br><span class="line">		int[] temp &#x3D; new int[right - left + 1];</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">			if(arr[j] &lt;&#x3D; arr[j])temp[k++] &#x3D; arr[i++];</span><br><span class="line">			else temp[k++] &#x3D; arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while(i&lt;&#x3D;mid) temp[k++] &#x3D; arr[i++];</span><br><span class="line">		while(j&lt;&#x3D;right) temp[k++] &#x3D; arr[j++];</span><br><span class="line"></span><br><span class="line">		for(int m&#x3D;0; m&lt;temp.length; m++)&#123;</span><br><span class="line">			arr[left+m] &#x3D; temp[m];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">		int temp &#x3D; arr[i];</span><br><span class="line">		arr[i] &#x3D; arr[j];</span><br><span class="line">		arr[j] &#x3D; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/12/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h4><hr>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><pre><code>每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。一般从第二个数开始插。</code></pre>
<a id="more"></a>
<pre><code>5,3,6,8,7,2

第一步：3与5比较，3小于5，插到前面 ：3，5，6，8，7，2
第二步：6与5比较，6大于5，插到后面：3，5，6，8，7，2
第三步：8与6比较，8大于6，插到后面：3，5，6，8，7，2
第四步：7与8比较，7小于8，插到前面：3，5，6，7，8，2
        7与6比较，7大于6，插到后面：3，5，6，7，8，2
第五步：2与8比较，2小于8，插到前面：3，5，6，7，2，8
        2与7比较，2小于7，插到前面：3，5，6，2，7，8
        2与6比较，2小于6，插到前面：3，5，2，6，7，8
        2与5比较，2小于5，插到前面：3，2，5，6，7，8
        2与3比较，2小于3，插到前面：2，3，5，6，7，8


结果：2，3，5，6，7，8</code></pre>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><pre><code>O(n^2),最好是O(n)</code></pre>
<hr>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InsertSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int[] arr &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;1;i&lt;arr.length;i++)&#123;</span><br><span class="line">			for(int j&#x3D;i;j&gt;0;j--)&#123;</span><br><span class="line">				if(arr[j]&lt;arr[j-1])&#123;</span><br><span class="line">					int temp &#x3D; arr[j];</span><br><span class="line">					arr[j]&#x3D;arr[j-1];</span><br><span class="line">					arr[j-1]&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int num:arr)&#123;</span><br><span class="line">			System.out.print(num+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/12/15/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code>1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</code></pre>
<hr>
<a id="more"></a>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">	public int value;</span><br><span class="line">	public Node next;</span><br><span class="line"></span><br><span class="line">	public Node(int v)&#123;</span><br><span class="line">		value &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Node midOrUpMidNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有3个或以上的点</span><br><span class="line">	Node slow &#x3D; head.next;</span><br><span class="line">	Node fast &#x3D; head.next.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node midOrDownMidNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head.next;</span><br><span class="line">	Node fast &#x3D; head.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node midOrUpMidPreNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head;</span><br><span class="line">	Node fast &#x3D; head.next.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Node midOrDownMidPreNode(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;链表有2个或以上的点</span><br><span class="line">	Node slow &#x3D; head;</span><br><span class="line">	Node fast &#x3D; head.next;</span><br><span class="line">	while(fast.next!&#x3D;null &amp;&amp; fast.next.next!&#x3D;null)&#123;</span><br><span class="line">		slow &#x3D; slow.next;</span><br><span class="line">		fast &#x3D; fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个单链表的头节点head，请判断该链表是否为回文结构"><a href="#给定一个单链表的头节点head，请判断该链表是否为回文结构" class="headerlink" title="给定一个单链表的头节点head，请判断该链表是否为回文结构"></a>给定一个单链表的头节点head，请判断该链表是否为回文结构</h4><pre><code>1）栈方法特别简单（笔试用）
2）改原链表的方法需要注意边界（面试用）</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPalindrome1(Node head)&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();</span><br><span class="line">	Node cur &#x3D; head;</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		if(head.value !&#x3D; stack.pop().value)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		head &#x3D; head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;need o(1) extra space</span><br><span class="line">public boolean isPalindrome2(Node head)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	Node n1 &#x3D; head;</span><br><span class="line">	NOde n2 &#x3D; head;</span><br><span class="line">	while(n2.next!&#x3D; null &amp;&amp; n2.next.next!&#x3D;null)&#123;</span><br><span class="line">		n1 &#x3D; n1.next;&#x2F;&#x2F;n1-&gt;mid</span><br><span class="line">		n2 &#x3D; n2.next.next;&#x2F;&#x2F;n2-&gt;end</span><br><span class="line">	&#125;</span><br><span class="line">	n2 &#x3D; n1.next;&#x2F;&#x2F;n2-&gt;right part first node</span><br><span class="line">	n1.next &#x3D; null;&#x2F;&#x2F;mid.next-&gt;null</span><br><span class="line">	Node n3 &#x3D; null;</span><br><span class="line">	while(n2!&#x3D;null)&#123;&#x2F;&#x2F;right part convert</span><br><span class="line">		n3 &#x3D; n2.next;&#x2F;&#x2F;n3-&gt;save the node</span><br><span class="line">		n2.next &#x3D; n1;&#x2F;&#x2F;next of right node convert</span><br><span class="line">		n1 &#x3D; n2;&#x2F;&#x2F;n1 move</span><br><span class="line">		n2 &#x3D; n3;&#x2F;&#x2F;n2 move</span><br><span class="line">	&#125;</span><br><span class="line">	n3 &#x3D; n1; &#x2F;&#x2F; n3 -&gt; save last node</span><br><span class="line">	n2 &#x3D; head; &#x2F;&#x2F; n2 -&gt; left first node</span><br><span class="line">	boolean res &#x3D; true;</span><br><span class="line">	while(n1 !&#x3D; null &amp;&amp; n2!&#x3D; null)&#123; &#x2F;&#x2F; check palindrome</span><br><span class="line">		if(n1.value !&#x3D; n2.value)&#123;</span><br><span class="line">			res &#x3D; false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		n1 &#x3D; n1.next; &#x2F;&#x2F; left to mid</span><br><span class="line">		n2 &#x3D; n2.next; &#x2F;&#x2F; right to mid</span><br><span class="line">	&#125;</span><br><span class="line">	n1 &#x3D; n3.next;</span><br><span class="line">	n3.next &#x3D; null;</span><br><span class="line">	while(n1 !&#x3D; null)&#123;</span><br><span class="line">		n2 &#x3D; n1.next;</span><br><span class="line">		n1.next &#x3D; n3;</span><br><span class="line">		n3 &#x3D; n1;</span><br><span class="line">		n1 &#x3D; n2;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="将单向列表按某值划分为左边小，中间相等、右边大的形式"><a href="#将单向列表按某值划分为左边小，中间相等、右边大的形式" class="headerlink" title="将单向列表按某值划分为左边小，中间相等、右边大的形式"></a>将单向列表按某值划分为左边小，中间相等、右边大的形式</h4><pre><code>1）把链表放入数组里，在数组上做partition（笔试用）
2）分成小、中、大三部分，再把各部分之间串起来</code></pre>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Node listPartition1(Node head, int piovt)&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	Node cur &#x3D; head;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	while(cur!&#x3D;null)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	Node[] nodeArr &#x3D; new Node[i];</span><br><span class="line">	i &#x3D; 0;</span><br><span class="line">	cur &#x3D; head;</span><br><span class="line">	for(i &#x3D; 0; i!&#x3D;nodeArr.length;i++)&#123;</span><br><span class="line">		nodeArr[i] &#x3D; cur;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	arrPartition(nodeArr, pivot);</span><br><span class="line">	for(i &#x3D; 1; i !&#x3D; nodeArr.length; i++)&#123;</span><br><span class="line">		nodeArr[i-1].next &#x3D; nodeArr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nodeArr[i-1].next &#x3D; null;</span><br><span class="line">	return nodeArr[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void arrPartition(Node[] nodeArr, int pivot)&#123;</span><br><span class="line">	int samll &#x3D; -1;</span><br><span class="line">	int big &#x3D; nodeArr.length;</span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	while(index!&#x3D;big)&#123;</span><br><span class="line">		if(nodeArr[index].value&lt;piovt)&#123;</span><br><span class="line">			swap(nodeArr, ++small,index++);</span><br><span class="line">		&#125;else if(nodeArr[index].value&#x3D;&#x3D;piovt)&#123;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			swap(nodeArr, --big, index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;面试方法</span><br><span class="line">public Node listPartition2(Node head, int pivot)&#123;</span><br><span class="line">	Node sH &#x3D; null;&#x2F;&#x2F;small head</span><br><span class="line">	Node sT &#x3D; null;&#x2F;&#x2F;samll tail</span><br><span class="line">	Node eH &#x3D; null;&#x2F;&#x2F;equal head</span><br><span class="line">	Node eT &#x3D; null;&#x2F;&#x2F;equal tail</span><br><span class="line">	Node mH &#x3D; null;&#x2F;&#x2F;big head</span><br><span class="line">	Node MT &#x3D; null;&#x2F;&#x2F;big tail</span><br><span class="line">	Node next &#x3D; null;&#x2F;&#x2F;save the node</span><br><span class="line">	&#x2F;&#x2F;every node distributed to three lists</span><br><span class="line">	while(head!&#x3D;null)&#123;</span><br><span class="line">		next &#x3D; head.next;</span><br><span class="line">		head.next &#x3D; null;</span><br><span class="line">		if(head.value &lt; pivot)&#123;</span><br><span class="line">			if(sH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				sH &#x3D; head;</span><br><span class="line">				sT &#x3D; head;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				sT.next &#x3D; head;</span><br><span class="line">				sT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(head.value &#x3D;&#x3D; pivot)&#123;</span><br><span class="line">			if(eH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				eH &#x3D; head;</span><br><span class="line">				eT &#x3D; head;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				eT.next &#x3D; head;</span><br><span class="line">				eT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(mH &#x3D;&#x3D; null)&#123;</span><br><span class="line">				mH &#x3D; head;</span><br><span class="line">				mT &#x3D; head;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				mT.next &#x3D; head;</span><br><span class="line">				mT &#x3D; head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head &#x3D; next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;小于区域的尾巴，连等于区域的头，等于区域的尾巴</span><br><span class="line">	if(sT!&#x3D;null)&#123;&#x2F;&#x2F;如果有小于区域</span><br><span class="line">		sT.next &#x3D; eH;</span><br><span class="line">		eT &#x3D; eT &#x3D;&#x3D; null ? sT : eT;&#x2F;&#x2F;下一步，谁去连大于区域的头</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;上面的if，不管跑了没有，et</span><br><span class="line">	&#x2F;&#x2F;all reconnect</span><br><span class="line">	if(et!&#x3D;null)&#123;</span><br><span class="line">		eT.next &#x3D; mH;</span><br><span class="line">	&#125;</span><br><span class="line">	return sH !&#x3D; null ? sH : (eH !&#x3D; null ? eH : mH);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 一种特殊的单链表节点描述一下</span><br><span class="line">	class Node&#123;</span><br><span class="line">		int value;</span><br><span class="line">		Node next;</span><br><span class="line">		Node rand;</span><br><span class="line">		Node(int val)&#123;</span><br><span class="line">			value &#x3D; val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rand指针是单链表节点结构中新增的指针，rand可能指向链表中任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。【要求】时间复杂度O(N)，额外空间复杂度O(1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//笔试方法，使用HashMap<br>public Node copyListWithRand1(Node head){<br>    HashMap&lt;Node, Node&gt; map = new HashMap&lt;Node, Node&gt;();<br>    Node cur = head;<br>    while(cur != null){<br>        map.put(cur, new Node(cur.value));<br>        cur = cur.next;<br>    }<br>    cur = head;<br>    while(cur!=null){<br>        //cur 老节点<br>        //map.get(cur)新节点<br>        map.get(cur).next = map.get(cur.next);<br>        map.get(cur).rand = map.get(cut.rand);<br>        cur = cur.next;<br>    }<br>    return mp.get(head);<br>}</p>
<p>//面试用的方法<br>public Node copyListWithRand2(Node head){<br>    if(head == null){<br>        return null;<br>    }<br>    Node cur = head;<br>    Node next = null;<br>    //copy node and link to every node<br>    //1-&gt;2<br>    //1-&gt;1’-&gt;2<br>    while(cur!=null){<br>        next = cur.next;<br>        cur.next = new Node(cur.value);<br>        cur.next.next = next;<br>        cur = next;<br>    }<br>    cur = head;<br>    Node curCopy = null;<br>    //set copy node rand<br>    //1-&gt;1’-&gt;2-&gt;2’<br>    while(cur!=null){<br>        //cur 老<br>        //cur.next 新 copy<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        curCopy.rand = cur.rand != null ? cur.rand.next : null;<br>        cur = next;<br>    }<br>    Node res = head.next;<br>    cur = head;<br>    // split<br>    while(cur!=null){<br>        next = cur.next.next;<br>        curCopy = cur.next;<br>        cur.next = next;<br>        curCopy.next = next != null ? next.next : null;<br>        cur = next;<br>    }<br>    return res;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 两个可能有环链表的交点</span><br></pre></td></tr></table></figure>
<p>class Node{<br>    int value;<br>    Node next;<br>    Node(int v){<br>        value = v;<br>    }<br>}</p>
<p>public class LinkedTest {</p>
<pre><code>public static void main(String[] args) &#123;
    Node head = new Node(1);
    Node node2 = new Node(2);
    Node node3 = new Node(3);
    Node node4 = new Node(4);
    Node node5 = new Node(5);
    Node node6 = new Node(6);
    Node node7 = new Node(7);
    Node node8 = new Node(8);
    Node node9 = new Node(9);
    Node node10 = new Node(10);

    head.next = node2;
    node2.next = node3;
    node3.next = node4;
    node4.next = node5;
    node5.next = node6;
    node6.next = node7;
    node7.next = node8;
    node8.next = node9;
    node9.next = node10;
    node10.next = node5;

    Node crossNode = getLoopNode(head);
    System.out.println(crossNode.value);
&#125;

public static Node getIntersection(Node head1, Node head2)&#123;
    if(head1 == null || head2==null)&#123;
        return null;
    &#125;
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if(loop1==null &amp;&amp; loop2==null)&#123;
        return noLoop(head1, head2);
    &#125;
    if(loop1!=null &amp;&amp; loop2!=null)&#123;
        return  bothLoop(head1, loop1, head2, loop2);
    &#125;
    return null;
&#125;

//返回一个链表第一个入环的节点
public static Node getLoopNode(Node head)&#123;
    if(head ==null || head.next ==null || head.next.next == null)&#123;
        return null;
    &#125;
    // n1 慢 n2 快
    Node n1 = head.next; //n1-&gt;slow
    Node n2 = head.next.next; //n2-&gt;fast
    while(n1 != n2)&#123;
        if(n2.next == null || n2.next.next == null)&#123;
            return null;
        &#125;
        n2 = n2.next.next;
        n1 = n1.next;
    &#125;
    n2 = head;  //n2-&gt;walk again from head
    while(n1!=n2)&#123;
        n1 = n1.next;
        n2 = n2.next;
    &#125;
    return n1;
&#125;


//如果两个无环链表相交返回第一个相交的节点，如果不相交返回空
public static Node noLoop(Node head1, Node head2)&#123;
    if(head1 == null || head2 == null)&#123;
        return null;
    &#125;
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    while(cur1.next != null)&#123;
        n++;
        cur1 = cur1.next;
    &#125;
    while(cur1.next != null)&#123;
        n--;
        cur2 = cur2.next;
    &#125;
    if(cur1 != cur2)&#123;
        return null;
    &#125;
    //n : 链表1的长度减去链表2的长度
    cur1 = n &gt; 0 ? head1 : head2; //长的变为cur1
    cur2 = cur1 == head1 ? head2 : head1; //短的头节点为cur2
    n = Math.abs(n);
    while(n!=0)&#123;
        n--;
        cur1 = cur1.next;
    &#125;
    while(cur1 != cur2)&#123;
        cur1 = cur1.next;
        cur2 = cur2.next;
    &#125;
    return cur1;
&#125;

//两个链表都有环，返回第一个相交的节点，不相交则返回空
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2)&#123;
    Node cur1 = null;
    Node cur2 = null;
    if(loop1 == loop2)&#123;
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while(cur1!=loop1)&#123;
            n++;
            cur1 = cur1.next;
        &#125;
        while(cur2!=loop2)&#123;
            n--;
            cur2 = cur2.next;
        &#125;
        cur1 = n &gt; 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 :head1;
        n = Math.abs(n);
        while(n!=0)&#123;
            n--;
            cur1 = cur1.next;
        &#125;
        while(cur1!=cur2)&#123;
            cur1= cur1.next;
            cur2 = cur2.next;
        &#125;
        return cur1;
    &#125;else&#123;
        cur1 = loop1.next;
        while(cur1!=loop1)&#123;
            if(cur1 == loop2)&#123;
                return loop1;
            &#125;
            cur1 = cur1.next;
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<p>}<br>```</p>
]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法总结</title>
    <url>/2020/12/10/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><pre><code>基本不用，太慢</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><pre><code>基本不用，不稳定</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>样本小且基本有序的时候效率比较高</code></pre>
<a id="more"></a>]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/12/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><hr>
<h2 id="O-n-2-且不稳定"><a href="#O-n-2-且不稳定" class="headerlink" title="O(n^2) 且不稳定"></a>O(n^2) 且不稳定</h2><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><hr>
<p>每一遍找出所剩下的数中最小的那个和首位进行交换</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SelectionSort&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		int arr[] &#x3D; &#123;5,3,6,8,7,9,4,2&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for(int i &#x3D; 0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">			int minPos &#x3D; i;</span><br><span class="line"></span><br><span class="line">			for(int j&#x3D;i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">				minPos &#x3D; arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			int temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; temp;</span><br><span class="line">			arr[minPos] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
</search>
